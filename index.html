<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QQQLANG</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="favicon-192.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
      background: #000;
    }
    
    #app {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    
    #input-container {
      flex-shrink: 0;
      padding: 10px 10px 0 10px;
      background: #000;
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    
    #help-container {
      position: absolute;
      top: 54px;
      left: 10px;
      right: 10px;
      padding: 5px;
      font-family: monospace;
      font-size: 9px;
      color: #0f0;
      line-height: 1.3;
      word-break: break-all;
      overflow-wrap: anywhere;
      text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000,
        0 0 3px #000;
      pointer-events: none;
      z-index: 10;
    }
    
    #help-container .fn-name {
      font-weight: bold;
    }
    
    #help-container .fn-char {
      color: #888;
      text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000,
        0 0 3px #000;
    }
    
    @media (max-width: 600px) {
      #help-container {
        display: none;
      }
    }
    
    #input-wrapper {
      position: relative;
      flex: 1;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      height: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      background: transparent;
      color: transparent;
      caret-color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      background: #1a1a1a;
      color: #fff;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      padding: 1px 0;
    }
    
    #input-background span.upload-char {
      text-decoration: underline;
      text-decoration-style: dotted;
    }
    
    #input-background span.upload-char.upload-invalid {
      color: #666;
    }
    
    .toolbar-button {
      padding: 10px 15px;
      font-size: 14px;
      font-family: monospace;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
      min-width: 90px;
      width: 90px;
      text-align: center;
    }
    
    #upload-button {
      width: 90px;
    }
    
    #download-button {
      width: 100px;
    }
    
    .toolbar-button:hover:not(:disabled) {
      border-color: #888;
      background: #333;
    }
    
    .toolbar-button:active:not(:disabled) {
      background: #444;
    }
    
    .toolbar-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .toolbar-button .btn-icon {
      display: none;
    }
    
    .toolbar-button .btn-indicator.math {
      font-style: italic;
    }
    
    .toolbar-button .btn-rainbow {
      background: linear-gradient(to bottom, 
        #ff0000, #ff8000, #ffff00, #00ff00, #0080ff, #8000ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
    }
    
    @media (max-width: 600px) {
      .toolbar-button .btn-text {
        display: none;
      }
      .toolbar-button .btn-icon {
        display: inline;
        font-size: 18px;
      }
      .toolbar-button {
        padding: 10px 12px;
        min-width: 44px;
        width: 44px;
      }
      #upload-button, #download-button {
        width: 44px;
      }
    }
    
    #canvas-container {
      flex: 1;
      min-height: 0;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      margin-top: 10px;
    }
    
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
    
    #intro-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 1000;
      transition: opacity 1s ease-out;
    }
    
    #intro-overlay.fading {
      opacity: 0;
      pointer-events: none;
    }
    
    #intro-overlay.hidden {
      display: none;
    }
    
    #intro-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
  </style>
</head>
<body>
  <div id="app">
    <div id="input-container">
      <div id="input-wrapper">
        <div id="input-background"></div>
        <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
      </div>
      <button id="upload-button" class="toolbar-button" disabled>
        <span class="btn-text"><span class="btn-indicator math">ùëìùëõ</span></span>
        <span class="btn-icon">ùëì</span>
      </button>
      <button id="download-button" class="toolbar-button"><span class="btn-text">Download</span><span class="btn-icon">‚¨á</span></button>
      <button id="help-button" class="toolbar-button"><span class="btn-text">Help</span><span class="btn-icon">?</span></button>
    </div>
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div id="help-container"></div>
  <div id="debug-pane"></div>
  
  <div id="intro-overlay" class="hidden">
    <video id="intro-video" playsinline muted></video>
  </div>
  
  <input type="file" id="file-input" accept="image/*" style="display: none;">

  <script type="module">
    import { runProgram, getParsedOperations, getExpectedNextType, getExpectedTypeAtPosition, getInvalidUploadIndices, addUploadedBlob, setUploadedBlob, preloadUploadedImages, clearUploadedImages } from './runtime.ts';
    import { characterDefs, emeraldReady, bgRemovalReady, UPLOAD_CHAR, ChoiceType } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');
    const helpButton = document.getElementById('help-button');
    const downloadButton = document.getElementById('download-button');
    const uploadButton = document.getElementById('upload-button');
    const fileInput = document.getElementById('file-input');
    const helpContainer = document.getElementById('help-container');

    const introOverlay = document.getElementById('intro-overlay');
    const introVideo = document.getElementById('intro-video');

    let helpHideTimeout = null;

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    const INTRO_SEEN_KEY = 'qqqlang-intro-seen';
    const INTRO_DURATION_MS = 4000;
    const FADE_DURATION_MS = 1000;
    
    let pendingUploadIndex = null;
    
    function shouldShowIntro() {
      const params = new URLSearchParams(window.location.search);
      if (params.has('show-intro')) return true;
      if (params.has('p')) return false;
      if (localStorage.getItem(INTRO_SEEN_KEY)) return false;
      return true;
    }
    
    function showIntro() {
      introOverlay.classList.remove('hidden');
      
      introVideo.src = 'intro.mp4';
      introVideo.loop = true;
      introVideo.play().catch(() => {});
      
      setTimeout(() => {
        introOverlay.classList.add('fading');
        
        setTimeout(() => {
          introOverlay.classList.add('hidden');
          introVideo.pause();
          introVideo.src = '';
          
          localStorage.setItem(INTRO_SEEN_KEY, 'true');
          
          const program = '???';
          input.value = program;
          updateURL(program);
          render();
          input.focus();
        }, FADE_DURATION_MS);
      }, INTRO_DURATION_MS);
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs || char === UPLOAD_CHAR;
    }
    
    function completeProgram(program) {
      if (!program) return program;
      const ops = getParsedOperations(program);
      if (ops.length === 0) return program;
      
      const lastOp = ops[ops.length - 1];
      if (lastOp.type === 'function') {
        const def = lastOp.fnDef;
        const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
        const currentOpChars = [...lastOp.identifier.substring(prevIdentifier.length)];
        const argsProvided = currentOpChars.length - 1;
        const argsNeeded = def.arity - argsProvided;
        
        if (argsNeeded > 0) {
          const fnChar = currentOpChars[0];
          for (let i = 0; i < argsNeeded; i++) {
            program += fnChar;
          }
        }
      }
      return program;
    }
    
    function numToChar(num) {
      if (num >= 1 && num <= 26) return String.fromCharCode('A'.charCodeAt(0) + num - 1);
      if (num >= 27 && num <= 36) return String.fromCharCode('0'.charCodeAt(0) + num - 27);
      const symbols = '<>^!"#$%&\'()*+,-./:;=?@[\\]_`{|}~';
      const idx = num - 37;
      if (idx >= 0 && idx < symbols.length) return symbols[idx];
      return '?';
    }
    
    function updateHelpDisplay() {
      // Clear any pending hide timeout
      if (helpHideTimeout) {
        clearTimeout(helpHideTimeout);
        helpHideTimeout = null;
      }
      
      const program = input.value || '';
      const cursorPos = input.selectionStart ?? program.length;
      
      // Only show help if cursor is at the end of the program
      if (cursorPos !== program.length) {
        helpContainer.innerHTML = '';
        return;
      }
      
      if (!program) {
        helpContainer.innerHTML = '';
        return;
      }
      
      const ops = getParsedOperations(program);
      if (ops.length === 0) {
        helpContainer.innerHTML = '';
        return;
      }
      
      const lastOp = ops[ops.length - 1];
      
      if (lastOp.type !== 'function') {
        helpContainer.innerHTML = '';
        return;
      }
      
      const def = lastOp.fnDef;
      
      // Check if function is complete (has all arguments)
      const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
      const currentOpChars = [...lastOp.identifier.substring(prevIdentifier.length)];
      const argsProvided = currentOpChars.length - 1; // Subtract 1 for the function character itself
      
      // If function has no args (arity 0), show help briefly then hide after 1 second
      if (def.args.length === 0 && argsProvided === 0) {
        const char = [...lastOp.identifier].find(c => characterDefs[c] && characterDefs[c] === def) || '?';
        const firstLine = `${char} ${def.functionName} ‚Äî ${def.documentation}`;
        helpContainer.innerHTML = `<div>${firstLine}</div>`;
        
        helpHideTimeout = setTimeout(() => {
          helpContainer.innerHTML = '';
          helpHideTimeout = null;
        }, 1000);
        return;
      }
      
      if (argsProvided >= def.args.length) {
        // Function is complete, don't show help
        helpContainer.innerHTML = '';
        return;
      }
      
      const char = [...lastOp.identifier].find(c => characterDefs[c] && characterDefs[c] === def) || '?';
      
      // Format first line: C name ‚Äî doc
      const firstLine = `${char} ${def.functionName} ‚Äî ${def.documentation}`;
      let html = `<div>${firstLine}</div>`;
      
      // Format arg lines: (n) argDoc (A=x, B=y, ...)
      for (let i = 0; i < def.args.length; i++) {
        const arg = def.args[i];
        let argLine = `(${i + 1}) ${arg.documentation}`;
        
        if (arg.type instanceof ChoiceType) {
          const choices = arg.type.choices;
          const mappings = choices.map((choice, idx) => {
            return `${numToChar(idx + 1)}=${choice}`;
          }).join(', ');
          argLine += ` (${mappings})`;
        }
        
        html += `<div>${argLine}</div>`;
      }
      
      helpContainer.innerHTML = html;
    }
    
    function updateUploadButtonState() {
      const cursorPos = input.selectionStart ?? input.value.length;
      const expectedType = getExpectedTypeAtPosition(input.value, cursorPos);
      const btnText = uploadButton.querySelector('.btn-text .btn-indicator');
      const btnIcon = uploadButton.querySelector('.btn-icon');
      
      if (expectedType === 'initial' || expectedType === 'index') {
        uploadButton.disabled = false;
        btnText.className = 'btn-indicator';
        btnText.textContent = 'Upload';
        btnIcon.textContent = 'üì∑';
      } else if (expectedType === 'function') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator math';
        btnText.textContent = 'ùëìùëõ';
        btnIcon.textContent = 'ùëì';
      } else if (expectedType === 'int') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator math';
        btnText.textContent = 'ùë•';
        btnIcon.textContent = 'ùë•';
      } else if (expectedType === 'color') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator btn-rainbow';
        btnText.textContent = '‚ñ†';
        btnIcon.textContent = 'üåà';
      }
    }
    
    
    function getUploadCharIndex(str, charPosition) {
      let uploadIndex = 0;
      const chars = [...str];
      for (let i = 0; i < charPosition && i < chars.length; i++) {
        if (chars[i] === UPLOAD_CHAR) {
          uploadIndex++;
        }
      }
      return uploadIndex;
    }
    
    uploadButton.addEventListener('click', () => {
      const cursorPos = input.selectionStart ?? input.value.length;
      const expectedType = getExpectedTypeAtPosition(input.value, cursorPos);
      if (expectedType === 'initial' || expectedType === 'index') {
        pendingUploadIndex = null;
        fileInput.click();
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const blob = file;
      
      if (pendingUploadIndex !== null) {
        setUploadedBlob(pendingUploadIndex, blob);
        pendingUploadIndex = null;
      } else {
        addUploadedBlob(blob);
        
        const start = input.selectionStart;
        const before = input.value.substring(0, start);
        const after = input.value.substring(input.selectionEnd);
        input.value = before + UPLOAD_CHAR + after;
        input.selectionStart = input.selectionEnd = start + UPLOAD_CHAR.length;
      }
      
      fileInput.value = '';
      updateURL(input.value);
      await render();
      input.focus();
    });
    
    helpButton.addEventListener('click', () => {
      let program = input.value;
      if (!program) {
        program = 'A';
      }
      program = completeProgram(program);
      program += '??';
      input.value = program;
      updateURL(program);
      render();
      input.focus();
    });
    
    downloadButton.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'qqqlang-' + (input.value || 'empty') + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    function getProgramFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('p') || '';
    }

    function updateURL(program) {
      const params = new URLSearchParams(window.location.search);
      if (program) {
        params.set('p', program);
      } else {
        params.delete('p');
      }
      const newSearch = params.toString();
      const newURL = window.location.pathname + (newSearch ? '?' + newSearch : '');
      if (window.location.pathname + window.location.search !== newURL) {
        window.history.pushState({ program }, '', newURL);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else if (op.type === 'uploaded-image') {
          html += `<div class="op">[${i}] "${opChars}" uploaded-image(${op.uploadIndex})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.map(a => 
            typeof a === 'object' ? `upload:${a.index}` : a
          ).join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    let uploadCharPositions = [];
    let invalidUploadIndicesCache = new Set();
    
    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const invalidUploads = getInvalidUploadIndices(program);
      invalidUploadIndicesCache = invalidUploads;
      
      const chars = [...program].filter(c => {
        const code = c.codePointAt(0);
        return (code > 32 && code < 127) || c === UPLOAD_CHAR;
      });
      
      let html = '';
      let charIdx = 0;
      let uploadIdx = 0;
      uploadCharPositions = [];
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = [...op.identifier.substring(prevIdentifier.length)];
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else if (op.type === 'uploaded-image') {
          color = '#888888';
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            const char = chars[charIdx];
            if (char === UPLOAD_CHAR) {
              const isInvalid = invalidUploads.has(uploadIdx);
              const invalidClass = isInvalid ? ' upload-invalid' : '';
              const displayChar = isInvalid ? '‚ñ†' : char;
              html += `<span class="upload-char${invalidClass}" style="background-color: ${bgColor};" data-upload-index="${uploadIdx}" data-char-index="${charIdx}">${displayChar}</span>`;
              uploadCharPositions.push({ charIdx, uploadIdx, isInvalid });
              uploadIdx++;
            } else {
              html += `<span style="background-color: ${bgColor};">${char}</span>`;
            }
            charIdx++;
          }
        }
      }
      
      // Also render any remaining upload chars that weren't part of ops (invalid ones skipped)
      while (charIdx < chars.length) {
        const char = chars[charIdx];
        if (char === UPLOAD_CHAR) {
          const isInvalid = invalidUploads.has(uploadIdx);
          const invalidClass = isInvalid ? ' upload-invalid' : '';
          const displayChar = isInvalid ? '‚ñ†' : char;
          html += `<span class="upload-char${invalidClass}" style="background-color: #44444440;" data-upload-index="${uploadIdx}" data-char-index="${charIdx}">${displayChar}</span>`;
          uploadCharPositions.push({ charIdx, uploadIdx, isInvalid });
          uploadIdx++;
        } else {
          html += `<span style="background-color: #44444440;">${char}</span>`;
        }
        charIdx++;
      }
      
      inputBackground.innerHTML = html;
    }
    
    function isOverUploadChar(clientX) {
      if (uploadCharPositions.length === 0) return false;
      
      const inputRect = input.getBoundingClientRect();
      const clickX = clientX - inputRect.left;
      
      const spans = inputBackground.querySelectorAll('.upload-char:not(.upload-invalid)');
      for (const span of spans) {
        const spanRect = span.getBoundingClientRect();
        const bgRect = inputBackground.getBoundingClientRect();
        const spanLeft = spanRect.left - bgRect.left;
        const spanRight = spanLeft + spanRect.width;
        
        if (clickX >= spanLeft && clickX <= spanRight) {
          return true;
        }
      }
      return false;
    }
    
    function handleInputClick(e) {
      if (uploadCharPositions.length === 0) return;
      
      const inputRect = input.getBoundingClientRect();
      const clickX = e.clientX - inputRect.left;
      
      const spans = inputBackground.querySelectorAll('.upload-char:not(.upload-invalid)');
      for (const span of spans) {
        const spanRect = span.getBoundingClientRect();
        const bgRect = inputBackground.getBoundingClientRect();
        const spanLeft = spanRect.left - bgRect.left;
        const spanRight = spanLeft + spanRect.width;
        
        if (clickX >= spanLeft && clickX <= spanRight) {
          const idx = parseInt(span.dataset.uploadIndex, 10);
          pendingUploadIndex = idx;
          fileInput.click();
          e.preventDefault();
          return;
        }
      }
    }
    
    function handleInputMouseMove(e) {
      if (isOverUploadChar(e.clientX)) {
        input.style.cursor = 'pointer';
      } else {
        input.style.cursor = '';
      }
    }

    function resize() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }

    function updateFaviconAndTitle(program) {
      let favicon = document.getElementById('dynamic-favicon');
      if (!favicon) {
        favicon = document.createElement('link');
        favicon.id = 'dynamic-favicon';
        favicon.rel = 'icon';
        favicon.type = 'image/png';
        document.head.appendChild(favicon);
      }
      
      if (program) {
        document.title = 'QQQLANG - ' + program;
        
        const size = Math.min(canvas.width, canvas.height);
        const x = Math.floor((canvas.width - size) / 2);
        const y = Math.floor((canvas.height - size) / 2);
        
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.drawImage(canvas, x, y, size, size, 0, 0, 32, 32);
        
        favicon.href = faviconCanvas.toDataURL('image/png');
      } else {
        document.title = 'QQQLANG';
        favicon.href = 'favicon-32.png';
      }
    }
    
    async function render() {
      const program = input.value || '';
      
      await preloadUploadedImages(canvas.width, canvas.height);
      
      const images = await runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
      updateFaviconAndTitle(program);
      updateUploadButtonState();
      updateHelpDisplay();
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      
      clearUploadedImages();
      
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
      updateHelpDisplay();
    });
    
    input.addEventListener('keyup', () => {
      updateUploadButtonState();
      updateHelpDisplay();
    });
    input.addEventListener('mouseup', () => {
      updateUploadButtonState();
      updateHelpDisplay();
    });
    input.addEventListener('focus', () => {
      updateUploadButtonState();
      updateHelpDisplay();
    });
    
    input.addEventListener('click', handleInputClick);
    input.addEventListener('mousemove', handleInputMouseMove);
    input.addEventListener('mouseleave', () => { input.style.cursor = ''; });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    Promise.all([emeraldReady, bgRemovalReady]).then(() => {
      if (shouldShowIntro()) {
        showIntro();
        resize();
      } else {
        loadProgramFromURL();
        resize();
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Esoteric Image Language</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
      background: #000;
    }
    
    #app {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    
    #input-container {
      flex-shrink: 0;
      padding: 10px;
      background: #000;
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    
    #input-wrapper {
      position: relative;
      flex: 1;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      height: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      background: transparent;
      color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      background: #1a1a1a;
      color: transparent;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      padding: 1px 0;
    }
    
    .toolbar-button {
      padding: 10px 15px;
      font-size: 14px;
      font-family: monospace;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .toolbar-button:hover {
      border-color: #888;
      background: #333;
    }
    
    .toolbar-button:active {
      background: #444;
    }
    
    #canvas-container {
      flex: 1;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }
    
    #canvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="input-container">
      <div id="input-wrapper">
        <div id="input-background"></div>
        <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
      </div>
      <button id="download-button" class="toolbar-button">Download</button>
      <button id="help-button" class="toolbar-button">Help</button>
    </div>
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div id="debug-pane"></div>

  <script type="module">
    import { runProgram, getParsedOperations } from './runtime.ts';
    import { characterDefs, emeraldReady } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');
    const helpButton = document.getElementById('help-button');
    const downloadButton = document.getElementById('download-button');

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs;
    }
    
    function completeProgram(program) {
      if (!program) return program;
      const ops = getParsedOperations(program);
      if (ops.length === 0) return program;
      
      const lastOp = ops[ops.length - 1];
      if (lastOp.type === 'function') {
        const def = lastOp.fnDef;
        const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
        const currentOpChars = lastOp.identifier.substring(prevIdentifier.length);
        const argsProvided = currentOpChars.length - 1;
        const argsNeeded = def.arity - argsProvided;
        
        if (argsNeeded > 0) {
          const fnChar = currentOpChars[0];
          for (let i = 0; i < argsNeeded; i++) {
            program += fnChar;
          }
        }
      }
      return program;
    }
    
    helpButton.addEventListener('click', () => {
      let program = input.value;
      if (!program) {
        program = 'A';
      }
      program = completeProgram(program);
      program += '??';
      input.value = program;
      updateURL(program);
      render();
      input.focus();
    });
    
    downloadButton.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'qqqlang-' + (input.value || 'empty') + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    const BASE_PATH = import.meta.env.BASE_URL || '/';
    
    function getProgramFromURL() {
      const path = window.location.pathname;
      const basePath = BASE_PATH.endsWith('/') ? BASE_PATH : BASE_PATH + '/';
      const programPath = path.startsWith(basePath) ? path.substring(basePath.length) : path.substring(1);
      return decodeURIComponent(programPath);
    }

    function updateURL(program) {
      const search = window.location.search;
      const basePath = BASE_PATH.endsWith('/') ? BASE_PATH : BASE_PATH + '/';
      const newPath = program ? `${basePath}${encodeURIComponent(program)}${search}` : `${basePath}${search}`;
      if (window.location.pathname + window.location.search !== newPath) {
        window.history.pushState({ program }, '', newPath);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
      
      let html = '';
      let charIdx = 0;
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            html += `<span style="background-color: ${bgColor};">${chars[charIdx]}</span>`;
            charIdx++;
          }
        }
      }
      
      inputBackground.innerHTML = html;
    }

    function resize() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }

    function render() {
      const program = input.value || '';
      const images = runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
    });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    // Wait for emerald model to load before first render
    emeraldReady.then(() => {
      loadProgramFromURL();
      resize();
    });
  </script>
</body>
</html>

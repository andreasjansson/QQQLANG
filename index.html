<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Esoteric Image Language</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
    }
    
    #input-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      padding: 10px;
      background: rgba(0, 0, 0, 0.7);
    }
    
    #program-input {
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      border-radius: 4px;
      background: #1a1a1a;
      color: #fff;
      outline: none;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="input-container">
    <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus>
  </div>

  <script type="module">
    // Inline the character definitions and runtime
    
    function hexToRgb(hex) {
      const h = hex.replace('#', '');
      return [
        parseInt(h.substring(0, 2), 16),
        parseInt(h.substring(2, 4), 16),
        parseInt(h.substring(4, 6), 16),
      ];
    }

    function createSolidImage(width, height, color) {
      const [r, g, b] = hexToRgb(color);
      const data = new Uint8ClampedArray(width * height * 4);
      for (let i = 0; i < width * height; i++) {
        data[i * 4] = r;
        data[i * 4 + 1] = g;
        data[i * 4 + 2] = b;
        data[i * 4 + 3] = 255;
      }
      return { width, height, data };
    }

    function cloneImage(img) {
      return {
        width: img.width,
        height: img.height,
        data: new Uint8ClampedArray(img.data),
      };
    }

    function getPixel(img, x, y) {
      const cx = Math.max(0, Math.min(img.width - 1, Math.floor(x)));
      const cy = Math.max(0, Math.min(img.height - 1, Math.floor(y)));
      const i = (cy * img.width + cx) * 4;
      return [img.data[i], img.data[i + 1], img.data[i + 2], img.data[i + 3]];
    }

    function setPixel(img, x, y, r, g, b, a = 255) {
      if (x < 0 || x >= img.width || y < 0 || y >= img.height) return;
      const i = (y * img.width + x) * 4;
      img.data[i] = r;
      img.data[i + 1] = g;
      img.data[i + 2] = b;
      img.data[i + 3] = a;
    }

    function bilinearSample(img, x, y) {
      const x0 = Math.floor(x);
      const y0 = Math.floor(y);
      const x1 = x0 + 1;
      const y1 = y0 + 1;
      const fx = x - x0;
      const fy = y - y0;
      const p00 = getPixel(img, x0, y0);
      const p10 = getPixel(img, x1, y0);
      const p01 = getPixel(img, x0, y1);
      const p11 = getPixel(img, x1, y1);
      const result = [0, 0, 0, 0];
      for (let c = 0; c < 4; c++) {
        result[c] = Math.round(
          p00[c] * (1 - fx) * (1 - fy) +
          p10[c] * fx * (1 - fy) +
          p01[c] * (1 - fx) * fy +
          p11[c] * fx * fy
        );
      }
      return result;
    }

    function getPrevImage(ctx) {
      if (ctx.images.length === 0) {
        return createSolidImage(ctx.width, ctx.height, '#000000');
      }
      return ctx.images[ctx.images.length - 1];
    }

    function getOldImage(ctx, i) {
      if (ctx.images.length <= 1) return getPrevImage(ctx);
      const idx = Math.abs(i) % ctx.images.length;
      return ctx.images[idx];
    }

    // All the transformation functions
    function tile2x2FlipMirror(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const hw = ctx.width / 2;
      const hh = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          let sx, sy;
          const qx = x < hw ? 0 : 1;
          const qy = y < hh ? 0 : 1;
          const lx = x < hw ? x : x - hw;
          const ly = y < hh ? y : y - hh;
          const nx = (lx / hw) * prev.width;
          const ny = (ly / hh) * prev.height;
          if (qx === 0 && qy === 0) { sx = prev.width - 1 - nx; sy = prev.height - 1 - ny; }
          else if (qx === 1 && qy === 0) { sx = nx; sy = prev.height - 1 - ny; }
          else if (qx === 0 && qy === 1) { sx = prev.width - 1 - nx; sy = ny; }
          else { sx = nx; sy = ny; }
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function tile2x2Plain(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const hw = ctx.width / 2;
      const hh = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const lx = x % hw;
          const ly = y % hh;
          const sx = (lx / hw) * prev.width;
          const sy = (ly / hh) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function horizontalRepeat(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const count = Math.max(1, Math.min(n, 20));
      const tileW = ctx.width / count;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const lx = x % tileW;
          const sx = (lx / tileW) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function verticalRepeat(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const count = Math.max(1, Math.min(n, 20));
      const tileH = ctx.height / count;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const ly = y % tileH;
          const sx = (x / ctx.width) * prev.width;
          const sy = (ly / tileH) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function gridRepeat(ctx, n, m) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const cols = Math.max(1, Math.min(n, 20));
      const rows = Math.max(1, Math.min(m, 20));
      const tileW = ctx.width / cols;
      const tileH = ctx.height / rows;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const lx = x % tileW;
          const ly = y % tileH;
          const sx = (lx / tileW) * prev.width;
          const sy = (ly / tileH) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function horizontalRepeatUnequal(ctx, n, m) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const count = Math.max(1, Math.min(n, 20));
      const shrink = Math.max(0.1, Math.min(2, m / 100));
      const tileW = (ctx.width / count) * shrink;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const lx = x % tileW;
          const sx = (lx / tileW) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function rotate90(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (y / ctx.height) * prev.width;
          const sy = (1 - x / ctx.width) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function rotate180(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (1 - x / ctx.width) * prev.width;
          const sy = (1 - y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function rotate270(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (1 - y / ctx.height) * prev.width;
          const sy = (x / ctx.width) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function flipHorizontal(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (1 - x / ctx.width) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function flipVertical(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x / ctx.width) * prev.width;
          const sy = (1 - y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function skewHorizontal(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const skew = (n - 50) / 100;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const offset = (y / ctx.height - 0.5) * skew * ctx.width;
          const sx = ((x - offset) / ctx.width) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function skewVertical(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const skew = (n - 50) / 100;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const offset = (x / ctx.width - 0.5) * skew * ctx.height;
          const sx = (x / ctx.width) * prev.width;
          const sy = ((y - offset) / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function waveHorizontal(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const amp = (n / 100) * 0.1;
      const freq = 4;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const offset = Math.sin((y / ctx.height) * Math.PI * freq) * amp * ctx.width;
          const sx = ((x - offset) / ctx.width) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function waveVertical(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const amp = (n / 100) * 0.1;
      const freq = 4;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const offset = Math.sin((x / ctx.width) * Math.PI * freq) * amp * ctx.height;
          const sx = (x / ctx.width) * prev.width;
          const sy = ((y - offset) / ctx.height) * prev.height;
          const [r, g, b, a] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function swirl(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const strength = ((n - 50) / 50) * Math.PI;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxR = Math.sqrt(cx * cx + cy * cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const r = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + strength * (1 - r / maxR);
          const sx = (cx + r * Math.cos(angle)) / ctx.width * prev.width;
          const sy = (cy + r * Math.sin(angle)) / ctx.height * prev.height;
          const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, cr, cg, cb, ca);
        }
      }
      return out;
    }

    function fisheye(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const strength = Math.max(0.1, n / 50);
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxR = Math.min(cx, cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = (x - cx) / maxR;
          const dy = (y - cy) / maxR;
          const r = Math.sqrt(dx * dx + dy * dy);
          const nr = Math.pow(r, strength) / r || 0;
          const sx = (cx + dx * nr * maxR) / ctx.width * prev.width;
          const sy = (cy + dy * nr * maxR) / ctx.height * prev.height;
          const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, cr, cg, cb, ca);
        }
      }
      return out;
    }

    function barrel(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const k = (n - 50) / 200;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = (x - cx) / cx;
          const dy = (y - cy) / cy;
          const r2 = dx * dx + dy * dy;
          const factor = 1 + k * r2;
          const sx = (cx + dx * factor * cx) / ctx.width * prev.width;
          const sy = (cy + dy * factor * cy) / ctx.height * prev.height;
          const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, cr, cg, cb, ca);
        }
      }
      return out;
    }

    function pinch(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const strength = (n - 50) / 100;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxR = Math.min(cx, cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const r = Math.sqrt(dx * dx + dy * dy);
          const nr = r / maxR;
          const factor = nr < 1 ? Math.pow(Math.sin(Math.PI * nr / 2), strength) : 1;
          const sx = (cx + dx * factor) / ctx.width * prev.width;
          const sy = (cy + dy * factor) / ctx.height * prev.height;
          const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, cr, cg, cb, ca);
        }
      }
      return out;
    }

    function spherize(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxR = Math.min(cx, cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = (x - cx) / maxR;
          const dy = (y - cy) / maxR;
          const r = Math.sqrt(dx * dx + dy * dy);
          if (r < 1) {
            const z = Math.sqrt(1 - r * r);
            const sx = (cx + dx * (1 - z) * maxR) / ctx.width * prev.width;
            const sy = (cy + dy * (1 - z) * maxR) / ctx.height * prev.height;
            const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
            setPixel(out, x, y, cr, cg, cb, ca);
          } else {
            const sx = x / ctx.width * prev.width;
            const sy = y / ctx.height * prev.height;
            const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
            setPixel(out, x, y, cr, cg, cb, ca);
          }
        }
      }
      return out;
    }

    function ripple(ctx, n, m) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const amp = (n / 100) * 20;
      const freq = Math.max(1, m / 10);
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const r = Math.sqrt(dx * dx + dy * dy);
          const offset = Math.sin(r / freq) * amp;
          const angle = Math.atan2(dy, dx);
          const sx = (x + Math.cos(angle) * offset) / ctx.width * prev.width;
          const sy = (y + Math.sin(angle) * offset) / ctx.height * prev.height;
          const [cr, cg, cb, ca] = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, cr, cg, cb, ca);
        }
      }
      return out;
    }

    function solarizeBlend(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = cloneImage(prev);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const oidx = (oy * old.width + ox) * 4;
          for (let c = 0; c < 3; c++) {
            const v = out.data[idx + c];
            const ov = old.data[oidx + c];
            out.data[idx + c] = v < 128 ? v : Math.abs(255 - v - ov);
          }
        }
      }
      return out;
    }

    function blendMultiply(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = cloneImage(prev);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const oidx = (oy * old.width + ox) * 4;
          for (let c = 0; c < 3; c++) {
            out.data[idx + c] = (out.data[idx + c] * old.data[oidx + c]) / 255;
          }
        }
      }
      return out;
    }

    function blendScreen(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = cloneImage(prev);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const oidx = (oy * old.width + ox) * 4;
          for (let c = 0; c < 3; c++) {
            out.data[idx + c] = 255 - ((255 - out.data[idx + c]) * (255 - old.data[oidx + c])) / 255;
          }
        }
      }
      return out;
    }

    function blendDifference(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = cloneImage(prev);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const oidx = (oy * old.width + ox) * 4;
          for (let c = 0; c < 3; c++) {
            out.data[idx + c] = Math.abs(out.data[idx + c] - old.data[oidx + c]);
          }
        }
      }
      return out;
    }

    function blendOverlay(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = cloneImage(prev);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const oidx = (oy * old.width + ox) * 4;
          for (let c = 0; c < 3; c++) {
            const a = out.data[idx + c];
            const b = old.data[oidx + c];
            out.data[idx + c] = a < 128 ? (2 * a * b) / 255 : 255 - (2 * (255 - a) * (255 - b)) / 255;
          }
        }
      }
      return out;
    }

    function checkerboardBlend(ctx, i, n) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const size = Math.max(4, n);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const checker = (Math.floor(x / size) + Math.floor(y / size)) % 2;
          const src = checker ? prev : old;
          const sx = Math.floor((x / ctx.width) * src.width);
          const sy = Math.floor((y / ctx.height) * src.height);
          const sidx = (sy * src.width + sx) * 4;
          const idx = (y * ctx.width + x) * 4;
          out.data[idx] = src.data[sidx];
          out.data[idx + 1] = src.data[sidx + 1];
          out.data[idx + 2] = src.data[sidx + 2];
          out.data[idx + 3] = 255;
        }
      }
      return out;
    }

    function diagonalTileBlend(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const hw = ctx.width / 2;
      const hh = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const qx = x < hw ? 0 : 1;
          const qy = y < hh ? 0 : 1;
          const src = (qx === qy) ? prev : old;
          const lx = x < hw ? x : x - hw;
          const ly = y < hh ? y : y - hh;
          const sx = (lx / hw) * src.width;
          const sy = (ly / hh) * src.height;
          const [r, g, b, a] = bilinearSample(src, sx, sy);
          setPixel(out, x, y, r, g, b, a);
        }
      }
      return out;
    }

    function horizontalLine(ctx, c, w) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const lineW = Math.max(1, Math.min(w, ctx.height / 2));
      const cy = Math.floor(ctx.height / 2);
      for (let y = cy - Math.floor(lineW / 2); y < cy + Math.ceil(lineW / 2); y++) {
        for (let x = 0; x < ctx.width; x++) {
          setPixel(out, x, y, r, g, b);
        }
      }
      return out;
    }

    function verticalLine(ctx, c, w) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const lineW = Math.max(1, Math.min(w, ctx.width / 2));
      const cx = Math.floor(ctx.width / 2);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = cx - Math.floor(lineW / 2); x < cx + Math.ceil(lineW / 2); x++) {
          setPixel(out, x, y, r, g, b);
        }
      }
      return out;
    }

    function border(ctx, c, w) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const bw = Math.max(1, Math.min(w, Math.min(ctx.width, ctx.height) / 4));
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          if (x < bw || x >= ctx.width - bw || y < bw || y >= ctx.height - bw) {
            setPixel(out, x, y, r, g, b);
          }
        }
      }
      return out;
    }

    function circle(ctx, c, radius) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const rad = Math.max(5, Math.min(radius, Math.min(ctx.width, ctx.height) / 2));
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= rad && dist >= rad - 3) {
            setPixel(out, x, y, r, g, b);
          }
        }
      }
      return out;
    }

    function filledCircle(ctx, c, radius) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const rad = Math.max(5, Math.min(radius, Math.min(ctx.width, ctx.height) / 2));
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          if (dx * dx + dy * dy <= rad * rad) {
            setPixel(out, x, y, r, g, b);
          }
        }
      }
      return out;
    }

    function gradientOverlay(ctx, c) {
      const prev = getPrevImage(ctx);
      console.log('  gradientOverlay: color arg =', c, 'prev size:', prev.width, 'x', prev.height);
      const out = cloneImage(prev);
      const [gr, gg, gb] = hexToRgb(c);
      console.log('  gradientOverlay: RGB =', gr, gg, gb);
      for (let y = 0; y < ctx.height; y++) {
        const t = y / ctx.height;
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          out.data[idx] = Math.round(out.data[idx] * (1 - t) + gr * t);
          out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - t) + gg * t);
          out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - t) + gb * t);
        }
      }
      return out;
    }

    function horizontalGradientOverlay(ctx, c) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [gr, gg, gb] = hexToRgb(c);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const t = x / ctx.width;
          const idx = (y * ctx.width + x) * 4;
          out.data[idx] = Math.round(out.data[idx] * (1 - t) + gr * t);
          out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - t) + gg * t);
          out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - t) + gb * t);
        }
      }
      return out;
    }

    function invert(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = 255 - out.data[i];
        out.data[i + 1] = 255 - out.data[i + 1];
        out.data[i + 2] = 255 - out.data[i + 2];
      }
      return out;
    }

    function grayscale(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
        out.data[i] = gray;
        out.data[i + 1] = gray;
        out.data[i + 2] = gray;
      }
      return out;
    }

    function sepia(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        const r = out.data[i];
        const g = out.data[i + 1];
        const b = out.data[i + 2];
        out.data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
        out.data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
        out.data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
      }
      return out;
    }

    function posterize(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const levels = Math.max(2, Math.min(n, 32));
      const step = 255 / (levels - 1);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.round(Math.round(out.data[i] / step) * step);
        out.data[i + 1] = Math.round(Math.round(out.data[i + 1] / step) * step);
        out.data[i + 2] = Math.round(Math.round(out.data[i + 2] / step) * step);
      }
      return out;
    }

    function shiftHue(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const shift = (n / 100) * 360;
      for (let i = 0; i < out.data.length; i += 4) {
        const r = out.data[i] / 255;
        const g = out.data[i + 1] / 255;
        const b = out.data[i + 2] / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h = 0, s = 0;
        if (max !== min) {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
          else if (max === g) h = ((b - r) / d + 2) / 6;
          else h = ((r - g) / d + 4) / 6;
        }
        h = (h + shift / 360) % 1;
        let nr, ng, nb;
        if (s === 0) {
          nr = ng = nb = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          const hue2rgb = (t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          nr = hue2rgb(h + 1/3);
          ng = hue2rgb(h);
          nb = hue2rgb(h - 1/3);
        }
        out.data[i] = Math.round(nr * 255);
        out.data[i + 1] = Math.round(ng * 255);
        out.data[i + 2] = Math.round(nb * 255);
      }
      return out;
    }

    function increaseSaturation(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const factor = 1 + n / 50;
      for (let i = 0; i < out.data.length; i += 4) {
        const gray = out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114;
        out.data[i] = Math.min(255, Math.max(0, gray + (out.data[i] - gray) * factor));
        out.data[i + 1] = Math.min(255, Math.max(0, gray + (out.data[i + 1] - gray) * factor));
        out.data[i + 2] = Math.min(255, Math.max(0, gray + (out.data[i + 2] - gray) * factor));
      }
      return out;
    }

    function decreaseSaturation(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const factor = Math.max(0, 1 - n / 100);
      for (let i = 0; i < out.data.length; i += 4) {
        const gray = out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114;
        out.data[i] = gray + (out.data[i] - gray) * factor;
        out.data[i + 1] = gray + (out.data[i + 1] - gray) * factor;
        out.data[i + 2] = gray + (out.data[i + 2] - gray) * factor;
      }
      return out;
    }

    function increaseBrightness(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const amount = n * 2;
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.min(255, out.data[i] + amount);
        out.data[i + 1] = Math.min(255, out.data[i + 1] + amount);
        out.data[i + 2] = Math.min(255, out.data[i + 2] + amount);
      }
      return out;
    }

    function decreaseBrightness(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const amount = n * 2;
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.max(0, out.data[i] - amount);
        out.data[i + 1] = Math.max(0, out.data[i + 1] - amount);
        out.data[i + 2] = Math.max(0, out.data[i + 2] - amount);
      }
      return out;
    }

    function threshold(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const thresh = n * 2.55;
      for (let i = 0; i < out.data.length; i += 4) {
        const gray = out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114;
        const v = gray > thresh ? 255 : 0;
        out.data[i] = v;
        out.data[i + 1] = v;
        out.data[i + 2] = v;
      }
      return out;
    }

    function swapRG(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        const tmp = out.data[i];
        out.data[i] = out.data[i + 1];
        out.data[i + 1] = tmp;
      }
      return out;
    }

    function swapRB(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        const tmp = out.data[i];
        out.data[i] = out.data[i + 2];
        out.data[i + 2] = tmp;
      }
      return out;
    }

    function swapGB(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        const tmp = out.data[i + 1];
        out.data[i + 1] = out.data[i + 2];
        out.data[i + 2] = tmp;
      }
      return out;
    }

    function blur(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
      const kSum = 16;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const px = getPixel(prev, x + kx, y + ky);
              const k = kernel[(ky + 1) * 3 + (kx + 1)];
              r += px[0] * k;
              g += px[1] * k;
              b += px[2] * k;
            }
          }
          setPixel(out, x, y, r / kSum, g / kSum, b / kSum);
        }
      }
      return out;
    }

    function strongBlur(ctx, n) {
      let img = getPrevImage(ctx);
      const iterations = Math.max(1, Math.min(Math.floor(n / 10), 10));
      for (let iter = 0; iter < iterations; iter++) {
        const out = createSolidImage(ctx.width, ctx.height, '#000000');
        for (let y = 0; y < ctx.height; y++) {
          for (let x = 0; x < ctx.width; x++) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let ky = -2; ky <= 2; ky++) {
              for (let kx = -2; kx <= 2; kx++) {
                const px = getPixel(img, x + kx, y + ky);
                r += px[0];
                g += px[1];
                b += px[2];
                count++;
              }
            }
            setPixel(out, x, y, r / count, g / count, b / count);
          }
        }
        img = out;
      }
      return img;
    }

    function sharpen(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const px = getPixel(prev, x + kx, y + ky);
              const k = kernel[(ky + 1) * 3 + (kx + 1)];
              r += px[0] * k;
              g += px[1] * k;
              b += px[2] * k;
            }
          }
          setPixel(out, x, y, Math.max(0, Math.min(255, r)), Math.max(0, Math.min(255, g)), Math.max(0, Math.min(255, b)));
        }
      }
      return out;
    }

    function edgeDetect(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const px = getPixel(prev, x + kx, y + ky);
              const k = kernel[(ky + 1) * 3 + (kx + 1)];
              r += px[0] * k;
              g += px[1] * k;
              b += px[2] * k;
            }
          }
          setPixel(out, x, y, Math.max(0, Math.min(255, r)), Math.max(0, Math.min(255, g)), Math.max(0, Math.min(255, b)));
        }
      }
      return out;
    }

    function emboss(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const kernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const px = getPixel(prev, x + kx, y + ky);
              const k = kernel[(ky + 1) * 3 + (kx + 1)];
              r += px[0] * k;
              g += px[1] * k;
              b += px[2] * k;
            }
          }
          setPixel(out, x, y, Math.max(0, Math.min(255, r + 128)), Math.max(0, Math.min(255, g + 128)), Math.max(0, Math.min(255, b + 128)));
        }
      }
      return out;
    }

    function pixelate(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const size = Math.max(2, Math.min(n, 50));
      for (let by = 0; by < ctx.height; by += size) {
        for (let bx = 0; bx < ctx.width; bx += size) {
          let r = 0, g = 0, b = 0, count = 0;
          for (let y = by; y < by + size && y < ctx.height; y++) {
            for (let x = bx; x < bx + size && x < ctx.width; x++) {
              const px = getPixel(prev, x, y);
              r += px[0];
              g += px[1];
              b += px[2];
              count++;
            }
          }
          r = Math.round(r / count);
          g = Math.round(g / count);
          b = Math.round(b / count);
          for (let y = by; y < by + size && y < ctx.height; y++) {
            for (let x = bx; x < bx + size && x < ctx.width; x++) {
              setPixel(out, x, y, r, g, b);
            }
          }
        }
      }
      return out;
    }

    function noiseOverlay(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const amount = n / 100;
      for (let i = 0; i < out.data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 255 * amount;
        out.data[i] = Math.max(0, Math.min(255, out.data[i] + noise));
        out.data[i + 1] = Math.max(0, Math.min(255, out.data[i + 1] + noise));
        out.data[i + 2] = Math.max(0, Math.min(255, out.data[i + 2] + noise));
      }
      return out;
    }

    function scanlines(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const gap = Math.max(2, Math.min(n, 20));
      for (let y = 0; y < ctx.height; y++) {
        if (y % gap === 0) {
          for (let x = 0; x < ctx.width; x++) {
            const idx = (y * ctx.width + x) * 4;
            out.data[idx] = out.data[idx] * 0.5;
            out.data[idx + 1] = out.data[idx + 1] * 0.5;
            out.data[idx + 2] = out.data[idx + 2] * 0.5;
          }
        }
      }
      return out;
    }

    function vignette(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const strength = n / 100;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxD = Math.sqrt(cx * cx + cy * cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const d = Math.sqrt(dx * dx + dy * dy) / maxD;
          const factor = 1 - d * strength;
          const idx = (y * ctx.width + x) * 4;
          out.data[idx] = out.data[idx] * factor;
          out.data[idx + 1] = out.data[idx + 1] * factor;
          out.data[idx + 2] = out.data[idx + 2] * factor;
        }
      }
      return out;
    }

    function glitch(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const intensity = Math.max(1, Math.floor(n / 5));
      for (let i = 0; i < intensity; i++) {
        const y = Math.floor(Math.random() * ctx.height);
        const h = Math.floor(Math.random() * 20) + 1;
        const offset = Math.floor((Math.random() - 0.5) * 50);
        for (let dy = 0; dy < h && y + dy < ctx.height; dy++) {
          for (let x = 0; x < ctx.width; x++) {
            const srcX = (x + offset + ctx.width) % ctx.width;
            const srcPx = getPixel(prev, srcX, y + dy);
            setPixel(out, x, y + dy, srcPx[0], srcPx[1], srcPx[2]);
          }
        }
      }
      return out;
    }

    function offsetRows(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const step = Math.max(2, n);
      for (let y = 0; y < ctx.height; y++) {
        const offset = Math.floor(y / step) % 2 === 0 ? 0 : step * 5;
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x + offset) % ctx.width;
          const px = getPixel(prev, sx, y);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function offsetCols(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const step = Math.max(2, n);
      for (let x = 0; x < ctx.width; x++) {
        const offset = Math.floor(x / step) % 2 === 0 ? 0 : step * 5;
        for (let y = 0; y < ctx.height; y++) {
          const sy = (y + offset) % ctx.height;
          const px = getPixel(prev, x, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function sortRows(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const thresh = n * 2.55;
      for (let y = 0; y < ctx.height; y++) {
        const row = [];
        for (let x = 0; x < ctx.width; x++) {
          const px = getPixel(prev, x, y);
          const bright = px[0] * 0.299 + px[1] * 0.587 + px[2] * 0.114;
          row.push({ x, r: px[0], g: px[1], b: px[2], bright });
        }
        let start = 0;
        while (start < row.length) {
          while (start < row.length && row[start].bright < thresh) {
            setPixel(out, start, y, row[start].r, row[start].g, row[start].b);
            start++;
          }
          let end = start;
          while (end < row.length && row[end].bright >= thresh) end++;
          const segment = row.slice(start, end).sort((a, b) => a.bright - b.bright);
          for (let i = 0; i < segment.length; i++) {
            setPixel(out, start + i, y, segment[i].r, segment[i].g, segment[i].b);
          }
          start = end;
        }
      }
      return out;
    }

    function dither(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const matrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]];
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const idx = (y * ctx.width + x) * 4;
          const thresh = (matrix[y % 4][x % 4] / 16) * 255;
          for (let c = 0; c < 3; c++) {
            out.data[idx + c] = out.data[idx + c] > thresh ? 255 : 0;
          }
        }
      }
      return out;
    }

    function kaleidoscope(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const segments = Math.max(3, Math.min(n, 12));
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const angleStep = (Math.PI * 2) / segments;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          let angle = Math.atan2(dy, dx);
          if (angle < 0) angle += Math.PI * 2;
          const segmentAngle = angle % angleStep;
          const mirroredAngle = segmentAngle > angleStep / 2 ? angleStep - segmentAngle : segmentAngle;
          const r = Math.sqrt(dx * dx + dy * dy);
          const sx = cx + r * Math.cos(mirroredAngle);
          const sy = cy + r * Math.sin(mirroredAngle);
          const px = bilinearSample(prev, (sx / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function mirrorQuad(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const hw = ctx.width / 2;
      const hh = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = x < hw ? x : ctx.width - 1 - x;
          const sy = y < hh ? y : ctx.height - 1 - y;
          const px = bilinearSample(prev, (sx / hw) * prev.width, (sy / hh) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function spiral(ctx, n) {
      const prev = getPrevImage(ctx);
      console.log('  spiral: prev image size:', prev.width, 'x', prev.height, 'n:', n);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const twist = (n / 50) * Math.PI * 2;
      console.log('  spiral: twist angle:', twist, 'radians');
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxR = Math.sqrt(cx * cx + cy * cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const r = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) - (r / maxR) * twist;
          const sx = cx + r * Math.cos(angle);
          const sy = cy + r * Math.sin(angle);
          const px = bilinearSample(prev, (sx / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function zoom(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const scale = Math.max(0.1, n / 50);
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = cx + (x - cx) / scale;
          const sy = cy + (y - cy) / scale;
          const px = bilinearSample(prev, (sx / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function translateX(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const offset = (n - 50) * 4;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x - offset + ctx.width * 100) % ctx.width;
          const px = getPixel(prev, sx, y);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function translateY(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const offset = (n - 50) * 4;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sy = (y - offset + ctx.height * 100) % ctx.height;
          const px = getPixel(prev, x, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function tile3x3(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const tw = ctx.width / 3;
      const th = ctx.height / 3;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = ((x % tw) / tw) * prev.width;
          const sy = ((y % th) / th) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function redChannel(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i + 1] = 0;
        out.data[i + 2] = 0;
      }
      return out;
    }

    function greenChannel(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = 0;
        out.data[i + 2] = 0;
      }
      return out;
    }

    function blueChannel(ctx) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = 0;
        out.data[i + 1] = 0;
      }
      return out;
    }

    function contrast(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const factor = (n / 50);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.max(0, Math.min(255, 128 + (out.data[i] - 128) * factor));
        out.data[i + 1] = Math.max(0, Math.min(255, 128 + (out.data[i + 1] - 128) * factor));
        out.data[i + 2] = Math.max(0, Math.min(255, 128 + (out.data[i + 2] - 128) * factor));
      }
      return out;
    }

    function gamma(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const g = Math.max(0.1, n / 50);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.pow(out.data[i] / 255, g) * 255;
        out.data[i + 1] = Math.pow(out.data[i + 1] / 255, g) * 255;
        out.data[i + 2] = Math.pow(out.data[i + 2] / 255, g) * 255;
      }
      return out;
    }

    function solarize(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const thresh = n * 2.55;
      for (let i = 0; i < out.data.length; i += 4) {
        if (out.data[i] > thresh) out.data[i] = 255 - out.data[i];
        if (out.data[i + 1] > thresh) out.data[i + 1] = 255 - out.data[i + 1];
        if (out.data[i + 2] > thresh) out.data[i + 2] = 255 - out.data[i + 2];
      }
      return out;
    }

    function colorize(ctx, c) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [cr, cg, cb] = hexToRgb(c);
      for (let i = 0; i < out.data.length; i += 4) {
        const gray = out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114;
        out.data[i] = (gray / 255) * cr;
        out.data[i + 1] = (gray / 255) * cg;
        out.data[i + 2] = (gray / 255) * cb;
      }
      return out;
    }

    function tintAdd(ctx, c) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [cr, cg, cb] = hexToRgb(c);
      for (let i = 0; i < out.data.length; i += 4) {
        out.data[i] = Math.min(255, out.data[i] + cr * 0.3);
        out.data[i + 1] = Math.min(255, out.data[i + 1] + cg * 0.3);
        out.data[i + 2] = Math.min(255, out.data[i + 2] + cb * 0.3);
      }
      return out;
    }

    function crosshatch(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const spacing = Math.max(3, n);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          if ((x + y) % spacing === 0 || (x - y + ctx.height) % spacing === 0) {
            const idx = (y * ctx.width + x) * 4;
            out.data[idx] = out.data[idx] * 0.3;
            out.data[idx + 1] = out.data[idx + 1] * 0.3;
            out.data[idx + 2] = out.data[idx + 2] * 0.3;
          }
        }
      }
      return out;
    }

    function diamonds(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const size = Math.max(4, n);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = Math.abs((x % size) - size / 2);
          const dy = Math.abs((y % size) - size / 2);
          if (dx + dy < size / 2) {
            const px = getPixel(prev, x, y);
            setPixel(out, x, y, px[0], px[1], px[2]);
          }
        }
      }
      return out;
    }

    function stretch(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const factor = Math.max(0.2, n / 50);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x / ctx.width) * prev.width;
          const sy = Math.pow(y / ctx.height, factor) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function squeeze(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const factor = Math.max(0.2, n / 50);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = Math.pow(x / ctx.width, factor) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function halfLeft(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = ((x / ctx.width) * 0.5) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function halfRight(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (0.5 + (x / ctx.width) * 0.5) * prev.width;
          const sy = (y / ctx.height) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function halfTop(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x / ctx.width) * prev.width;
          const sy = ((y / ctx.height) * 0.5) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function halfBottom(ctx) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const sx = (x / ctx.width) * prev.width;
          const sy = (0.5 + (y / ctx.height) * 0.5) * prev.height;
          const px = bilinearSample(prev, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function blendAvg(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const px1 = getPixel(prev, x, y);
          const ox = Math.floor((x / ctx.width) * old.width);
          const oy = Math.floor((y / ctx.height) * old.height);
          const px2 = getPixel(old, ox, oy);
          setPixel(out, x, y, (px1[0] + px2[0]) / 2, (px1[1] + px2[1]) / 2, (px1[2] + px2[2]) / 2);
        }
      }
      return out;
    }

    function splitMerge(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const src = x < ctx.width / 2 ? prev : old;
          const sx = x < ctx.width / 2 ? x * 2 : (x - ctx.width / 2) * 2;
          const px = getPixel(src, Math.min(sx, src.width - 1), y);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function interlace(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        const src = y % 2 === 0 ? prev : old;
        for (let x = 0; x < ctx.width; x++) {
          const sx = Math.floor((x / ctx.width) * src.width);
          const sy = Math.floor((y / ctx.height) * src.height);
          const px = getPixel(src, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function vertInterlace(ctx, i) {
      const prev = getPrevImage(ctx);
      const old = getOldImage(ctx, i);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const src = x % 2 === 0 ? prev : old;
          const sx = Math.floor((x / ctx.width) * src.width);
          const sy = Math.floor((y / ctx.height) * src.height);
          const px = getPixel(src, sx, sy);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function rotateArbitrary(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const angle = (n / 100) * Math.PI * 2;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const sx = cx + dx * cos + dy * sin;
          const sy = cy - dx * sin + dy * cos;
          const px = bilinearSample(prev, (sx / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function radialGradient(ctx, c) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [gr, gg, gb] = hexToRgb(c);
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      const maxD = Math.sqrt(cx * cx + cy * cy);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          const t = Math.sqrt(dx * dx + dy * dy) / maxD;
          const idx = (y * ctx.width + x) * 4;
          out.data[idx] = Math.round(out.data[idx] * (1 - t) + gr * t);
          out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - t) + gg * t);
          out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - t) + gb * t);
        }
      }
      return out;
    }

    function cosineWave(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const freq = Math.max(1, n / 10);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const offset = Math.cos((x / ctx.width) * Math.PI * freq) * 20;
          const sy = y + offset;
          const px = bilinearSample(prev, (x / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function tanDistort(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const strength = (n / 100) * 0.3;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const nx = (x / ctx.width - 0.5) * 2;
          const ny = (y / ctx.height - 0.5) * 2;
          const sx = x + Math.tan(ny * Math.PI * 0.4) * strength * ctx.width * 0.1;
          const sy = y + Math.tan(nx * Math.PI * 0.4) * strength * ctx.height * 0.1;
          const px = bilinearSample(prev, (sx / ctx.width) * prev.width, (sy / ctx.height) * prev.height);
          setPixel(out, x, y, px[0], px[1], px[2]);
        }
      }
      return out;
    }

    function rectMask(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const margin = n * 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          if (x >= margin && x < ctx.width - margin && y >= margin && y < ctx.height - margin) {
            const px = getPixel(prev, x, y);
            setPixel(out, x, y, px[0], px[1], px[2]);
          }
        }
      }
      return out;
    }

    function circleMask(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const rad = (n / 100) * Math.min(ctx.width, ctx.height) / 2;
      const cx = ctx.width / 2;
      const cy = ctx.height / 2;
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const dx = x - cx;
          const dy = y - cy;
          if (dx * dx + dy * dy <= rad * rad) {
            const px = getPixel(prev, x, y);
            setPixel(out, x, y, px[0], px[1], px[2]);
          }
        }
      }
      return out;
    }

    function grid(ctx, c, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const spacing = Math.max(4, n);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          if (x % spacing === 0 || y % spacing === 0) {
            setPixel(out, x, y, r, g, b);
          }
        }
      }
      return out;
    }

    function diagonalLines(ctx, c, n) {
      const prev = getPrevImage(ctx);
      const out = cloneImage(prev);
      const [r, g, b] = hexToRgb(c);
      const spacing = Math.max(4, n);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          if ((x + y) % spacing < 2) {
            setPixel(out, x, y, r, g, b);
          }
        }
      }
      return out;
    }

    function chromaShift(ctx, n) {
      const prev = getPrevImage(ctx);
      const out = createSolidImage(ctx.width, ctx.height, '#000000');
      const shift = Math.floor(n / 10);
      for (let y = 0; y < ctx.height; y++) {
        for (let x = 0; x < ctx.width; x++) {
          const rPx = getPixel(prev, x - shift, y);
          const gPx = getPixel(prev, x, y);
          const bPx = getPixel(prev, x + shift, y);
          setPixel(out, x, y, rPx[0], gPx[1], bPx[2]);
        }
      }
      return out;
    }

    // Character definitions
    const characterDefs = {
      '!': { color: '#FF5733', number: 1, fn: tile2x2FlipMirror, arity: 0, argTypes: [] },
      '"': { color: '#33FF57', number: 2, fn: tile2x2Plain, arity: 0, argTypes: [] },
      '#': { color: '#3357FF', number: 3, fn: horizontalRepeat, arity: 1, argTypes: ['int'] },
      '$': { color: '#FF33F5', number: 4, fn: verticalRepeat, arity: 1, argTypes: ['int'] },
      '%': { color: '#33FFF5', number: 5, fn: gridRepeat, arity: 2, argTypes: ['int', 'int'] },
      '&': { color: '#F5FF33', number: 6, fn: horizontalRepeatUnequal, arity: 2, argTypes: ['int', 'int'] },
      "'": { color: '#FF8833', number: 7, fn: rotate90, arity: 0, argTypes: [] },
      '(': { color: '#88FF33', number: 8, fn: rotate180, arity: 0, argTypes: [] },
      ')': { color: '#3388FF', number: 9, fn: rotate270, arity: 0, argTypes: [] },
      '*': { color: '#FF3388', number: 10, fn: flipHorizontal, arity: 0, argTypes: [] },
      '+': { color: '#88FF88', number: 11, fn: flipVertical, arity: 0, argTypes: [] },
      ',': { color: '#8888FF', number: 12, fn: skewHorizontal, arity: 1, argTypes: ['int'] },
      '-': { color: '#FF8888', number: 13, fn: skewVertical, arity: 1, argTypes: ['int'] },
      '.': { color: '#88FFFF', number: 14, fn: waveHorizontal, arity: 1, argTypes: ['int'] },
      '/': { color: '#FFFF88', number: 15, fn: waveVertical, arity: 1, argTypes: ['int'] },
      '0': { color: '#000000', number: 0, fn: swirl, arity: 1, argTypes: ['int'] },
      '1': { color: '#111111', number: 1, fn: fisheye, arity: 1, argTypes: ['int'] },
      '2': { color: '#222222', number: 2, fn: barrel, arity: 1, argTypes: ['int'] },
      '3': { color: '#333333', number: 3, fn: pinch, arity: 1, argTypes: ['int'] },
      '4': { color: '#444444', number: 4, fn: spherize, arity: 0, argTypes: [] },
      '5': { color: '#555555', number: 5, fn: ripple, arity: 2, argTypes: ['int', 'int'] },
      '6': { color: '#666666', number: 6, fn: solarizeBlend, arity: 1, argTypes: ['int'] },
      '7': { color: '#777777', number: 7, fn: blendMultiply, arity: 1, argTypes: ['int'] },
      '8': { color: '#888888', number: 8, fn: blendScreen, arity: 1, argTypes: ['int'] },
      '9': { color: '#999999', number: 9, fn: blendDifference, arity: 1, argTypes: ['int'] },
      ':': { color: '#AAAAAA', number: 10, fn: blendOverlay, arity: 1, argTypes: ['int'] },
      ';': { color: '#BBBBBB', number: 11, fn: checkerboardBlend, arity: 2, argTypes: ['int', 'int'] },
      '<': { color: '#CCCCCC', number: 12, fn: diagonalTileBlend, arity: 1, argTypes: ['int'] },
      '=': { color: '#DDDDDD', number: 13, fn: horizontalLine, arity: 2, argTypes: ['color', 'int'] },
      '>': { color: '#EEEEEE', number: 14, fn: verticalLine, arity: 2, argTypes: ['color', 'int'] },
      '?': { color: '#FFFFFF', number: 15, fn: border, arity: 2, argTypes: ['color', 'int'] },
      '@': { color: '#FF0000', number: 16, fn: circle, arity: 2, argTypes: ['color', 'int'] },
      'A': { color: '#00FF00', number: 17, fn: filledCircle, arity: 2, argTypes: ['color', 'int'] },
      'B': { color: '#0000FF', number: 18, fn: gradientOverlay, arity: 1, argTypes: ['color'] },
      'C': { color: '#FFFF00', number: 19, fn: horizontalGradientOverlay, arity: 1, argTypes: ['color'] },
      'D': { color: '#FF00FF', number: 20, fn: invert, arity: 0, argTypes: [] },
      'E': { color: '#00FFFF', number: 21, fn: grayscale, arity: 0, argTypes: [] },
      'F': { color: '#800000', number: 22, fn: sepia, arity: 0, argTypes: [] },
      'G': { color: '#008000', number: 23, fn: posterize, arity: 1, argTypes: ['int'] },
      'H': { color: '#000080', number: 24, fn: shiftHue, arity: 1, argTypes: ['int'] },
      'I': { color: '#808000', number: 25, fn: increaseSaturation, arity: 1, argTypes: ['int'] },
      'J': { color: '#800080', number: 26, fn: decreaseSaturation, arity: 1, argTypes: ['int'] },
      'K': { color: '#008080', number: 27, fn: increaseBrightness, arity: 1, argTypes: ['int'] },
      'L': { color: '#C0C0C0', number: 28, fn: decreaseBrightness, arity: 1, argTypes: ['int'] },
      'M': { color: '#808080', number: 29, fn: threshold, arity: 1, argTypes: ['int'] },
      'N': { color: '#FF6600', number: 30, fn: swapRG, arity: 0, argTypes: [] },
      'O': { color: '#6600FF', number: 31, fn: swapRB, arity: 0, argTypes: [] },
      'P': { color: '#00FF66', number: 32, fn: swapGB, arity: 0, argTypes: [] },
      'Q': { color: '#66FF00', number: 33, fn: blur, arity: 0, argTypes: [] },
      'R': { color: '#FF0066', number: 34, fn: strongBlur, arity: 1, argTypes: ['int'] },
      'S': { color: '#0066FF', number: 35, fn: sharpen, arity: 0, argTypes: [] },
      'T': { color: '#CC3300', number: 36, fn: edgeDetect, arity: 0, argTypes: [] },
      'U': { color: '#00CC33', number: 37, fn: emboss, arity: 0, argTypes: [] },
      'V': { color: '#3300CC', number: 38, fn: pixelate, arity: 1, argTypes: ['int'] },
      'W': { color: '#33CC00', number: 39, fn: noiseOverlay, arity: 1, argTypes: ['int'] },
      'X': { color: '#CC0033', number: 40, fn: scanlines, arity: 1, argTypes: ['int'] },
      'Y': { color: '#0033CC', number: 41, fn: vignette, arity: 1, argTypes: ['int'] },
      'Z': { color: '#FFCC00', number: 42, fn: glitch, arity: 1, argTypes: ['int'] },
      '[': { color: '#00FFCC', number: 43, fn: offsetRows, arity: 1, argTypes: ['int'] },
      '\\': { color: '#CC00FF', number: 44, fn: offsetCols, arity: 1, argTypes: ['int'] },
      ']': { color: '#CCFF00', number: 45, fn: sortRows, arity: 1, argTypes: ['int'] },
      '^': { color: '#00CCFF', number: 46, fn: dither, arity: 0, argTypes: [] },
      '_': { color: '#FF00CC', number: 47, fn: kaleidoscope, arity: 1, argTypes: ['int'] },
      '`': { color: '#996633', number: 48, fn: mirrorQuad, arity: 0, argTypes: [] },
      'a': { color: '#339966', number: 49, fn: spiral, arity: 1, argTypes: ['int'] },
      'b': { color: '#663399', number: 50, fn: zoom, arity: 1, argTypes: ['int'] },
      'c': { color: '#996699', number: 51, fn: translateX, arity: 1, argTypes: ['int'] },
      'd': { color: '#669966', number: 52, fn: translateY, arity: 1, argTypes: ['int'] },
      'e': { color: '#666699', number: 53, fn: tile3x3, arity: 0, argTypes: [] },
      'f': { color: '#FF9966', number: 54, fn: redChannel, arity: 0, argTypes: [] },
      'g': { color: '#66FF99', number: 55, fn: greenChannel, arity: 0, argTypes: [] },
      'h': { color: '#9966FF', number: 56, fn: blueChannel, arity: 0, argTypes: [] },
      'i': { color: '#99FF66', number: 57, fn: contrast, arity: 1, argTypes: ['int'] },
      'j': { color: '#6699FF', number: 58, fn: gamma, arity: 1, argTypes: ['int'] },
      'k': { color: '#FF6699', number: 59, fn: solarize, arity: 1, argTypes: ['int'] },
      'l': { color: '#993366', number: 60, fn: colorize, arity: 1, argTypes: ['color'] },
      'm': { color: '#669933', number: 61, fn: tintAdd, arity: 1, argTypes: ['color'] },
      'n': { color: '#336699', number: 62, fn: crosshatch, arity: 1, argTypes: ['int'] },
      'o': { color: '#996633', number: 63, fn: diamonds, arity: 1, argTypes: ['int'] },
      'p': { color: '#663366', number: 64, fn: stretch, arity: 1, argTypes: ['int'] },
      'q': { color: '#336633', number: 65, fn: squeeze, arity: 1, argTypes: ['int'] },
      'r': { color: '#333366', number: 66, fn: halfLeft, arity: 0, argTypes: [] },
      's': { color: '#FF3366', number: 67, fn: halfRight, arity: 0, argTypes: [] },
      't': { color: '#66FF33', number: 68, fn: halfTop, arity: 0, argTypes: [] },
      'u': { color: '#3366FF', number: 69, fn: halfBottom, arity: 0, argTypes: [] },
      'v': { color: '#33FF66', number: 70, fn: blendAvg, arity: 1, argTypes: ['int'] },
      'w': { color: '#6633FF', number: 71, fn: splitMerge, arity: 1, argTypes: ['int'] },
      'x': { color: '#FF6633', number: 72, fn: interlace, arity: 1, argTypes: ['int'] },
      'y': { color: '#CC6699', number: 73, fn: vertInterlace, arity: 1, argTypes: ['int'] },
      'z': { color: '#99CC66', number: 74, fn: rotateArbitrary, arity: 1, argTypes: ['int'] },
      '{': { color: '#6699CC', number: 75, fn: radialGradient, arity: 1, argTypes: ['color'] },
      '|': { color: '#CC9966', number: 76, fn: cosineWave, arity: 1, argTypes: ['int'] },
      '}': { color: '#66CC99', number: 77, fn: tanDistort, arity: 1, argTypes: ['int'] },
      '~': { color: '#9966CC', number: 78, fn: rectMask, arity: 1, argTypes: ['int'] },
    };

    // Runtime with caching
    const cache = {
      chars: [],
      charToImageIndex: [], // maps char index -> image index it produced (or -1 if consumed as arg)
      images: [],
      imageMaxCharIndex: [], // for each image, the max char index used to produce it (including args)
      width: 0,
      height: 0,
      lastOpUsedEOFDefault: false, // Did the last op use defaults because it hit end of input?
      lastOpStartIndex: 0,         // Char index where the last op started
    };

    function runProgramCached(program, width, height) {
      const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
      
      console.log(`=== Input: "${chars.join('')}" (${chars.length} chars), cache has ${cache.chars.length} chars, ${cache.images.length} images ===`);
      
      // If dimensions changed, invalidate everything
      if (width !== cache.width || height !== cache.height) {
        console.log('Dimensions changed, invalidating cache');
        cache.chars = [];
        cache.charToImageIndex = [];
        cache.images = [];
        cache.width = width;
        cache.height = height;
      }
      
      // Empty program = black screen
      if (chars.length === 0) {
        console.log('Empty program -> black');
        cache.chars = [];
        cache.charToImageIndex = [];
        cache.images = [createSolidImage(width, height, '#000000')];
        return cache.images;
      }
      
      // Find first differing character
      let firstDiff = 0;
      while (firstDiff < chars.length && firstDiff < cache.chars.length && chars[firstDiff] === cache.chars[firstDiff]) {
        firstDiff++;
      }
      
      console.log(`First diff at index ${firstDiff}`);
      
      // If new program is shorter or different in the middle, truncate cache
      if (firstDiff < cache.chars.length) {
        console.log(`Truncating: new program diverges or is shorter at index ${firstDiff}`);
        // Find how many images to keep - only those that don't use any char at or after firstDiff
        let keepImages = 0;
        for (let imgIdx = 0; imgIdx < cache.images.length; imgIdx++) {
          if (cache.imageMaxCharIndex[imgIdx] < firstDiff) {
            keepImages = imgIdx + 1;
          } else {
            break; // This image used a char that's being deleted
          }
        }
        // Also need to truncate chars to match - find the last char that contributed to kept images
        let keepChars = 0;
        for (let i = 0; i < cache.chars.length; i++) {
          const imgIdx = cache.charToImageIndex[i];
          if (imgIdx >= 0 && imgIdx < keepImages) {
            keepChars = i + 1;
          } else if (imgIdx === -1 && i < firstDiff) {
            // This was a consumed arg - keep it if it was used by a kept image
            // Actually, we can simplify: just keep chars up to the max char used by kept images
          }
        }
        // Simpler: find max char index used by kept images
        if (keepImages > 0) {
          keepChars = cache.imageMaxCharIndex[keepImages - 1] + 1;
        }
        // But we can't keep more chars than firstDiff
        keepChars = Math.min(keepChars, firstDiff);
        
        console.log(`Keeping ${keepImages} images, ${keepChars} chars`);
        cache.images = cache.images.slice(0, keepImages);
        cache.imageMaxCharIndex = cache.imageMaxCharIndex.slice(0, keepImages);
        cache.chars = cache.chars.slice(0, keepChars);
        cache.charToImageIndex = cache.charToImageIndex.slice(0, keepChars);
        cache.lastOpUsedEOFDefault = false;
      }
      // If appending new chars and the last operation used defaults due to EOF, re-evaluate it
      else if (firstDiff >= cache.chars.length && cache.lastOpUsedEOFDefault && cache.chars.length > 0) {
        const redoFrom = cache.lastOpStartIndex;
        console.log(`Appending, but last op (at char ${redoFrom}) used EOF defaults - redoing from there`);
        let keepImages = 0;
        for (let j = 0; j < redoFrom; j++) {
          if (cache.charToImageIndex[j] >= 0) {
            keepImages = cache.charToImageIndex[j] + 1;
          }
        }
        cache.images = cache.images.slice(0, keepImages);
        cache.imageMaxCharIndex = cache.imageMaxCharIndex.slice(0, keepImages);
        cache.chars = cache.chars.slice(0, redoFrom);
        cache.charToImageIndex = cache.charToImageIndex.slice(0, redoFrom);
        cache.lastOpUsedEOFDefault = false;
      }
      
      // If we've already processed all chars, just return cached result
      if (cache.chars.length === chars.length && cache.images.length > 0) {
        console.log(`Already fully cached, returning ${cache.images.length} images`);
        return cache.images;
      }
      
      // Start processing from where cache ends
      let i = cache.chars.length;
      console.log(`Processing from char index ${i}`);
      
      // Handle first char specially if we're starting from scratch
      if (i === 0) {
        // Clear any stale state (e.g., from empty program -> non-empty)
        cache.images = [];
        cache.imageMaxCharIndex = [];
        cache.chars = [];
        cache.charToImageIndex = [];
        
        const firstChar = chars[0];
        const firstDef = characterDefs[firstChar];
        if (firstDef) {
          console.log(`First char '${firstChar}' -> solid ${firstDef.color}`);
          cache.images.push(createSolidImage(width, height, firstDef.color));
        } else {
          console.log(`First char '${firstChar}' undefined -> black`);
          cache.images.push(createSolidImage(width, height, '#000000'));
        }
        cache.imageMaxCharIndex.push(0); // First image only uses char 0
        cache.chars.push(firstChar);
        cache.charToImageIndex.push(0);
        i = 1;
      }

      while (i < chars.length) {
        const char = chars[i];
        const def = characterDefs[char];
        
        if (!def) {
          console.log(`[${i}] '${char}' undefined, skipping`);
          cache.chars.push(char);
          cache.charToImageIndex.push(-1);
          i++;
          continue;
        }

        console.log(`[${i}] '${char}' -> fn, arity ${def.arity}`);
        
        const args = [];
        let argsConsumed = 0;
        const argCharIndices = [];
        let usedEOFDefault = false;

        for (let argIdx = 0; argIdx < def.arity; argIdx++) {
          const argType = def.argTypes[argIdx];
          const nextCharIdx = i + 1 + argIdx;
          
          if (nextCharIdx < chars.length) {
            const argChar = chars[nextCharIdx];
            const argDef = characterDefs[argChar];
            
            if (argDef) {
              args.push(argType === 'int' ? argDef.number : argDef.color);
              argsConsumed++;
              argCharIndices.push(nextCharIdx);
              console.log(`  arg[${argIdx}]: '${argChar}' -> ${argType === 'int' ? argDef.number : argDef.color}`);
            } else {
              args.push(argType === 'int' ? def.number : def.color);
              console.log(`  arg[${argIdx}]: '${argChar}' undefined, using default`);
            }
          } else {
            args.push(argType === 'int' ? def.number : def.color);
            usedEOFDefault = true;
            console.log(`  arg[${argIdx}]: EOF, using default`);
          }
        }

        const ctx = {
          width,
          height,
          images: [...cache.images],
          currentIndex: cache.images.length,
        };

        const result = def.fn(ctx, ...args);
        const newImageIndex = cache.images.length;
        cache.images.push(result);
        
        // Track the max char index used by this image (the function char or any consumed args)
        const maxCharUsed = argCharIndices.length > 0 ? Math.max(i, ...argCharIndices) : i;
        cache.imageMaxCharIndex.push(maxCharUsed);
        
        cache.chars.push(char);
        cache.charToImageIndex.push(newImageIndex);
        cache.lastOpUsedEOFDefault = usedEOFDefault;
        cache.lastOpStartIndex = i;
        
        for (const argCharIdx of argCharIndices) {
          cache.chars.push(chars[argCharIdx]);
          cache.charToImageIndex.push(-1);
        }
        
        i += 1 + argsConsumed;
      }

      console.log(`Done. cache.chars=${cache.chars.length}, cache.images=${cache.images.length}`);
      return cache.images;
    }

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      render();
    }

    function render() {
      const program = input.value || '';
      const images = runProgramCached(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
    }

    window.addEventListener('resize', resize);
    input.addEventListener('input', render);
    
    resize();
  </script>
</body>
</html>

# SYSTEM

You are Greger, and expert coding agent.

${greger-prompt-code-style<eval-result-224558598497>
# Code style

## Don't be overly defensive

I don't trust the code you write, so I want you to fail early and loudly.

**Don't** add fallbacks, guards, or try/catch blocks against errors unless I specifically ask you to. I don't trust the code you write so I'd rather fail hard early and detect your errors than softly receive a fallback and not detect your errors.

## Imports go at the top

Don't sprinkle the code with imports unless in very special circumstances or if I explicltly ask you to.

## No unnecessary comments

You have a tendency to comment every line. I'm an expert programmer and I prefer reading code to prose. Most of the time I can read the code faster than the comment to understand what's going on. Only add comments in cases where the code is unintuitive or particularly hard to follow (e.g. custom parsers).

## Read full files

Important: The first time you read a source code file, read the _entire_ file (_not_ piecemeal with start-line and end-line) so you get a real holistic understanding of the logic.

## IMPORTANT: NO SUMMARY DOCUMENTS!!!

IMPORTANT: DON'T write summary documents (e.g. SUMMARY.md, FINAL_REPORT.md) unless the user explicitly asks you to. If you feel the need to explain something, just do it in the chat. The ONLY exception to this rule is if the user explicitly asks you to write up a markdown file on disk.
</eval-result-224558598497>}

# IMPORTANT

Don't try to run the server or build things, I'm running it myself in the background

# USER

I want to create an esoteric programming language for generating images, where _every_ combination of uppercase ascii characters (excluding "invisible characters" like space, return) create an image.

Every character have an associated color, integer, and function.

Some functions have arity 0, some are unary, some are binary (some are maybe ternary?). Arguments to functions may be colors or integers. When arity > 0, the default argument are defined in the function, and color values usually default to the color of the character. Each function outputs a 2D RGB image.

A program is a list of characters that outputs a list of images (where the number of images <= number of characters, since some characters may be function arguments)

Functions have access to the entire history of output images up to the point in the program where they're defined. By convention, each function does some transformation on the previous image.

The first character is always used by its color, creating a single color image. Subsequent characters are parsed until the end of the program string. The default arguments are only used if the last function in the program string is missing inputs.

Note that

These are all valid programs: FJID)WIJF, FH)Y*#, I0ASDFJ0IDFSJOJOSF280EFY2HFUDSOH)DFSHFD, 8DFS632&@DSFJFDJSINCSJNIJSHOF, etc.

Implement this as a table in typescript in the following form:

```
// character-defs.ts
const characterDefs = {
  'A': {
    color: '#78A10F',
    number: 7,
    function: (images, a, c) => ..., // a and c are the arguments here. `images` is passed to as the first argument to every function. width and height are implicit from the previous image. images are inputs to every function. images is a list of 3D tensors, and the function returns a 3D tensor
    arity: 2,
    functionName: "short-name",
    documentation: "one sentence about what the function does"
  }
}
```

I have already made index.html, runtime.ts, and parts of character-defs.ts. You just need to implement the rest of character-defs.ts.

All functions need to be completely deterministic! You must not use the random function anywhere!

Assign a random color to each character, and a number that starts at 1 at `A`, incrementing by one to `Z`, followed by `0` through `9`, followed by symbols.

---

# runtime.ts:

${:sh cat runtime.ts<eval-result-223027526958>import { characterDefs, createSolidImage, Image, FnContext, CharDef } from './character-defs.js';

interface ParsedSolidColor {
  type: 'solid';
  identifier: string;
  color: string;
}

interface ParsedFunction {
  type: 'function';
  identifier: string;
  fnDef: CharDef;
  args: (number | string)[];
}

type ParsedOp = ParsedSolidColor | ParsedFunction;

class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
  }

  clear(): void {
    this.cache.clear();
  }
}

function parseProgram(program: string): ParsedOp[] {
  console.log(`\n=== PARSING: "${program}" ===`);
  const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
  console.log(`Filtered chars: "${chars.join('')}"`);
  
  if (chars.length === 0) {
    console.log('Empty program, returning []');
    return [];
  }

  const ops: ParsedOp[] = [];
  
  const firstChar = chars[0];
  const firstDef = characterDefs[firstChar];
  const firstColor = firstDef ? firstDef.color : '#000000';
  
  console.log(`[0] First char '${firstChar}' -> solid color ${firstColor}`);
  ops.push({
    type: 'solid',
    identifier: firstChar,
    color: firstColor
  });

  let i = 1;
  while (i < chars.length) {
    const char = chars[i];
    const def = characterDefs[char];
    
    if (!def) {
      console.log(`[${i}] '${char}' undefined, skipping`);
      i++;
      continue;
    }

    const args: (number | string)[] = [];
    let argsConsumed = 0;

    console.log(`[${i}] '${char}' -> ${def.functionName}, arity ${def.arity}`);

    for (let argIdx = 0; argIdx < def.arity; argIdx++) {
      const argType = def.argTypes[argIdx];
      const nextCharIdx = i + 1 + argIdx;
      
      if (nextCharIdx < chars.length) {
        const argChar = chars[nextCharIdx];
        const argDef = characterDefs[argChar];
        
        if (argDef) {
          if (argType === 'int') {
            args.push(argDef.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.number}`);
          } else {
            args.push(argDef.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.color}`);
          }
          argsConsumed++;
        } else {
          if (argType === 'int') {
            args.push(def.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.number}`);
          } else {
            args.push(def.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.color}`);
          }
        }
      } else {
        if (argType === 'int') {
          args.push(def.number);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.number}`);
        } else {
          args.push(def.color);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.color}`);
        }
      }
    }

    const endIndex = i + 1 + argsConsumed;
    const identifier = chars.slice(0, endIndex).join('');
    
    console.log(`  identifier: "${identifier}"`);
    
    ops.push({
      type: 'function',
      identifier,
      fnDef: def,
      args
    });
    
    i += 1 + argsConsumed;
  }

  console.log(`Parsed into ${ops.length} operations`);
  return ops;
}

const imageCache = new LRUCache<string, Image>(100);
let lastWidth = 0;
let lastHeight = 0;

export function runProgram(program: string, width: number, height: number): Image[] {
  console.log(`\n=== EXECUTION: ${width}x${height} ===`);
  
  if (width !== lastWidth || height !== lastHeight) {
    console.log(`Dimensions changed (${lastWidth}x${lastHeight} -> ${width}x${height}), clearing cache`);
    imageCache.clear();
    lastWidth = width;
    lastHeight = height;
  }

  const ops = parseProgram(program);
  
  if (ops.length === 0) {
    console.log('No operations, returning black image');
    return [createSolidImage(width, height, '#000000')];
  }

  const images: Image[] = [createSolidImage(width, height, '#000000')];
  let cacheHits = 0;
  let cacheMisses = 0;
  
  for (let opIdx = 0; opIdx < ops.length; opIdx++) {
    const op = ops[opIdx];
    console.log(`\n[Op ${opIdx}] identifier="${op.identifier}"`);
    
    const cached = imageCache.get(op.identifier);
    if (cached) {
      console.log(`  ✓ CACHE HIT`);
      images.push(cached);
      cacheHits++;
      continue;
    }

    console.log(`  ✗ CACHE MISS`);
    cacheMisses++;

    let result: Image;
    
    if (op.type === 'solid') {
      console.log(`  Creating solid image: ${op.color}`);
      result = createSolidImage(width, height, op.color);
    } else {
      console.log(`  Executing function: ${op.fnDef.functionName} with args:`, op.args);
      const ctx: FnContext = {
        width,
        height,
        images: [...images],
        currentIndex: images.length,
      };
      
      result = op.fnDef.fn(ctx, ...op.args);
    }
    
    images.push(result);
    imageCache.set(op.identifier, result);
    console.log(`  ✓ Cached result for "${op.identifier}"`);
  }

  console.log(`\n=== EXECUTION COMPLETE ===`);
  console.log(`Cache hits: ${cacheHits}, Cache misses: ${cacheMisses}`);
  console.log(`Total images: ${images.length}`);
  return images;
}

export function getFinalImage(program: string, width: number, height: number): Image {
  const images = runProgram(program, width, height);
  return images[images.length - 1];
}

export function getParsedOperations(program: string): ParsedOp[] {
  return parseProgram(program);
}
</eval-result-223027526958>}

---

# character-defs.ts:

${:sh cat character-defs.ts<eval-result-223027560053>import * as THREE from 'three';
import FFT from 'fft.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

export interface Image {
  width: number;
  height: number;
  data: Uint8ClampedArray;
}

export interface FnContext {
  width: number;
  height: number;
  images: Image[];
  currentIndex: number;
}

export interface CharDef {
  color: string;
  number: number;
  fn: (ctx: FnContext, ...args: any[]) => Image;
  arity: number;
  argTypes: ('int' | 'color')[];
  functionName: string;
  documentation: string;
}

let glCanvas: HTMLCanvasElement | null = null;
let gl: WebGLRenderingContext | null = null;
let glTexture: WebGLTexture | null = null;
let glFramebuffer: WebGLFramebuffer | null = null;

function initWebGL(width: number, height: number): WebGLRenderingContext {
  if (!glCanvas || glCanvas.width !== width || glCanvas.height !== height) {
    glCanvas = document.createElement('canvas');
    glCanvas.width = width;
    glCanvas.height = height;
    gl = glCanvas.getContext('webgl', { 
      premultipliedAlpha: false,
      preserveDrawingBuffer: true 
    });
    if (!gl) throw new Error('WebGL not supported');
    
    glTexture = gl.createTexture();
    glFramebuffer = gl.createFramebuffer();
  }
  return gl!;
}

function createShaderProgram(gl: WebGLRenderingContext, vertSource: string, fragSource: string): WebGLProgram {
  const vertShader = gl.createShader(gl.VERTEX_SHADER)!;
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);
  
  const fragShader = gl.createShader(gl.FRAGMENT_SHADER)!;
  gl.shaderSource(fragShader, fragSource);
  gl.compileShader(fragShader);
  
  const program = gl.createProgram()!;
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  
  return program;
}

export function createSolidImage(width: number, height: number, color: string): Image {
  const [r, g, b] = hexToRgb(color);
  const data = new Uint8ClampedArray(width * height * 4);
  for (let i = 0; i < width * height; i++) {
    data[i * 4] = r;
    data[i * 4 + 1] = g;
    data[i * 4 + 2] = b;
    data[i * 4 + 3] = 255;
  }
  return { width, height, data };
}

function hexToRgb(hex: string): [number, number, number] {
  const h = hex.replace('#', '');
  return [
    parseInt(h.substring(0, 2), 16),
    parseInt(h.substring(2, 4), 16),
    parseInt(h.substring(4, 6), 16),
  ];
}

function cloneImage(img: Image): Image {
  return {
    width: img.width,
    height: img.height,
    data: new Uint8ClampedArray(img.data),
  };
}

function getPrevImage(ctx: FnContext): Image {
  if (ctx.images.length === 0) {
    return createSolidImage(ctx.width, ctx.height, '#000000');
  }
  return ctx.images[ctx.images.length - 1];
}

function getOldImage(ctx: FnContext, j: number): Image {
  if (ctx.images.length === 0) return createSolidImage(ctx.width, ctx.height, '#000000');
  if (ctx.images.length === 1) return ctx.images[0];
  const idx = Math.abs(j) % ctx.images.length;
  return ctx.images[idx];
}

function getPixel(img: Image, x: number, y: number): [number, number, number, number] {
  const cx = Math.max(0, Math.min(img.width - 1, Math.floor(x)));
  const cy = Math.max(0, Math.min(img.height - 1, Math.floor(y)));
  const i = (cy * img.width + cx) * 4;
  return [img.data[i], img.data[i + 1], img.data[i + 2], img.data[i + 3]];
}

function setPixel(img: Image, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {
  if (x < 0 || x >= img.width || y < 0 || y >= img.height) return;
  const i = (y * img.width + x) * 4;
  img.data[i] = r;
  img.data[i + 1] = g;
  img.data[i + 2] = b;
  img.data[i + 3] = a;
}

function rgbToHsl(r: number, g: number, b: number): [number, number, number] {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0, s = 0;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
  }
  
  return [h * 360, s, l];
}

function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  h = h / 360;
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function fnA(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    vec3 renderSphere(vec2 uv, vec2 center, float radius, sampler2D tex) {
      vec2 p = (uv - center) / radius;
      float d = length(p);
      
      if (d > 1.0) return vec3(-1.0);
      
      float z = sqrt(1.0 - d * d);
      vec3 normal = normalize(vec3(p.x, -p.y, z));
      vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.0));
      
      float diffuse = max(dot(normal, lightDir), 0.0);
      float ambient = 0.3;
      float lighting = ambient + diffuse * 0.7;
      
      vec2 texCoord = vec2(
        atan(normal.x, normal.z) / (2.0 * 3.14159) + 0.5,
        acos(normal.y) / 3.14159
      );
      
      vec3 color = texture2D(tex, texCoord).rgb;
      return color * lighting;
    }
    
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;
      vec3 bg = texture2D(texture, vec2(1.0 - uv.x, 1.0 - uv.y)).rgb;
      
      vec2 topRight = vec2(0.75, 0.75);
      vec2 bottomLeft = vec2(0.25, 0.25);
      float radius = 0.15;
      
      vec3 sphere1 = renderSphere(uv, topRight, radius, texture);
      vec3 sphere2 = renderSphere(uv, bottomLeft, radius, texture);
      
      vec3 color = bg;
      if (sphere1.x >= 0.0) color = sphere1;
      if (sphere2.x >= 0.0) color = sphere2;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  const textureLoc = gl.getUniformLocation(program, 'texture');
  const resolutionLoc = gl.getUniformLocation(program, 'resolution');
  
  gl.uniform1i(textureLoc, 0);
  gl.uniform2f(resolutionLoc, ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnB(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const seeds: [number, number][] = [];
  for (let i = 0; i < 36; i++) {
    seeds.push([
      (i * 47) % ctx.width,
      (i * 89) % ctx.height
    ]);
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let minDist = Infinity;
      let closestIdx = 0;
      
      for (let i = 0; i < seeds.length; i++) {
        const dx = x - seeds[i][0];
        const dy = y - seeds[i][1];
        const dist = dx * dx + dy * dy;
        if (dist < minDist) {
          minDist = dist;
          closestIdx = i;
        }
      }
      
      const src = closestIdx % 2 === 0 ? prev : old;
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnC(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const rings = Math.max(2, Math.min(n, 50));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxRadius = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const ringIdx = Math.floor((dist / maxRadius) * rings);
      const [r, g, b] = getPixel(prev, x, y);
      
      if (ringIdx % 2 === 0) {
        setPixel(out, x, y, r, g, b);
      } else {
        const hueShift = (360 / rings) * ringIdx;
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fn5(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const cellSize = Math.max(20, n * 4);
  const cols = Math.max(2, Math.floor(ctx.width / cellSize));
  const rows = Math.max(2, Math.floor(ctx.height / cellSize));
  const totalTriangles = cols * rows * 2;
  
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x0 = Math.floor((col / cols) * ctx.width);
      const y0 = Math.floor((row / rows) * ctx.height);
      const x1 = Math.floor(((col + 1) / cols) * ctx.width);
      const y1 = Math.floor(((row + 1) / rows) * ctx.height);
      const cellW = x1 - x0;
      const cellH = y1 - y0;
      
      const triIndex1 = (row * cols + col) * 2;
      const triIndex2 = triIndex1 + 1;
      
      const hueShift1 = (triIndex1 * 137.5) % 360;
      const hueShift2 = (triIndex2 * 137.5) % 360;
      const lightMod1 = (triIndex1 % 2 === 0) ? 0.15 : -0.15;
      const lightMod2 = (triIndex2 % 2 === 0) ? 0.15 : -0.05;
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const localX = (x - x0) / cellW;
          const localY = (y - y0) / cellH;
          
          const [r, g, b] = getPixel(prev, x, y);
          const [h, s, l] = rgbToHsl(r, g, b);
          const isUpperTriangle = localX + localY < 1;
          
          const hueShift = isUpperTriangle ? hueShift1 : hueShift2;
          const lightMod = isUpperTriangle ? lightMod1 : lightMod2;
          const newL = Math.max(0, Math.min(1, l + lightMod));
          
          const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, Math.min(1, s * 1.3), newL);
          setPixel(out, x, y, nr, ng, nb);
        }
      }
    }
  }
  
  return out;
}

function fnF(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const zoomPower = Math.max(1, n);
  const scale = Math.pow(0.7, zoomPower);
  const maxIterations = 10 + zoomPower * 5;
  
  const cReal = -0.7;
  const cImag = 0.27015;
  
  const centerReal = 0.15;
  const centerImag = 0.6;
  
  const aspect = ctx.height / ctx.width;
  
  for (let py = 0; py < ctx.height; py++) {
    for (let px = 0; px < ctx.width; px++) {
      let zReal = centerReal + ((px / ctx.width) - 0.5) * 3 * scale;
      let zImag = centerImag + ((py / ctx.height) - 0.5) * 3 * scale * aspect;
      
      let iteration = 0;
      let zReal2 = zReal * zReal;
      let zImag2 = zImag * zImag;
      
      while (iteration < maxIterations && zReal2 + zImag2 < 256) {
        zImag = 2 * zReal * zImag + cImag;
        zReal = zReal2 - zImag2 + cReal;
        zReal2 = zReal * zReal;
        zImag2 = zImag * zImag;
        iteration++;
      }
      
      if (iteration === maxIterations) {
        const [pr, pg, pb] = getPixel(prev, px, py);
        setPixel(out, px, py, pr, pg, pb);
      } else {
        const log_zn = Math.log(zReal2 + zImag2) / 2;
        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
        const smoothed = iteration + 1 - nu;
        
        const t = (smoothed % 20) / 20;
        const sampleX = Math.floor(t * ctx.width);
        const sampleY = py;
        
        const [pr, pg, pb] = getPixel(prev, sampleX, sampleY);
        const brightness = 0.85 + 0.3 * t;
        setPixel(out, px, py, 
          Math.min(255, Math.round(pr * brightness)),
          Math.min(255, Math.round(pg * brightness)),
          Math.min(255, Math.round(pb * brightness)));
      }
    }
  }
  
  return out;
}

function fnG(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const histogram = new Array(256).fill(0);
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
    out.data[i] = gray;
    out.data[i + 1] = gray;
    out.data[i + 2] = gray;
    histogram[gray]++;
  }
  
  const numColors = Math.max(2, Math.min(n, 16));
  const colors: [number, number, number][] = [];
  
  for (let i = 0; i < numColors; i++) {
    const hue = (i / numColors) * 360;
    colors.push(hslToRgb(hue, 0.7, 0.5));
  }
  
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = out.data[i];
    const colorIndex = Math.floor((gray / 256) * numColors);
    const clampedIndex = Math.min(colorIndex, numColors - 1);
    
    out.data[i] = colors[clampedIndex][0];
    out.data[i + 1] = colors[clampedIndex][1];
    out.data[i + 2] = colors[clampedIndex][2];
  }
  
  return out;
}

function fnH(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / cx;
      const ny = (y - cy) / cy;
      
      const hourglassWidth = Math.abs(ny);
      const inHourglass = Math.abs(nx) < hourglassWidth;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      const distFromCenter = Math.sqrt(nx * nx + ny * ny);
      const angle = Math.atan2(ny, nx);
      
      if (inHourglass) {
        const gr = Math.floor((1 - Math.abs(ny)) * 255);
        const gg = Math.floor((Math.abs(nx) / Math.max(0.01, hourglassWidth)) * 255);
        const gb = Math.floor(distFromCenter * 180);
        
        const nr = 255 - (pr & gr);
        const ng = 255 - (pg & gg);
        const nb = 255 - (pb & gb);
        
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const gr = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 255);
        const gg = Math.floor((1 - distFromCenter) * 200 + 55);
        const gb = Math.floor(((nx + 1) / 2) * 255);
        
        const nr = (pr + gr) % 256;
        const ng = Math.abs(pg - gg);
        const nb = pb ^ gb;
        
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnI(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = 255 - out.data[i];
    out.data[i + 1] = 255 - out.data[i + 1];
    out.data[i + 2] = 255 - out.data[i + 2];
  }
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  for (let y = 1; y < ctx.height - 1; y++) {
    for (let x = 1; x < ctx.width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const px = getPixel(prev, x + kx, y + ky);
          const gray = px[0] * 0.299 + px[1] * 0.587 + px[2] * 0.114;
          const kernelIdx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kernelIdx];
          gy += gray * sobelY[kernelIdx];
        }
      }
      
      const magnitude = Math.sqrt(gx * gx + gy * gy);
      
      if (magnitude > 50) {
        setPixel(out, x, y, 255, 255, 255);
      }
    }
  }
  
  return out;
}

function fnJ(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = x / ctx.width;
      const ny = y / ctx.height;
      
      const squareSize = Math.max(2, Math.floor(2 + (nx + ny) * 50));
      
      const gridX = Math.floor(x / squareSize);
      const gridY = Math.floor(y / squareSize);
      
      const useOld = (gridX + gridY) % 2 === 0;
      const src = useOld ? old : prev;
      
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnK(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const segments = Math.max(1, Math.min(n + 2, 18));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const angleStep = (Math.PI * 2) / segments;
  const zoom = 1.1;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = (x - cx) * zoom;
      const dy = (y - cy) * zoom;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const segmentAngle = angle % angleStep;
      const mirroredAngle = segmentAngle > angleStep / 2 ? angleStep - segmentAngle : segmentAngle;
      
      const r = Math.sqrt(dx * dx + dy * dy);
      const sx = cx + r * Math.cos(mirroredAngle);
      const sy = cy + r * Math.sin(mirroredAngle);
      
      const [pr, pg, pb] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, pr, pg, pb);
    }
  }
  
  return out;
}

function fnL(ctx: FnContext, j: number, rot: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const rotation = rot * 0.3;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uModelView;
    uniform mat3 uNormalMatrix;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vPosition = (uModelView * vec4(aPosition, 1.0)).xyz;
      vNormal = uNormalMatrix * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * vec4(vPosition, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightPos;
    uniform vec3 uLightPos2;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vec3 normal = normalize(vNormal);
      vec3 viewDir = normalize(-vPosition);
      
      // Light 1 - main light
      vec3 lightDir1 = normalize(uLightPos - vPosition);
      vec3 halfDir1 = normalize(lightDir1 + viewDir);
      float diff1 = max(dot(normal, lightDir1), 0.0);
      float spec1 = pow(max(dot(normal, halfDir1), 0.0), 32.0);
      
      // Light 2 - fill light
      vec3 lightDir2 = normalize(uLightPos2 - vPosition);
      vec3 halfDir2 = normalize(lightDir2 + viewDir);
      float diff2 = max(dot(normal, lightDir2), 0.0);
      float spec2 = pow(max(dot(normal, halfDir2), 0.0), 32.0);
      
      float ambient = 0.35;
      float diffuse = diff1 * 0.6 + diff2 * 0.35;
      float specular = (spec1 * 0.8 + spec2 * 0.4);
      
      vec2 tiledCoord = fract(vTexCoord);
      vec3 texColor = texture2D(uTexture, tiledCoord).rgb;
      vec3 color = texColor * (ambient + diffuse) + vec3(1.0) * specular;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const bgVertShader = `
    attribute vec2 aPosition;
    varying vec2 vUV;
    void main() {
      vUV = aPosition * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 0.999, 1.0);
    }
  `;
  
  const bgFragShader = `
    precision highp float;
    uniform sampler2D uBgTexture;
    varying vec2 vUV;
    void main() {
      gl_FragColor = texture2D(uBgTexture, vec2(vUV.x, 1.0 - vUV.y));
    }
  `;
  
  const tubeProgram = createShaderProgram(gl, vertexShader, fragmentShader);
  const bgProgram = createShaderProgram(gl, bgVertShader, bgFragShader);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const positions: number[] = [];
  const normals: number[] = [];
  const texCoords: number[] = [];
  
  const a = 3, b = 2, c = 1;
  const tubeRadius = 0.08;
  const segments = 400;
  const radialSegments = 12;
  
  const cross = (a: number[], b: number[]): number[] => [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
  const normalize = (v: number[]): number[] => {
    const len = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
    if (len < 0.0001) return [1, 0, 0];
    return [v[0]/len, v[1]/len, v[2]/len];
  };
  const dot = (a: number[], b: number[]): number => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  
  const getPoint = (t: number): number[] => [
    Math.sin(a * t) * 0.7,
    Math.sin(b * t) * 0.7,
    Math.sin(c * t) * 0.5
  ];
  
  const getTangent = (t: number): number[] => {
    const eps = 0.0001;
    const p1 = getPoint(t - eps);
    const p2 = getPoint(t + eps);
    return normalize([p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]]);
  };
  
  const frames: {point: number[], normal: number[], binormal: number[]}[] = [];
  
  let prevNormal = [1, 0, 0];
  const firstTan = getTangent(0);
  if (Math.abs(dot(prevNormal, firstTan)) > 0.9) {
    prevNormal = [0, 1, 0];
  }
  prevNormal = normalize(cross(cross(firstTan, prevNormal), firstTan));
  
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const point = getPoint(t);
    const tangent = getTangent(t);
    
    let normal = normalize(cross(cross(tangent, prevNormal), tangent));
    const binormal = normalize(cross(tangent, normal));
    
    frames.push({ point, normal, binormal });
    prevNormal = normal;
  }
  
  const firstFrame = frames[0];
  const lastFrame = frames[segments];
  const twistAngle = Math.atan2(
    dot(lastFrame.normal, firstFrame.binormal),
    dot(lastFrame.normal, firstFrame.normal)
  );
  
  for (let i = 0; i <= segments; i++) {
    const correction = -twistAngle * (i / segments);
    const cos_c = Math.cos(correction), sin_c = Math.sin(correction);
    const f = frames[i];
    const newNormal = [
      f.normal[0] * cos_c + f.binormal[0] * sin_c,
      f.normal[1] * cos_c + f.binormal[1] * sin_c,
      f.normal[2] * cos_c + f.binormal[2] * sin_c
    ];
    const newBinormal = [
      -f.normal[0] * sin_c + f.binormal[0] * cos_c,
      -f.normal[1] * sin_c + f.binormal[1] * cos_c,
      -f.normal[2] * sin_c + f.binormal[2] * cos_c
    ];
    f.normal = newNormal;
    f.binormal = newBinormal;
  }
  
  for (let i = 0; i < segments; i++) {
    const f0 = frames[i];
    const f1 = frames[i + 1];
    
    for (let r = 0; r < radialSegments; r++) {
      const angle0 = (r / radialSegments) * Math.PI * 2;
      const angle1 = ((r + 1) / radialSegments) * Math.PI * 2;
      
      const cos0 = Math.cos(angle0), sin0 = Math.sin(angle0);
      const cos1 = Math.cos(angle1), sin1 = Math.sin(angle1);
      
      const v00 = [
        f0.point[0] + (f0.normal[0] * cos0 + f0.binormal[0] * sin0) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos0 + f0.binormal[1] * sin0) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos0 + f0.binormal[2] * sin0) * tubeRadius
      ];
      const v01 = [
        f0.point[0] + (f0.normal[0] * cos1 + f0.binormal[0] * sin1) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos1 + f0.binormal[1] * sin1) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos1 + f0.binormal[2] * sin1) * tubeRadius
      ];
      const v10 = [
        f1.point[0] + (f1.normal[0] * cos0 + f1.binormal[0] * sin0) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos0 + f1.binormal[1] * sin0) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos0 + f1.binormal[2] * sin0) * tubeRadius
      ];
      const v11 = [
        f1.point[0] + (f1.normal[0] * cos1 + f1.binormal[0] * sin1) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos1 + f1.binormal[1] * sin1) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos1 + f1.binormal[2] * sin1) * tubeRadius
      ];
      
      const n00 = [f0.normal[0] * cos0 + f0.binormal[0] * sin0, f0.normal[1] * cos0 + f0.binormal[1] * sin0, f0.normal[2] * cos0 + f0.binormal[2] * sin0];
      const n01 = [f0.normal[0] * cos1 + f0.binormal[0] * sin1, f0.normal[1] * cos1 + f0.binormal[1] * sin1, f0.normal[2] * cos1 + f0.binormal[2] * sin1];
      const n10 = [f1.normal[0] * cos0 + f1.binormal[0] * sin0, f1.normal[1] * cos0 + f1.binormal[1] * sin0, f1.normal[2] * cos0 + f1.binormal[2] * sin0];
      const n11 = [f1.normal[0] * cos1 + f1.binormal[0] * sin1, f1.normal[1] * cos1 + f1.binormal[1] * sin1, f1.normal[2] * cos1 + f1.binormal[2] * sin1];
      
      const u0 = i / segments * 3;
      const u1 = (i + 1) / segments * 3;
      const v0 = r / radialSegments;
      const v1 = (r + 1) / radialSegments;
      
      positions.push(...v00, ...v10, ...v11, ...v00, ...v11, ...v01);
      normals.push(...n00, ...n10, ...n11, ...n00, ...n11, ...n01);
      texCoords.push(u0, v0, u1, v0, u1, v1, u0, v0, u1, v1, u0, v1);
    }
  }
  
  gl.enable(gl.DEPTH_TEST);
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  gl.useProgram(bgProgram);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(bgProgram, 'uBgTexture'), 0);
  
  const bgVerts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const bgBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, bgVerts, gl.STATIC_DRAW);
  const bgPosLoc = gl.getAttribLocation(bgProgram, 'aPosition');
  gl.enableVertexAttribArray(bgPosLoc);
  gl.vertexAttribPointer(bgPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.disableVertexAttribArray(bgPosLoc);
  
  gl.useProgram(tubeProgram);
  
  const posLoc = gl.getAttribLocation(tubeProgram, 'aPosition');
  const normLoc = gl.getAttribLocation(tubeProgram, 'aNormal');
  const texLoc = gl.getAttribLocation(tubeProgram, 'aTexCoord');
  
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  
  const normBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  
  const texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 3.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const projection = new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) / (near - far), -1,
    0, 0, (2 * far * near) / (near - far), 0
  ]);
  
  const angleY = -55 * Math.PI / 180 + rotation;
  const angleX = 0.3;
  const cy = Math.cos(angleY), sy = Math.sin(angleY);
  const cx = Math.cos(angleX), sx = Math.sin(angleX);
  const modelView = new Float32Array([
    cy, sy * sx, sy * cx, 0,
    0, cx, -sx, 0,
    -sy, cy * sx, cy * cx, 0,
    0, 0, -2.2, 1
  ]);
  
  const normalMatrix = new Float32Array([
    cy, sy * sx, sy * cx,
    0, cx, -sx,
    -sy, cy * sx, cy * cx
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uProjection'), false, projection);
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uModelView'), false, modelView);
  gl.uniformMatrix3fv(gl.getUniformLocation(tubeProgram, 'uNormalMatrix'), false, normalMatrix);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos'), 3.0, 3.0, 3.0);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos2'), -2.0, 1.0, 2.0);
  
  gl.activeTexture(gl.TEXTURE1);
  const tubeTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tubeTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.uniform1i(gl.getUniformLocation(tubeProgram, 'uTexture'), 1);
  
  gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disable(gl.DEPTH_TEST);
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE0);
  gl.deleteTexture(tubeTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(oldTexture);
  gl.deleteBuffer(bgBuffer);
  gl.deleteBuffer(posBuffer);
  gl.deleteBuffer(normBuffer);
  gl.deleteBuffer(texBuffer);
  gl.deleteProgram(tubeProgram);
  gl.deleteProgram(bgProgram);
  gl.useProgram(null);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnM(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hash = (i: number) => {
    const x = Math.sin(i * 127.1 + n * 311.7) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const scale = 12 + hash(0) * 30;
  const freqRatio = 1.02 + hash(1) * 0.1;
  const amp1 = 15 + hash(2) * 80;
  const amp2 = 15 + hash(3) * 80;
  const freq1 = 0.006 + hash(4) * 0.025;
  const angle1 = hash(5) * Math.PI;
  const angle2 = angle1 + (hash(6) - 0.5) * 0.3;
  const phase = hash(7) * Math.PI * 2;
  const hueShift = Math.floor(hash(8) * 360);
  const harmonic1 = 0.3 + hash(9) * 0.7;
  const harmonic2 = hash(10) * 0.5;
  const scaleRatio = 0.95 + hash(11) * 0.1;
  const crossAmp = hash(12) * 40;
  const crossFreq = 0.01 + hash(13) * 0.02;
  
  const cos_a1 = Math.cos(angle1), sin_a1 = Math.sin(angle1);
  const cos_a2 = Math.cos(angle2), sin_a2 = Math.sin(angle2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const rx1 = x * cos_a1 + y * sin_a1;
      const ry1 = -x * sin_a1 + y * cos_a1;
      const rx2 = x * cos_a2 + y * sin_a2;
      const ry2 = -x * sin_a2 + y * cos_a2;
      
      const wobble1 = Math.sin(rx1 * freq1) * amp1 
                    + Math.sin(rx1 * freq1 * 2.1) * amp1 * harmonic1
                    + Math.sin(ry1 * crossFreq) * crossAmp;
      const wobble2 = Math.sin(rx2 * freq1 * freqRatio + phase) * amp2
                    + Math.sin(rx2 * freq1 * freqRatio * 2.3 + phase) * amp2 * harmonic2
                    + Math.sin(ry2 * crossFreq * 1.1) * crossAmp;
      
      const wave1 = ry1 + wobble1;
      const wave2 = ry2 + wobble2;
      
      const line1 = Math.floor(wave1 / scale) % 2;
      const line2 = Math.floor(wave2 / (scale * scaleRatio)) % 2;
      
      const moire = line1 !== line2;
      
      const [r, g, b] = getPixel(prev, x, y);
      
      if (moire) {
        setPixel(out, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnN(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const scale = Math.min(ctx.width, ctx.height);
  const numLights = 15;
  
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const lights: { x: number; y: number; r: number; g: number; b: number; size: number }[] = [];
  for (let i = 0; i < numLights; i++) {
    const px = hash(i * 127.1) * ctx.width;
    const py = hash(i * 311.7) * ctx.height;
    const colorAngle = hash(i * 74.3) * Math.PI * 2;
    const size = 0.03 + hash(i * 191.3) * 0.04;
    lights.push({
      x: px, y: py,
      r: Math.cos(colorAngle) * 0.5 + 0.5,
      g: Math.cos(colorAngle + Math.PI * 2 / 3) * 0.5 + 0.5,
      b: Math.cos(colorAngle + Math.PI * 4 / 3) * 0.5 + 0.5,
      size
    });
  }
  
  const glowRadius = 8;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / (255 * 3);
      
      let tr = (pr / 255) * 0.3;
      let tg = (pg / 255) * 0.3;
      let tb = (pb / 255) * 0.3;
      
      if (brightness > 0.3) {
        let glowSum = 0;
        let glowR = 0, glowG = 0, glowB = 0;
        for (let dy = -glowRadius; dy <= glowRadius; dy += 2) {
          for (let dx = -glowRadius; dx <= glowRadius; dx += 2) {
            const sx = Math.max(0, Math.min(ctx.width - 1, x + dx));
            const sy = Math.max(0, Math.min(ctx.height - 1, y + dy));
            const [sr, sg, sb] = getPixel(prev, sx, sy);
            const sBright = (sr + sg + sb) / (255 * 3);
            if (sBright > 0.3) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              const weight = Math.max(0, 1 - dist / glowRadius);
              glowR += (sr / 255) * weight * sBright;
              glowG += (sg / 255) * weight * sBright;
              glowB += (sb / 255) * weight * sBright;
              glowSum += weight;
            }
          }
        }
        if (glowSum > 0) {
          tr += (glowR / glowSum) * brightness * 1.5;
          tg += (glowG / glowSum) * brightness * 1.5;
          tb += (glowB / glowSum) * brightness * 1.5;
        }
      }
      
      for (const light of lights) {
        const dx = (x - light.x) / scale;
        const dy = (y - light.y) / scale;
        const distSq = dx * dx + dy * dy;
        const glow = (light.size * light.size) / Math.max(0.0001, distSq);
        const cappedGlow = Math.min(1, glow);
        tr += cappedGlow * light.r;
        tg += cappedGlow * light.g;
        tb += cappedGlow * light.b;
      }
      
      setPixel(out, x, y,
        Math.min(255, Math.floor(tr * 255)),
        Math.min(255, Math.floor(tg * 255)),
        Math.min(255, Math.floor(tb * 255))
      );
    }
  }
  
  return out;
}

function fnO(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  
  const multiplier = 1.5 + n * 0.8;
  
  const nextPow2 = (v: number) => {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return v + 1;
  };
  
  const fftW = nextPow2(ctx.width);
  const fftH = nextPow2(ctx.height);
  
  const fftRow = new FFT(fftW);
  const fftCol = new FFT(fftH);
  
  const processChannel = (channel: Float32Array, mult: number, phaseShift: number): Float32Array => {
    const data = new Float64Array(fftW * fftH * 2);
    
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        data[(y * fftW + x) * 2] = channel[y * ctx.width + x];
      }
    }
    
    const rowIn = fftRow.createComplexArray();
    const rowOut = fftRow.createComplexArray();
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.transform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
        data[(y * fftW + x) * 2 + 1] = rowOut[x * 2 + 1];
      }
    }
    
    const colIn = fftCol.createComplexArray();
    const colOut = fftCol.createComplexArray();
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.transform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    const cx = fftW / 2;
    const cy = fftH / 2;
    const maxFreqDist = Math.sqrt(cx * cx + cy * cy);
    const wrapLimit = 255 * fftW * fftH / 4;
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        const i = (y * fftW + x) * 2;
        const re = data[i];
        const im = data[i + 1];
        const mag = Math.sqrt(re * re + im * im);
        let phase = Math.atan2(im, re);
        
        const dx = (x < cx ? x : x - fftW);
        const dy = (y < cy ? y : y - fftH);
        const freqDist = Math.sqrt(dx * dx + dy * dy) / maxFreqDist;
        
        let newMag = mag * mult;
        while (newMag > wrapLimit) {
          newMag = Math.abs(newMag - wrapLimit * 2);
        }
        
        phase += phaseShift * freqDist;
        
        data[i] = newMag * Math.cos(phase);
        data[i + 1] = newMag * Math.sin(phase);
      }
    }
    
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.inverseTransform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.inverseTransform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
      }
    }
    
    const result = new Float32Array(ctx.width * ctx.height);
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        result[y * ctx.width + x] = data[(y * fftW + x) * 2];
      }
    }
    
    return result;
  };
  
  const rIn = new Float32Array(ctx.width * ctx.height);
  const gIn = new Float32Array(ctx.width * ctx.height);
  const bIn = new Float32Array(ctx.width * ctx.height);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = y * ctx.width + x;
      rIn[idx] = r;
      gIn[idx] = g;
      bIn[idx] = b;
    }
  }
  
  const rOut = processChannel(rIn, multiplier, 0);
  const gOut = processChannel(gIn, multiplier * 1.1, Math.PI * 0.1);
  const bOut = processChannel(bIn, multiplier * 0.9, -Math.PI * 0.1);
  
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const idx = y * ctx.width + x;
      let r = rOut[idx];
      let g = gOut[idx];
      let b = bOut[idx];
      
      r = ((r % 256) + 256) % 256;
      g = ((g % 256) + 256) % 256;
      b = ((b % 256) + 256) % 256;
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnP(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(2, Math.min(n + 1, 50));
  
  for (let by = 0; by < ctx.height; by += cellSize) {
    for (let bx = 0; bx < ctx.width; bx += cellSize) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      let maxSat = 0;
      let mostSatR = 0, mostSatG = 0, mostSatB = 0;
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
          
          const [h, s, l] = rgbToHsl(r, g, b);
          if (s > maxSat) {
            maxSat = s;
            mostSatR = r;
            mostSatG = g;
            mostSatB = b;
          }
        }
      }
      
      const avgR = Math.round(sumR / count);
      const avgG = Math.round(sumG / count);
      const avgB = Math.round(sumB / count);
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const localX = x - bx;
          const localY = y - by;
          const isTopLeft = localX + localY < cellSize;
          
          if (isTopLeft) {
            setPixel(out, x, y, avgR, avgG, avgB);
          } else {
            setPixel(out, x, y, mostSatR, mostSatG, mostSatB);
          }
        }
      }
    }
  }
  
  return out;
}

let emeraldScene: THREE.Scene | null = null;
let emeraldRenderer: THREE.WebGLRenderer | null = null;
let emeraldCamera: THREE.PerspectiveCamera | null = null;
let emeraldModel: THREE.Group | null = null;
let emeraldModelLoaded = false;
let emeraldLoadPromise: Promise<void> | null = null;
let emeraldComposer: EffectComposer | null = null;

function initEmeraldScene(width: number, height: number) {
  if (!emeraldRenderer || emeraldRenderer.domElement.width !== width || emeraldRenderer.domElement.height !== height) {
    if (emeraldRenderer) {
      emeraldRenderer.dispose();
    }
    
    emeraldRenderer = new THREE.WebGLRenderer({ 
      alpha: true, 
      antialias: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance',
    });
    emeraldRenderer.setSize(width, height);
    emeraldRenderer.setPixelRatio(1);
    emeraldRenderer.setClearColor(0x000000, 0);
    emeraldRenderer.toneMapping = THREE.NoToneMapping;
    emeraldRenderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // Setup bloom for sparkle effect
    emeraldComposer = new EffectComposer(emeraldRenderer);
  }
  
  if (!emeraldScene) {
    emeraldScene = new THREE.Scene();
  }
  
  if (!emeraldCamera) {
    emeraldCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    emeraldCamera.position.set(0, 2, 5);
    emeraldCamera.lookAt(0, 0, 0);
  } else {
    emeraldCamera.aspect = width / height;
    emeraldCamera.updateProjectionMatrix();
  }
}

function loadEmeraldModel(): Promise<void> {
  if (emeraldLoadPromise) {
    return emeraldLoadPromise;
  }
  
  emeraldLoadPromise = new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    loader.load(
      './emerald.glb',
      (gltf) => {
        emeraldModel = gltf.scene;
        
        const box = new THREE.Box3().setFromObject(emeraldModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2.0 / maxDim;
        
        emeraldModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
        emeraldModel.scale.setScalar(scale);
        
        emeraldModelLoaded = true;
        resolve();
      },
      undefined,
      (error) => {
        console.error('Error loading emerald model:', error);
        reject(error);
      }
    );
  });
  
  return emeraldLoadPromise;
}

// Start loading immediately when module loads
export const emeraldReady = loadEmeraldModel();

function fnE(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  
  if (!emeraldModelLoaded || !emeraldModel) {
    throw new Error('Emerald model not loaded - await emeraldReady before rendering');
  }
  
  initEmeraldScene(ctx.width, ctx.height);
  
  while (emeraldScene!.children.length > 0) {
    emeraldScene!.remove(emeraldScene!.children[0]);
  }
  
  // Create background texture - preserve original colors
  const bgTexture = new THREE.DataTexture(
    prev.data,
    prev.width,
    prev.height,
    THREE.RGBAFormat
  );
  bgTexture.colorSpace = THREE.SRGBColorSpace;
  bgTexture.needsUpdate = true;
  bgTexture.flipY = true;
  emeraldScene!.background = bgTexture;

  // Create environment map for reflections
  const pmremGenerator = new THREE.PMREMGenerator(emeraldRenderer!);
  pmremGenerator.compileEquirectangularShader();
  const envRT = pmremGenerator.fromEquirectangular(bgTexture);
  emeraldScene!.environment = envRT.texture;

  // Low ambient for more contrast
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
  emeraldScene!.add(ambientLight);
  
  // Strong key light for highlights
  const keyLight = new THREE.DirectionalLight(0xffffff, 5.0);
  keyLight.position.set(5, 8, 10);
  emeraldScene!.add(keyLight);
  
  // Weak fill light - keeps shadows darker
  const fillLight = new THREE.DirectionalLight(0xeeffee, 0.8);
  fillLight.position.set(-5, 3, 8);
  emeraldScene!.add(fillLight);
  
  // Rim lights for edge highlights from multiple angles
  const rimLight = new THREE.DirectionalLight(0xffffff, 2.5);
  rimLight.position.set(0, -2, 8);
  emeraldScene!.add(rimLight);
  
  const rimLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight2.position.set(-6, 0, -2);
  emeraldScene!.add(rimLight2);
  
  const rimLight3 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight3.position.set(6, 0, -2);
  emeraldScene!.add(rimLight3);
  
  // Seeded random for deterministic light positions based on image count
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  // Dramatic point lights - fewer but more intense for contrast
  const numLights = 8;
  for (let i = 0; i < numLights; i++) {
    const angle = hash(i * 127.1) * Math.PI * 2;
    const elevation = hash(i * 311.7) * Math.PI * 0.5 + 0.3;
    const distance = 3 + hash(i * 74.3) * 5;
    
    const px = Math.cos(angle) * Math.cos(elevation) * distance;
    const py = Math.sin(elevation) * distance + 2;
    const pz = Math.sin(angle) * Math.cos(elevation) * distance + 4;
    
    const intensity = 15.0 + hash(i * 191.3) * 25.0;
    const light = new THREE.PointLight(0xffffff, intensity, 30);
    light.decay = 2;
    light.position.set(px, py, pz);
    emeraldScene!.add(light);
  }

  // Glass emerald material - pronounced edges with sheen
  const emeraldMaterial = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(0.3, 0.95, 0.5),
    metalness: 0.0,
    roughness: 0.0,
    transmission: 0.92,
    thickness: 0.4,
    ior: 1.3,
    envMapIntensity: 0.25,
    clearcoat: 1.0,
    clearcoatRoughness: 0.0,
    transparent: true,
    side: THREE.DoubleSide,
    flatShading: true,
    attenuationColor: new THREE.Color(0.0, 0.75, 0.25),
    attenuationDistance: 0.4,
    specularIntensity: 1.5,
    specularColor: new THREE.Color(1, 1, 1),
    reflectivity: 0.3,
    sheen: 0.5,
    sheenRoughness: 0.2,
    sheenColor: new THREE.Color(0.8, 1.0, 0.9),
  });
  
  // Corner positions extracted from the emerald geometry
  // Girdle corners (8 points around y ≈ 0.07)
  const girdleCorners = [
    [0.0, 0.064, -0.323],    // front
    [0.227, 0.069, -0.226],  // front-right
    [0.322, 0.063, 0.0],     // right
    [0.224, 0.072, 0.228],   // back-right
    [0.0, 0.064, 0.322],     // back
    [-0.227, 0.07, 0.226],   // back-left
    [-0.322, 0.07, 0.0],     // left (inferred)
    [-0.225, 0.069, -0.227], // front-left
  ];
  
  // Crown corners (upper facet intersections around y ≈ 0.176)
  const crownCorners = [
    [-0.169, 0.176, -0.092],
    [-0.089, 0.176, 0.174],
    [0.169, 0.176, -0.092],  // mirrored
    [0.089, 0.176, 0.174],   // mirrored
    [0.0, 0.176, -0.18],     // front center
    [0.0, 0.176, 0.18],      // back center
    [-0.15, 0.176, 0.0],     // left center
    [0.15, 0.176, 0.0],      // right center
  ];
  
  // Create subtle sparkle sprite texture
  const sparkleCanvas = document.createElement('canvas');
  sparkleCanvas.width = 64;
  sparkleCanvas.height = 64;
  const sctx = sparkleCanvas.getContext('2d')!;
  const cx = 32, cy = 32;
  
  // Soft subtle glow
  const gradient = sctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.3)');
  gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.08)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  sctx.fillStyle = gradient;
  sctx.fillRect(0, 0, 64, 64);
  
  // Very subtle cross rays
  sctx.globalCompositeOperation = 'lighter';
  const rayGradient = sctx.createLinearGradient(0, cy, 64, cy);
  rayGradient.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradient.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradient.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradient;
  sctx.fillRect(0, cy-1, 64, 2);
  
  const rayGradientV = sctx.createLinearGradient(cx, 0, cx, 64);
  rayGradientV.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradientV.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradientV.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradientV;
  sctx.fillRect(cx-1, 0, 2, 64);
  
  const sparkleTexture = new THREE.CanvasTexture(sparkleCanvas);
  
  const createSparkleMaterial = () => new THREE.SpriteMaterial({
    map: sparkleTexture,
    color: 0xffffff,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    depthWrite: false,
  });

  const addEmerald = (x: number, y: number, scale: number, logGeometry: boolean = false) => {
    const gem = emeraldModel!.clone();
    
    gem.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        const geom = child.geometry.clone();
        geom.computeVertexNormals();
        child.geometry = geom;
        child.material = emeraldMaterial;
        child.renderOrder = 1;
        
        // Log geometry info for the first emerald
        if (logGeometry) {
          const positions = geom.attributes.position;
          const normals = geom.attributes.normal;
          
          console.log('=== EMERALD GEOMETRY ===');
          console.log('Vertex count:', positions.count);
          console.log('Triangle count:', positions.count / 3);
          
          // Find unique vertices and their positions
          const uniqueVerts = new Map<string, {pos: number[], count: number, indices: number[]}>();
          
          for (let i = 0; i < positions.count; i++) {
            const px = positions.getX(i).toFixed(3);
            const py = positions.getY(i).toFixed(3);
            const pz = positions.getZ(i).toFixed(3);
            const key = `${px},${py},${pz}`;
            
            if (!uniqueVerts.has(key)) {
              uniqueVerts.set(key, {pos: [parseFloat(px), parseFloat(py), parseFloat(pz)], count: 0, indices: []});
            }
            uniqueVerts.get(key)!.count++;
            uniqueVerts.get(key)!.indices.push(i);
          }
          
          console.log('Unique vertex positions:', uniqueVerts.size);
          
          // Sort by how many triangles share this vertex (corners have more)
          const sorted = [...uniqueVerts.entries()].sort((a, b) => b[1].count - a[1].count);
          
          console.log('\nTop 20 most-shared vertices (likely corners):');
          sorted.slice(0, 20).forEach(([key, data], i) => {
            console.log(`  ${i+1}. [${data.pos.join(', ')}] shared by ${data.count} triangles`);
          });
          
          // Also log bounding box
          geom.computeBoundingBox();
          const bb = geom.boundingBox!;
          console.log('\nBounding box:');
          console.log('  min:', bb.min.x.toFixed(3), bb.min.y.toFixed(3), bb.min.z.toFixed(3));
          console.log('  max:', bb.max.x.toFixed(3), bb.max.y.toFixed(3), bb.max.z.toFixed(3));
        }
      }
    });
    
    gem.scale.setScalar(scale * 3.0);
    gem.position.set(x, y, 0);
    emeraldScene!.add(gem);
    
    // Add sparkle sprites at corner positions
    const allCorners = [...girdleCorners, ...crownCorners];
    const scaleFactor = scale * 3.0;
    
    allCorners.forEach((corner, i) => {
      // Only show sparkles on front-facing corners (positive z)
      if (corner[2] > 0) {
        const sprite = new THREE.Sprite(createSparkleMaterial());
        const sparkleSize = 0.03 + (i % 3) * 0.01;
        sprite.scale.set(sparkleSize * scaleFactor, sparkleSize * scaleFactor, 1);
        // Position at the corner, pushed forward a bit to be visible
        sprite.position.set(
          x + corner[0] * scaleFactor,
          y + corner[1] * scaleFactor,
          corner[2] * scaleFactor + 0.02
        );
        sprite.renderOrder = 10;
        emeraldScene!.add(sprite);
      }
    });
  };
  
  addEmerald(0, 0, 1.0, false);  // Main emerald
  addEmerald(-2.5, 0, 0.5);
  addEmerald(2.5, 0, 0.5);
  addEmerald(-1.5, 1.2, 0.35);
  addEmerald(1.5, 1.2, 0.35);
  addEmerald(-1.5, -1.2, 0.35);
  addEmerald(1.5, -1.2, 0.35);
  
  // Setup bloom passes
  emeraldComposer!.passes = [];
  const renderPass = new RenderPass(emeraldScene!, emeraldCamera!);
  emeraldComposer!.addPass(renderPass);
  
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(ctx.width, ctx.height),
    0.3,
    0.15,
    0.97
  );
  emeraldComposer!.addPass(bloomPass);
  
  // Render multiple times - transmission needs multiple passes to converge
  for (let i = 0; i < 6; i++) {
    emeraldComposer!.render();
  }
  
  const glContext = emeraldRenderer!.getContext();
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  glContext.readPixels(0, 0, ctx.width, ctx.height, glContext.RGBA, glContext.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  // Clean up
  bgTexture.dispose();
  envRT.texture.dispose();
  pmremGenerator.dispose();
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnR(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    #define PI 3.14159265359
    
    // Ray-plane intersection
    float intersectPlane(vec3 ro, vec3 rd, vec3 planeNormal, float planeD) {
      float denom = dot(rd, planeNormal);
      if (abs(denom) < 0.0001) return -1.0;
      return -(dot(ro, planeNormal) + planeD) / denom;
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Camera setup - looking into the room
      vec3 ro = vec3(0.0, 0.0, 2.5); // camera position
      vec2 screenPos = (uv - 0.5) * 2.0;
      screenPos.x *= aspect;
      vec3 rd = normalize(vec3(screenPos * 0.8, -1.0)); // ray direction
      
      // Room dimensions
      float roomSize = 2.0;
      float roomDepth = 3.0;
      
      // Light position (center of room)
      vec3 lightPos = vec3(0.0, 0.0, -roomDepth * 0.4);
      
      // Find closest intersection
      float tMin = 1000.0;
      vec3 hitNormal = vec3(0.0);
      vec2 texCoord = vec2(0.0);
      
      // Back wall (z = -roomDepth)
      float t = intersectPlane(ro, rd, vec3(0.0, 0.0, 1.0), roomDepth);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (abs(hit.x) < roomSize && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 0.0, 1.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Left wall (x = -roomSize)
      t = intersectPlane(ro, rd, vec3(1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(1.0, 0.0, 0.0);
          texCoord = vec2((hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Right wall (x = roomSize)
      t = intersectPlane(ro, rd, vec3(-1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(-1.0, 0.0, 0.0);
          texCoord = vec2((hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Floor (y = -roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, 1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, 1.0 - (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      // Ceiling (y = roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, -1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, -1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      vec3 color = vec3(0.0);
      
      if (tMin < 1000.0) {
        vec3 hitPos = ro + rd * tMin;
        
        // Sample texture
        texCoord = clamp(texCoord, 0.0, 1.0);
        vec3 texColor = texture2D(uTexture, texCoord).rgb;
        
        // Lighting
        vec3 toLight = lightPos - hitPos;
        float lightDist = length(toLight);
        vec3 lightDir = toLight / lightDist;
        
        // Diffuse
        float diff = max(dot(hitNormal, lightDir), 0.0);
        
        // Attenuation
        float attenuation = 1.0 / (1.0 + 0.1 * lightDist + 0.05 * lightDist * lightDist);
        
        // Ambient
        float ambient = 0.25;
        
        color = texColor * (ambient + diff * attenuation * 1.5);
      }
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnS(ctx: FnContext, j: number, size: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const popcount = (n: number): number => {
    let count = 0;
    while (n) {
      count += n & 1;
      n >>= 1;
    }
    return count;
  };
  
  const resolution = Math.pow(2, Math.floor((size - 1) / 10) + 2);
  
  const v0x = ctx.width / 2, v0y = 0;
  const v1x = 0, v1y = ctx.height;
  const v2x = ctx.width, v2y = ctx.height;
  
  const denom = (v1y - v2y) * (v0x - v2x) + (v2x - v1x) * (v0y - v2y);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const baryA = ((v1y - v2y) * (x - v2x) + (v2x - v1x) * (y - v2y)) / denom;
      const baryB = ((v2y - v0y) * (x - v2x) + (v0x - v2x) * (y - v2y)) / denom;
      const baryC = 1 - baryA - baryB;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (baryA < 0 || baryB < 0 || baryC < 0) {
        setPixel(out, x, y, pr, pg, pb);
        continue;
      }
      
      const ai = Math.floor(baryA * resolution);
      const bi = Math.floor(baryB * resolution);
      const ci = Math.floor(baryC * resolution);
      
      const overlap = (ai & bi) | (bi & ci) | (ai & ci);
      const level = popcount(overlap) % 6;
      
      const [or, og, ob] = getPixel(old, x, y);
      
      let r: number, g: number, b: number;
      
      switch (level) {
        case 0: {
          r = or; g = og; b = ob;
          break;
        }
        case 1: {
          r = 255 - pr; g = 255 - pg; b = 255 - pb;
          break;
        }
        case 2: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 120) % 360, s, l);
          break;
        }
        case 3: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 240) % 360, s, l);
          break;
        }
        case 4: {
          const gray = Math.round(pr * 0.299 + pg * 0.587 + pb * 0.114);
          const contrast = gray < 128 ? gray * 0.5 : 128 + (gray - 128) * 1.5;
          r = g = b = Math.max(0, Math.min(255, Math.round(contrast)));
          break;
        }
        case 5: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 60) % 360, Math.min(1, s * 1.5), l);
          break;
        }
        default:
          r = pr; g = pg; b = pb;
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewLeft(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (1 - 2 * y / ctx.height);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewRight(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (2 * y / ctx.height - 1);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnT(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numCubes = Math.max(1, n + 1);
  const seed = ctx.images.length * 137.5 + n * 17.0;
  const hash = (i: number) => {
    const x = Math.sin(i + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  interface CubeData {
    cx: number; cy: number; hw: number; hh: number; depth: number;
  }
  const cubesData: CubeData[] = [];
  for (let i = 0; i < numCubes; i++) {
    cubesData.push({
      cx: hash(i * 127.1),
      cy: hash(i * 311.7),
      hw: 0.03 + hash(i * 74.3) * 0.08,
      hh: 0.025 + hash(i * 183.9) * 0.06,
      depth: 0.1 + hash(i * 271.3) * 0.2
    });
  }
  
  const lightDirX = -0.3;
  const lightDirY = -0.4;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec4 worldPos = uModel * vec4(aPosition, 1.0);
      vWorldPos = worldPos.xyz;
      vNormal = mat3(uModel) * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * uView * worldPos;
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightDir;
    uniform float uIsBackground;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec3 color = texture2D(uTexture, vTexCoord).rgb;
      
      if (uIsBackground > 0.5) {
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(uLightDir);
        
        float ambient = 0.5;
        float diffuse = max(dot(normal, lightDir), 0.0) * 0.5;
        float lighting = ambient + diffuse;
        
        gl_FragColor = vec4(color * lighting, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  function createBox(cx: number, cy: number, hw: number, hh: number, depth: number): { vertices: number[], normals: number[], texCoords: number[] } {
    const x0 = cx - hw, x1 = cx + hw;
    const y0 = cy - hh, y1 = cy + hh;
    const z0 = 0, z1 = depth;
    
    const u0 = cx - hw, u1 = cx + hw;
    const v0 = cy - hh, v1 = cy + hh;
    
    const vertices: number[] = [];
    const normals: number[] = [];
    const texCoords: number[] = [];
    
    // Top face - textured with image at this position
    vertices.push(x0,y0,z1, x1,y0,z1, x1,y1,z1, x0,y0,z1, x1,y1,z1, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(0,0,1);
    texCoords.push(u0,v0, u1,v0, u1,v1, u0,v0, u1,v1, u0,v1);
    
    // Right face (+x)
    vertices.push(x1,y0,z0, x1,y0,z1, x1,y1,z1, x1,y0,z0, x1,y1,z1, x1,y1,z0);
    for(let i=0;i<6;i++) normals.push(1,0,0);
    texCoords.push(u1,v0, u1,v0, u1,v1, u1,v0, u1,v1, u1,v1);
    
    // Left face (-x)
    vertices.push(x0,y0,z1, x0,y0,z0, x0,y1,z0, x0,y0,z1, x0,y1,z0, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(-1,0,0);
    texCoords.push(u0,v0, u0,v0, u0,v1, u0,v0, u0,v1, u0,v1);
    
    // Front face (+y)
    vertices.push(x0,y1,z1, x1,y1,z1, x1,y1,z0, x0,y1,z1, x1,y1,z0, x0,y1,z0);
    for(let i=0;i<6;i++) normals.push(0,1,0);
    texCoords.push(u0,v1, u1,v1, u1,v1, u0,v1, u1,v1, u0,v1);
    
    // Back face (-y)
    vertices.push(x0,y0,z0, x1,y0,z0, x1,y0,z1, x0,y0,z0, x1,y0,z1, x0,y0,z1);
    for(let i=0;i<6;i++) normals.push(0,-1,0);
    texCoords.push(u0,v0, u1,v0, u1,v0, u0,v0, u1,v0, u0,v0);
    
    return { vertices, normals, texCoords };
  }
  
  const allVertices: number[] = [];
  const allNormals: number[] = [];
  const allTexCoords: number[] = [];
  
  for (const c of cubesData) {
    const box = createBox(c.cx, c.cy, c.hw, c.hh, c.depth);
    allVertices.push(...box.vertices);
    allNormals.push(...box.normals);
    allTexCoords.push(...box.texCoords);
  }
  
  gl.useProgram(program);
  gl.disable(gl.DEPTH_TEST);
  
  const bgVertices = new Float32Array([0,0,0, 1,0,0, 1,1,0, 0,0,0, 1,1,0, 0,1,0]);
  const bgNormals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]);
  const bgTexCoords = new Float32Array([0,0, 1,0, 1,1, 0,0, 1,1, 0,1]);
  
  const posLoc = gl.getAttribLocation(program, 'aPosition');
  const normLoc = gl.getAttribLocation(program, 'aNormal');
  const texLoc = gl.getAttribLocation(program, 'aTexCoord');
  
  const identity = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  const ortho = new Float32Array([2,0,0,0, 0,2,0,0, 0,0,-1,0, -1,-1,0,1]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, ortho);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, identity);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uModel'), false, identity);
  gl.uniform3f(gl.getUniformLocation(program, 'uLightDir'), lightDirX, lightDirY, 1.0);
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 1.0);
  
  const bgPosBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgPosBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgNormBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgNormBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgNormals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgTexBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgTexCoords, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 2.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const perspective = new Float32Array([
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)/(near-far), -1,
    0, 0, (2*far*near)/(near-far), 0
  ]);
  
  const camZ = 0.5 / Math.tan(fov / 2);
  const view = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -0.5, -0.5, -camZ, 1
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, perspective);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, view);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 0.0);
  
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const normBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const texBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allTexCoords), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, allVertices.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = (y * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.disable(gl.DEPTH_TEST);
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(bgPosBuf);
  gl.deleteBuffer(bgNormBuf);
  gl.deleteBuffer(bgTexBuf);
  gl.deleteBuffer(posBuf);
  gl.deleteBuffer(normBuf);
  gl.deleteBuffer(texBuf);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnU(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const w = ctx.width;
  const h = ctx.height;
  
  const hueAmount = 90 + (n % 12) * 15;
  const satAmount = 0.5 + (n % 8) * 0.1;
  const lightAmount = 0.06 + (n % 8) * 0.01;
  
  const baseAngle = n * 0.5;
  const angleH = baseAngle;
  const angleS = baseAngle + Math.PI * 2 / 3;
  const angleL = baseAngle + Math.PI * 4 / 3;
  
  const dirHX = Math.cos(angleH);
  const dirHY = Math.sin(angleH);
  const dirSX = Math.cos(angleS);
  const dirSY = Math.sin(angleS);
  const dirLX = Math.cos(angleL);
  const dirLY = Math.sin(angleL);
  
  const cx = w / 2;
  const cy = h / 2;
  const maxDist = Math.sqrt(cx * cx + cy * cy);
  
  const out = createSolidImage(w, h, '#000000');
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const [origR, origG, origB] = getPixel(prev, x, y);
      let [oh, os, ol] = rgbToHsl(origR, origG, origB);
      
      const rx = x - cx;
      const ry = y - cy;
      
      const tH = (rx * dirHX + ry * dirHY) / maxDist;
      const tS = (rx * dirSX + ry * dirSY) / maxDist;
      const tL = (rx * dirLX + ry * dirLY) / maxDist;
      
      const hueShift = tH * hueAmount;
      let nh = (oh + hueShift + 360) % 360;
      
      const satMod = 1 + Math.abs(tS) * satAmount;
      let ns = Math.min(1, os * satMod);
      
      const midtoneFactor = 1 - Math.pow(Math.abs(ol - 0.5) * 2, 2);
      const lightShift = tL * lightAmount * midtoneFactor;
      let nl = Math.max(0.05, Math.min(0.95, ol + lightShift));
      
      const [r, g, b] = hslToRgb(nh, ns, nl);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnV(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [tr, tg, tb] = hexToRgb(c);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy) * 0.7;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const vignette = Math.max(0, 1 - Math.pow(dist / maxR, 2));
      const darken = vignette;
      const tint = 1 - vignette;
      
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * darken + tr * tint * 0.5);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * darken + tg * tint * 0.5);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * darken + tb * tint * 0.5);
    }
  }
  
  return out;
}

function fnW(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const maxRotation = (n * 20) * (Math.PI / 180);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const falloff = (1 - normDist) * (1 - normDist);
      const rotation = maxRotation * falloff;
      
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const sx = cx + dx * cos - dy * sin;
      const sy = cy + dx * sin + dy * cos;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnX(ctx: FnContext, k: number, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const shapes = [
    '★', '●', '■', '▲', '◆', '♥', '✦', '⬡', '✚', '◐', '☽', '⚡', '∞', '☀', '✿', '⬢',
    '◯', '△', '□', '◇', '♦', '♣', '♠', '⬟', '⬠', '▽', '◁', '▷', '⊕', '⊗', '⊛', '⊚',
    '▣', '▤', '▥', '▦', '▧', '▨', '▩', '⬣', '⬤', '◉', '◎', '◈', '◊', '○', '◌', '◍',
    '◢', '◣', '◤', '◥', '♯', '♮', '♩', '♪', '✶', '✴', '✳', '✲', '✱', '✰', '✯', '✮'
  ];
  
  const shapeIdx = Math.abs(k) % 64;
  const symbol = shapes[shapeIdx];
  
  const size = Math.min(ctx.width, ctx.height) * 0.9;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = 'black';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  tempCtx.fillStyle = 'white';
  tempCtx.font = `${size}px serif`;
  tempCtx.textAlign = 'center';
  tempCtx.textBaseline = 'alphabetic';
  
  const metrics = tempCtx.measureText(symbol);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const yOffset = metrics.actualBoundingBoxAscent - actualHeight / 2;
  
  tempCtx.fillText(symbol, ctx.width / 2, ctx.height / 2 + yOffset);
  
  const maskData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  
  let avgR = 0, avgG = 0, avgB = 0;
  for (let i = 0; i < prev.data.length; i += 4) {
    avgR += prev.data[i];
    avgG += prev.data[i + 1];
    avgB += prev.data[i + 2];
  }
  const numPixels = prev.data.length / 4;
  avgR = Math.round(avgR / numPixels);
  avgG = Math.round(avgG / numPixels);
  avgB = Math.round(avgB / numPixels);
  
  for (let y = 0; y < ctx.height; y++) {
    const t = y / ctx.height;
    
    const gr = cr * (1 - t) + avgR * t;
    const gg = cg * (1 - t) + avgG * t;
    const gb = cb * (1 - t) + avgB * t;
    
    for (let x = 0; x < ctx.width; x++) {
      const maskIdx = (y * ctx.width + x) * 4;
      if (maskData.data[maskIdx] > 128) {
        const [pr, pg, pb] = getPixel(prev, x, y);
        const nr = Math.round(gr * 0.9 + pr * 0.1);
        const ng = Math.round(gg * 0.9 + pg * 0.1);
        const nb = Math.round(gb * 0.9 + pb * 0.1);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnY(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const sections = Math.max(2, Math.min(n, 36));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const sectionIdx = Math.floor(angle / (Math.PI * 2) * sections);
      const hueShift = (sectionIdx / sections) * 360;
      
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnZ(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const blurAmount = n * 4;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const sharpRadius = 0.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      if (normDist < sharpRadius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const blurStrength = Math.min(1, (normDist - sharpRadius) / (1 - sharpRadius));
        const samples = Math.max(1, Math.floor(blurStrength * blurAmount / 2));
        
        let sumR = 0, sumG = 0, sumB = 0;
        for (let i = 0; i <= samples; i++) {
          const t = i / samples;
          const sx = cx + dx * (1 - t * blurStrength * 0.5);
          const sy = cy + dy * (1 - t * blurStrength * 0.5);
          const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
          sumR += r;
          sumG += g;
          sumB += b;
        }
        
        setPixel(out, x, y, 
          Math.round(sumR / (samples + 1)),
          Math.round(sumG / (samples + 1)),
          Math.round(sumB / (samples + 1))
        );
      }
    }
  }
  
  return out;
}

function fnQ(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const temp = createSolidImage(hw, hh, '#000000');
  
  for (let y = 0; y < hh; y++) {
    for (let x = 0; x < hw; x++) {
      const sx = (x / hw) * prev.width;
      const sy = (y / hh) * prev.height;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      if (x / hw + y / hh > 1) {
        setPixel(temp, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(temp, x, y, r, g, b);
      }
    }
  }
  
  for (let qy = 0; qy < 2; qy++) {
    for (let qx = 0; qx < 2; qx++) {
      for (let y = 0; y < hh; y++) {
        for (let x = 0; x < hw; x++) {
          const outX = qx * hw + x;
          const outY = qy * hh + y;
          if (outX < ctx.width && outY < ctx.height) {
            const srcX = qx === 1 ? hw - 1 - x : x;
            const srcY = qy === 1 ? hh - 1 - y : y;
            const [r, g, b] = getPixel(temp, srcX, srcY);
            setPixel(out, outX, outY, r, g, b);
          }
        }
      }
    }
  }
  
  return out;
}

function fn0(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const nr = pr < 128 ? (2 * pr * or) / 255 : 255 - (2 * (255 - pr) * (255 - or)) / 255;
      const ng = pg < 128 ? (2 * pg * og) / 255 : 255 - (2 * (255 - pg) * (255 - og)) / 255;
      const nb = pb < 128 ? (2 * pb * ob) / 255 : 255 - (2 * (255 - pb) * (255 - ob)) / 255;
      
      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
    }
  }
  
  return out;
}

function fn1(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const barStart = Math.floor(ctx.width / 3);
  const barEnd = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (x >= barStart && x < barEnd) {
        let sr = 0, sg = 0, sb = 0;
        const kernel = [
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0]
        ];
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = kernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        sr = Math.max(0, Math.min(255, sr));
        sg = Math.max(0, Math.min(255, sg));
        sb = Math.max(0, Math.min(255, sb));
        
        const contrast = 1.3;
        sr = Math.max(0, Math.min(255, ((sr / 255 - 0.5) * contrast + 0.5) * 255));
        sg = Math.max(0, Math.min(255, ((sg / 255 - 0.5) * contrast + 0.5) * 255));
        sb = Math.max(0, Math.min(255, ((sb / 255 - 0.5) * contrast + 0.5) * 255));
        
        setPixel(out, x, y, Math.round(sr), Math.round(sg), Math.round(sb));
      } else {
        const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
        setPixel(out, x, y, gray, gray, gray);
      }
    }
  }
  
  return out;
}

function fn2(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const len = ctx.images.length;
  const img3 = len >= 3 ? ctx.images[len - 3] : (len >= 1 ? ctx.images[0] : prev);
  const img2 = len >= 2 ? ctx.images[len - 2] : prev;
  const img1 = prev;
  
  const third1 = Math.floor(ctx.width / 3);
  const third2 = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let src: Image;
      if (x < third1) {
        src = img3;
      } else if (x < third2) {
        src = img2;
      } else {
        src = img1;
      }
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn3(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripWidth = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < stripWidth; x++) {
      const srcX = Math.floor((y / ctx.height) * stripWidth);
      const srcY = Math.floor(((stripWidth - 1 - x) / stripWidth) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth; x < stripWidth * 2; x++) {
      const srcX = Math.floor(((x - stripWidth) / stripWidth) * stripWidth + stripWidth);
      const srcY = y;
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth * 2; x < ctx.width; x++) {
      const localX = x - stripWidth * 2;
      const srcX = Math.floor(((ctx.height - 1 - y) / ctx.height) * (ctx.width - stripWidth * 2) + stripWidth * 2);
      const srcY = Math.floor((localX / (ctx.width - stripWidth * 2)) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn4(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const rotatePoint = (x: number, y: number, cx: number, cy: number, angle: number): [number, number] => {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
  };
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const qx = x < hw ? 0 : 1;
      const qy = y < hh ? 0 : 1;
      const quadrant = qy * 2 + qx;
      const angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2];
      const angle = angles[quadrant];
      
      const localCx = qx === 0 ? hw / 2 : hw + hw / 2;
      const localCy = qy === 0 ? hh / 2 : hh + hh / 2;
      
      const [srcX, srcY] = rotatePoint(x, y, localCx, localCy, -angle);
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnD(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const n = 7;
  const numDrips = Math.max(1, n * 3);
  const dripStrength = Math.max(0.5, Math.min(n * 0.2 + 0.8, 2.0));
  const seed = ctx.images.length * 137.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uStrength;
    uniform int uNumDrips;
    uniform float uSeed;
    varying vec2 vUV;
    
    #define MAX_DRIPS 100
    #define MAX_STEPS 64
    #define WALL_Z 0.0
    #define EPS 0.001
    
    float hash(float n) {
      return fract(sin(n) * 43758.5453123);
    }
    
    // Smooth min for organic blending
    float smin(float a, float b, float k) {
      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
      return mix(b, a, h) - k * h * (1.0 - h);
    }
    
    // Simple sphere SDF
    float sdSphere(vec3 p, vec3 center, float r) {
      return length(p - center) - r;
    }
    
    // Scene SDF - randomly distributed clusters of 4 metaballs each
    float sceneSDF(vec3 p, int numClusters, float strength) {
      float d = 1000.0;
      
      for (int i = 0; i < MAX_DRIPS; i++) {
        if (i >= numClusters) break;
        
        float fi = float(i);
        
        // Random cluster center position across full screen (seeded by image count)
        float clusterX = (hash(fi * 127.1 + uSeed) * 2.0 - 1.0) * 1.5;
        float clusterY = (hash(fi * 311.7 + uSeed) * 2.0 - 1.0) * 1.2;
        
        // Cluster size
        float clusterSize = 0.15 + hash(fi * 74.3 + uSeed) * 0.15;
        
        // 4 balls per cluster (fixed to avoid dynamic loop issues)
        for (int j = 0; j < 4; j++) {
          float fj = float(j);
          float localSeed = fi * 100.0 + fj + uSeed;
          
          // Random offset from cluster center
          float offX = (hash(localSeed * 123.4) - 0.5) * clusterSize;
          float offY = (hash(localSeed * 234.5) - 0.5) * clusterSize * 1.5; // More vertical spread
          
          float x = clusterX + offX;
          float y = clusterY + offY;
          
          // Varying ball sizes within cluster
          float r = (0.06 + hash(localSeed * 345.6) * 0.08) * strength * 0.6;
          
          float z = 0.05 + r * 0.3;
          
          vec3 center = vec3(x, y, z);
          float sphere = sdSphere(p, center, r);
          
          // Smooth blend to merge balls in cluster
          d = smin(d, sphere, 0.12);
        }
      }
      
      return d;
    }
    
    // Calculate normal via gradient
    vec3 calcNormal(vec3 p, int numDrips, float strength) {
      vec2 e = vec2(0.001, 0.0);
      return normalize(vec3(
        sceneSDF(p + e.xyy, numDrips, strength) - sceneSDF(p - e.xyy, numDrips, strength),
        sceneSDF(p + e.yxy, numDrips, strength) - sceneSDF(p - e.yxy, numDrips, strength),
        sceneSDF(p + e.yyx, numDrips, strength) - sceneSDF(p - e.yyx, numDrips, strength)
      ));
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Ray origin and direction (orthographic-ish camera)
      vec3 ro = vec3((uv.x * 2.0 - 1.0) * aspect, uv.y * 2.0 - 1.0, 2.0);
      vec3 rd = vec3(0.0, 0.0, -1.0);
      
      // Raymarch to find metaball surface
      float t = 0.0;
      float d = 0.0;
      bool hit = false;
      vec3 p;
      
      for (int i = 0; i < MAX_STEPS; i++) {
        p = ro + rd * t;
        d = sceneSDF(p, uNumDrips, uStrength);
        
        if (d < EPS) {
          hit = true;
          break;
        }
        if (t > 4.0) break;
        
        t += d * 0.8;
      }
      
      // Sample wall texture
      vec4 wallColor = texture2D(uTexture, uv);
      
      if (hit) {
        vec3 normal = calcNormal(p, uNumDrips, uStrength);
        
        // Light from top (Y is flipped in screen coords)
        vec3 lightDir = normalize(vec3(0.0, -1.0, 0.6));
        vec3 viewDir = -rd;
        
        // Fresnel - edges reflect more
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
        
        // Specular highlight - bright and sharp
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 120.0);
        
        // Refraction - water has IOR ~1.33, so ratio is 1.0/1.33 ≈ 0.75
        vec3 refracted = refract(rd, normal, 0.75);
        vec2 refractUV = uv + refracted.xy * 0.06;
        refractUV = clamp(refractUV, 0.0, 1.0);
        vec4 refractColor = texture2D(uTexture, refractUV);
        
        // Clear water droplet - mostly shows refracted background
        vec3 dropletColor = refractColor.rgb;
        
        // Slight caustic brightening where light focuses
        float caustic = max(dot(normal, lightDir), 0.0);
        dropletColor *= 1.0 + caustic * 0.15;
        
        // Add crisp specular highlight
        dropletColor += vec3(1.0) * spec * 1.5;
        
        // Subtle rim highlight from fresnel
        dropletColor += vec3(1.0) * fresnel * 0.2;
        
        // Very subtle shadow directly under droplet on wall
        vec2 shadowUV = uv + vec2(0.01, 0.02);
        float shadowMask = smoothstep(0.05, 0.0, d) * 0.15;
        vec3 wallWithShadow = wallColor.rgb * (1.0 - shadowMask);
        
        // Droplet is almost fully transparent, just refracts
        gl_FragColor = vec4(dropletColor, 1.0);
      } else {
        gl_FragColor = wallColor;
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uStrength'), dripStrength);
  gl.uniform1i(gl.getUniformLocation(program, 'uNumDrips'), numDrips);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fn6(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const levels = 4;
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = Math.floor(out.data[i] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 1] = Math.floor(out.data[i + 1] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 2] = Math.floor(out.data[i + 2] / 256 * levels) * (255 / (levels - 1));
  }
  
  return out;
}

function fn7(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r] = getPixel(prev, x - 4, y);
      const [, g] = getPixel(prev, x, y);
      const [, , b] = getPixel(prev, x + 4, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn8(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.1, n / 5);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height) / 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / scale;
      const ny = (y - cy) / scale;
      
      const r2 = nx * nx + ny * ny;
      const denom = r2 + 1;
      
      const lemnX = nx * (r2 - 1) / denom;
      const lemnY = ny * (r2 + 1) / denom;
      
      const sx = cx + (nx + (lemnX - nx) * strength * 0.3) * scale;
      const sy = cy + (ny + (lemnY - ny) * strength * 0.3) * scale;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn9(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r1, g1, b1] = getPixel(prev, x, y);
      const [r2, g2, b2] = getPixel(old, x, y);
      
      setPixel(out, x, y, r1 ^ r2, g1 ^ g2, b1 ^ b2);
    }
  }
  
  return out;
}

function fnLessThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 8);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = (x + shift) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnGreaterThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = y * prev.width / ctx.height;
      const sy = (ctx.width - 1 - x) * prev.height / ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnCaret(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.height / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcY = (y + shift) % ctx.height;
      const [r, g, b] = getPixel(prev, x, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnExclaim(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const hash = (x: number, y: number, seed: number) => {
    const v = Math.sin(x * 127.1 + y * 311.7 + seed * 113.3) * 43758.5453;
    return v - Math.floor(v);
  };
  
  const n = 60;
  const baseLen = 8 + n * 5;
  const chaos = 0.5 + n * 0.15;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      
      if (s < 0.03 && l < 0.03) continue;
      if (l > 0.97) continue;
      
      const hueAngle = (h / 360) * Math.PI * 2;
      
      const turbulence = (hash(x, y, 1) - 0.5) * Math.PI * chaos;
      const swirl = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 0.5;
      
      const angle = hueAngle + turbulence + swirl;
      
      const lenNoise = 0.3 + hash(x, y, 2) * 0.7;
      const len = baseLen * s * (0.2 + l * 0.8) * lenNoise;
      
      if (len < 2) continue;
      
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      
      for (let i = 1; i <= len; i++) {
        const wobble = Math.sin(i * 0.5) * hash(x, y, 3) * 2;
        const px = Math.floor(x + dx * i + dy * wobble);
        const py = Math.floor(y + dy * i - dx * wobble);
        
        if (px >= 0 && px < ctx.width && py >= 0 && py < ctx.height) {
          const fade = 1 - (i / len);
          const brightness = fade * fade;
          const idx = (py * ctx.width + px) * 4;
          
          out.data[idx] = Math.min(255, Math.floor(out.data[idx] * (1 - brightness * 0.8) + r * brightness * 0.8));
          out.data[idx + 1] = Math.min(255, Math.floor(out.data[idx + 1] * (1 - brightness * 0.8) + g * brightness * 0.8));
          out.data[idx + 2] = Math.min(255, Math.floor(out.data[idx + 2] * (1 - brightness * 0.8) + b * brightness * 0.8));
        }
      }
    }
  }
  
  return out;
}

function fnDoubleQuote(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const bands = Math.max(2, n);
  const bandHeight = ctx.height / bands;
  
  for (let y = 0; y < ctx.height; y++) {
    const bandIdx = Math.floor(y / bandHeight);
    const isOdd = bandIdx % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (isOdd) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnHash(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const gridSize = Math.max(2, n + 2);
  
  const getCellBounds = (gx: number, gy: number): [number, number, number, number] => {
    const x0 = Math.floor(gx * ctx.width / gridSize);
    const x1 = Math.floor((gx + 1) * ctx.width / gridSize);
    const y0 = Math.floor(gy * ctx.height / gridSize);
    const y1 = Math.floor((gy + 1) * ctx.height / gridSize);
    return [x0, y0, x1, y1];
  };
  
  const cells: { gx: number; gy: number; hue: number }[] = [];
  
  for (let gy = 0; gy < gridSize; gy++) {
    for (let gx = 0; gx < gridSize; gx++) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      const [x0, y0, x1, y1] = getCellBounds(gx, gy);
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
        }
      }
      
      const avgR = count > 0 ? sumR / count : 0;
      const avgG = count > 0 ? sumG / count : 0;
      const avgB = count > 0 ? sumB / count : 0;
      const [hue] = rgbToHsl(avgR, avgG, avgB);
      
      cells.push({ gx, gy, hue });
    }
  }
  
  const sortedIndices = cells.map((_, i) => i).sort((a, b) => cells[a].hue - cells[b].hue);
  
  for (let i = 0; i < sortedIndices.length; i++) {
    const srcIdx = sortedIndices[i];
    const srcCell = cells[srcIdx];
    const [sx0, sy0, sx1, sy1] = getCellBounds(srcCell.gx, srcCell.gy);
    const srcW = sx1 - sx0;
    const srcH = sy1 - sy0;
    
    const targetGX = i % gridSize;
    const targetGY = Math.floor(i / gridSize);
    const [tx0, ty0, tx1, ty1] = getCellBounds(targetGX, targetGY);
    const targetW = tx1 - tx0;
    const targetH = ty1 - ty0;
    
    for (let ty = ty0; ty < ty1; ty++) {
      for (let tx = tx0; tx < tx1; tx++) {
        const srcX = sx0 + Math.floor((tx - tx0) * srcW / targetW);
        const srcY = sy0 + Math.floor((ty - ty0) * srcH / targetH);
        const [r, g, b] = getPixel(prev, srcX, srcY);
        setPixel(out, tx, ty, r, g, b);
      }
    }
  }
  
  return out;
}

function fnDollar(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const w = ctx.width;
  const h = ctx.height;
  
  const threshold = 12;
  
  const labels = new Int32Array(w * h);
  labels.fill(-1);
  
  const colorDist = (x1: number, y1: number, x2: number, y2: number): number => {
    const [r1, g1, b1] = getPixel(prev, x1, y1);
    const [r2, g2, b2] = getPixel(prev, x2, y2);
    return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
  };
  
  let currentLabel = 0;
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const idx = y * w + x;
      if (labels[idx] !== -1) continue;
      
      const queue: [number, number][] = [[x, y]];
      labels[idx] = currentLabel;
      
      while (queue.length > 0) {
        const [cx, cy] = queue.shift()!;
        
        const neighbors = [
          [cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]
        ];
        
        for (const [nx, ny] of neighbors) {
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
          const nidx = ny * w + nx;
          if (labels[nidx] !== -1) continue;
          
          if (colorDist(cx, cy, nx, ny) < threshold) {
            labels[nidx] = currentLabel;
            queue.push([nx, ny]);
          }
        }
      }
      
      currentLabel++;
    }
  }
  
  const segments = new Map<number, { x: number; y: number; r: number; g: number; b: number; hue: number }[]>();
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const label = labels[y * w + x];
      const [r, g, b] = getPixel(prev, x, y);
      const [hue] = rgbToHsl(r, g, b);
      
      if (!segments.has(label)) {
        segments.set(label, []);
      }
      segments.get(label)!.push({ x, y, r, g, b, hue });
    }
  }
  
  for (const [, pixels] of segments) {
    pixels.sort((a, b) => a.hue - b.hue);
    
    const positions = pixels.map(p => ({ x: p.x, y: p.y }));
    positions.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    
    for (let i = 0; i < pixels.length; i++) {
      const color = pixels[i];
      const pos = positions[i];
      setPixel(out, pos.x, pos.y, color.r, color.g, color.b);
    }
  }
  
  return out;
}

function fnPercent(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(1, n + 1);
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  const palette = corners.map(([r, g, b]) => [r, g, b] as [number, number, number]);
  
  const findClosest = (r: number, g: number, b: number): [number, number, number] => {
    let minDist = Infinity;
    let closest = palette[0];
    for (const [pr, pg, pb] of palette) {
      const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
      if (dist < minDist) {
        minDist = dist;
        closest = [pr, pg, pb];
      }
    }
    return closest;
  };
  
  const tempData = new Float32Array(ctx.width * ctx.height * 3);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = (y * ctx.width + x) * 3;
      tempData[idx] = r;
      tempData[idx + 1] = g;
      tempData[idx + 2] = b;
    }
  }
  
  for (let y = 0; y < ctx.height; y += cellSize) {
    for (let x = 0; x < ctx.width; x += cellSize) {
      const idx = (y * ctx.width + x) * 3;
      const oldR = tempData[idx];
      const oldG = tempData[idx + 1];
      const oldB = tempData[idx + 2];
      
      const [newR, newG, newB] = findClosest(oldR, oldG, oldB);
      
      for (let cy = 0; cy < cellSize && y + cy < ctx.height; cy++) {
        for (let cx = 0; cx < cellSize && x + cx < ctx.width; cx++) {
          setPixel(out, x + cx, y + cy, newR, newG, newB);
        }
      }
      
      const errR = oldR - newR;
      const errG = oldG - newG;
      const errB = oldB - newB;
      
      const distribute = (dx: number, dy: number, factor: number) => {
        const nx = x + dx * cellSize;
        const ny = y + dy * cellSize;
        if (nx >= 0 && nx < ctx.width && ny >= 0 && ny < ctx.height) {
          const nidx = (ny * ctx.width + nx) * 3;
          tempData[nidx] += errR * factor;
          tempData[nidx + 1] += errG * factor;
          tempData[nidx + 2] += errB * factor;
        }
      };
      
      distribute(1, 0, 7 / 16);
      distribute(-1, 1, 3 / 16);
      distribute(0, 1, 5 / 16);
      distribute(1, 1, 1 / 16);
    }
  }
  
  return out;
}

function fnAmpersand(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const luminance = pr * 0.299 + pg * 0.587 + pb * 0.114;
      const [oh, os, ol] = rgbToHsl(or, og, ob);
      const [nr, ng, nb] = hslToRgb(oh, os, luminance / 255);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnApostrophe(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const spacing = n + 2;
  
  for (let x = 0; x < ctx.width; x++) {
    if (x % spacing !== 0) continue;
    
    let colLuminance = 0;
    for (let y = 0; y < ctx.height; y++) {
      const [r, g, b] = getPixel(prev, x, y);
      colLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    colLuminance /= ctx.height;
    
    const streakLength = Math.floor((colLuminance / 255) * 100);
    const startY = 0;
    
    for (let y = startY; y < startY + streakLength && y < ctx.height; y++) {
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * 0.5 + 127));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * 0.5 + 127));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * 0.5 + 127));
    }
  }
  
  return out;
}

function fnOpenParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const pinchFactor = 1 + strength * (1 - normDist);
      const sx = cx + dx * pinchFactor;
      const sy = cy + dy * pinchFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const brighten = (1 - normDist) * strength * 30;
      r = Math.min(255, r + brighten);
      g = Math.min(255, g + brighten);
      b = Math.min(255, b + brighten);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnCloseParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const bulgeFactor = 1 - strength * normDist * 0.5;
      const sx = cx + dx * bulgeFactor;
      const sy = cy + dy * bulgeFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const darken = normDist * strength * 50;
      r = Math.max(0, r - darken);
      g = Math.max(0, g - darken);
      b = Math.max(0, b - darken);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnAsterisk(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRays = Math.max(2, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const opacity = 0.6;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const rayAngle = (Math.PI * 2) / numRays;
      const nearestRay = Math.round(angle / rayAngle) * rayAngle;
      const angleDiff = Math.abs(angle - nearestRay);
      
      const rayWidth = 0.05;
      if (angleDiff < rayWidth) {
        const softness = 1 - angleDiff / rayWidth;
        const sampleX = Math.floor(cx + Math.cos(nearestRay) * (ctx.width / numRays));
        const [sr, sg, sb] = getPixel(prev, sampleX, Math.floor(cy));
        
        const idx = (y * ctx.width + x) * 4;
        const blend = softness * opacity;
        out.data[idx] = Math.round(out.data[idx] * (1 - blend) + sr * blend);
        out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - blend) + sg * blend);
        out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - blend) + sb * blend);
      }
    }
  }
  
  return out;
}

function fnPlus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const zoom = 1.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = cx + (x - cx) / zoom;
      const sy = cy + (y - cy) / zoom;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnComma(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = Math.floor(r * 0.299 + g * 0.587 + b * 0.114);
      const divisor = 1 + Math.floor(luminance / 32);
      
      if ((x * 13 + y * 7) % divisor === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnMinus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const spacing = 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let [r, g, b] = getPixel(prev, x, y);
      
      if (y % spacing === 0) {
        r = Math.floor(r * 0.5);
        g = Math.floor(g * 0.5);
        b = Math.floor(b * 0.5);
      }
      
      if (y % (spacing * 2) === 0) {
        const srcY = Math.max(0, y - spacing);
        [r, g, b] = getPixel(prev, x, srcY);
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnDot(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const radius = (n % 8) + 2;
  const diameter = radius * 2;
  
  for (let cy = radius; cy < ctx.height; cy += diameter) {
    for (let cx = radius; cx < ctx.width; cx += diameter) {
      const [r, g, b] = getPixel(prev, cx, cy);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb(h, Math.min(1, s + 0.1), l);
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx * dx + dy * dy <= radius * radius) {
            setPixel(out, cx + dx, cy + dy, nr, ng, nb);
          }
        }
      }
    }
  }
  
  return out;
}

function fnSlash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = (x + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnColon(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const radius = Math.min(cx, cy) * 0.9;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < radius) {
        const [r, g, b] = getPixel(old, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnSemicolon(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const radius = Math.min(cx, cy) * 0.9;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (y < cy && dist < radius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (y >= cy) {
        const mirrorY = 2 * cy - y;
        const mirrorDx = x - cx;
        const mirrorDy = mirrorY - cy;
        const mirrorDist = Math.sqrt(mirrorDx * mirrorDx + mirrorDy * mirrorDy);
        
        if (mirrorDist < radius) {
          const wave = Math.sin(x * 0.1) * 10;
          const srcY = Math.floor(mirrorY + wave);
          const [r, g, b] = getPixel(prev, x, Math.max(0, Math.min(ctx.height - 1, srcY)));
          setPixel(out, x, y, r, g, b);
        }
      }
    }
  }
  
  return out;
}

function fnEquals(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripeHeight = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const stripeIdx = Math.floor(y / stripeHeight);
    const isOdd = stripeIdx % 2 === 1;
    const shift = isOdd ? stripeIdx * 5 : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = ((x + shift) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnQuestion(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  
  let sum = 0;
  for (const [r, g, b] of corners) {
    sum += r + g + b;
  }
  const effect = sum % 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (effect === 0) {
        const sr = r < 128 ? r : 255 - r;
        const sg = g < 128 ? g : 255 - g;
        const sb = b < 128 ? b : 255 - b;
        setPixel(out, x, y, sr * 2, sg * 2, sb * 2);
      } else if (effect === 1) {
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const weight = (kx === 0 && ky === 0) ? 8 : -1;
            gx += gray * weight;
          }
        }
        const embossVal = Math.max(0, Math.min(255, 128 + gx / 4));
        setPixel(out, x, y, embossVal, embossVal, embossVal);
      } else if (effect === 2) {
        const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
        const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const kidx = (ky + 1) * 3 + (kx + 1);
            gx += gray * sobelX[kidx];
            gy += gray * sobelY[kidx];
          }
        }
        const mag = Math.min(255, Math.sqrt(gx * gx + gy * gy));
        setPixel(out, x, y, mag, mag, mag);
      } else {
        const levels = 4;
        const pr = Math.floor(r / 256 * levels) * (255 / (levels - 1));
        const pg = Math.floor(g / 256 * levels) * (255 / (levels - 1));
        const pb = Math.floor(b / 256 * levels) * (255 / (levels - 1));
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

function fnOpenBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const angle = -20 * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const srcX = cx + dx * cos - dy * sin;
      const srcY = cy + dx * sin + dy * cos;
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnBackslash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = ((ctx.width - 1 - x) + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnCloseBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const offset = Math.floor(ctx.height * 0.2);
  const midX = Math.floor(ctx.width / 2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX) {
        const srcY = (y + offset) % ctx.height;
        const [r, g, b] = getPixel(prev, x, srcY);
        setPixel(out, x, y, r, g, b);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnUnderscore(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const blurShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDirection;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    void main() {
      vec2 texelSize = 1.0 / uResolution;
      vec3 result = vec3(0.0);
      
      float weights[5];
      weights[0] = 0.227027;
      weights[1] = 0.1945946;
      weights[2] = 0.1216216;
      weights[3] = 0.054054;
      weights[4] = 0.016216;
      
      result += texture2D(uTexture, vUV).rgb * weights[0];
      for (int i = 1; i < 5; i++) {
        vec2 offset = uDirection * texelSize * float(i) * 5.0;
        result += texture2D(uTexture, vUV + offset).rgb * weights[i];
        result += texture2D(uTexture, vUV - offset).rgb * weights[i];
      }
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const luminosityShader = `
    precision highp float;
    uniform sampler2D uPrev;
    uniform sampler2D uBlurred;
    varying vec2 vUV;
    
    void main() {
      vec2 flippedUV = vec2(vUV.x, 1.0 - vUV.y);
      vec3 prevColor = texture2D(uPrev, flippedUV).rgb;
      vec3 blurColor = texture2D(uBlurred, vUV).rgb;
      
      float prevLum = dot(prevColor, vec3(0.299, 0.587, 0.114));
      float blurLum = dot(blurColor, vec3(0.299, 0.587, 0.114));
      
      float scale = blurLum > 0.001 ? prevLum / blurLum : 1.0;
      vec3 result = clamp(blurColor * scale, 0.0, 1.0);
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const blurProgram = createShaderProgram(gl, vertexShader, blurShader);
  const luminosityProgram = createShaderProgram(gl, vertexShader, luminosityShader);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const tempTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const blurredTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const framebuffer = gl.createFramebuffer();
  
  gl.useProgram(blurProgram);
  const blurPosLoc = gl.getAttribLocation(blurProgram, 'position');
  gl.enableVertexAttribArray(blurPosLoc);
  gl.vertexAttribPointer(blurPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uResolution'), ctx.width, ctx.height);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.uniform1i(gl.getUniformLocation(blurProgram, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 1.0, 0.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, blurredTexture, 0);
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 0.0, 1.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.useProgram(luminosityProgram);
  const lumPosLoc = gl.getAttribLocation(luminosityProgram, 'position');
  gl.enableVertexAttribArray(lumPosLoc);
  gl.vertexAttribPointer(lumPosLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uPrev'), 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uBlurred'), 1);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(oldTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(tempTexture);
  gl.deleteTexture(blurredTexture);
  gl.deleteFramebuffer(framebuffer);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(blurProgram);
  gl.deleteProgram(luminosityProgram);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const glitchN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const shouldGlitch = (y * 17) % 23 < glitchN;
    const shiftAmount = shouldGlitch ? ((y * 31) % (glitchN * 20)) : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      if (shouldGlitch) {
        const srcXR = ((x - shiftAmount - glitchN) % ctx.width + ctx.width) % ctx.width;
        const srcXG = ((x - shiftAmount) % ctx.width + ctx.width) % ctx.width;
        const srcXB = ((x - shiftAmount + glitchN) % ctx.width + ctx.width) % ctx.width;
        
        const [rr] = getPixel(prev, srcXR, y);
        const [, gg] = getPixel(prev, srcXG, y);
        const [, , bb] = getPixel(prev, srcXB, y);
        
        setPixel(out, x, y, rr, gg, bb);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnOpenBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x < 0.5) {
        float localX = uv.x * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnPipe(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const midX = Math.floor(ctx.width / 2);
  const blendWidth = 5;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX - blendWidth) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (x > midX + blendWidth) {
        const [r, g, b] = getPixel(old, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const t = (x - (midX - blendWidth)) / (blendWidth * 2);
        const [pr, pg, pb] = getPixel(prev, x, y);
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y,
          Math.round(pr * (1 - t) + or * t),
          Math.round(pg * (1 - t) + og * t),
          Math.round(pb * (1 - t) + ob * t)
        );
      }
    }
  }
  
  return out;
}

function fnCloseBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x > 0.5) {
        float localX = (uv.x - 0.5) * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(0.5 + newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnOilSlick(ctx: FnContext, warpN: number, iridN: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const seed = ctx.images.length * 137.5 + warpN * 17.3 + iridN * 7.1;
  const depth = 1 + Math.floor(iridN / 4);
  const warpStrength = 0.05 + warpN * 0.025;
  const patternScale = 1.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uSeed;
    uniform int uDepth;
    uniform float uWarpStrength;
    uniform float uPatternScale;
    varying vec2 vUV;
    
    // Hash function for deterministic noise
    float hash(vec2 p, float seed) {
      return fract(sin(dot(p + seed * 0.1, vec2(127.1, 311.7))) * 43758.5453);
    }
    
    // Smooth noise
    float noise(vec2 p, float seed) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);
      
      float a = hash(i, seed);
      float b = hash(i + vec2(1.0, 0.0), seed);
      float c = hash(i + vec2(0.0, 1.0), seed);
      float d = hash(i + vec2(1.0, 1.0), seed);
      
      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }
    
    // FBM for organic patterns
    float fbm(vec2 p, float seed) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;
      for (int i = 0; i < 4; i++) {
        value += amplitude * noise(p * frequency, seed + float(i) * 100.0);
        amplitude *= 0.5;
        frequency *= 2.0;
      }
      return value;
    }
    
    // Domain warping effect - creates swirling patterns
    vec2 warpEffect(vec2 p, float i, float seed) {
      float angle = fbm(p * 0.8 + seed * 0.01, seed) * 6.28;
      float magnitude = fbm(p * 0.5 + seed * 0.02 + 50.0, seed + 100.0);
      return vec2(cos(angle), sin(angle)) * magnitude / (i * 0.3 + 1.0);
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Noise coordinates with offset to avoid symmetry
      vec2 noiseCoord = uv * 4.0 + vec2(uSeed * 0.1 + 5.7, uSeed * 0.07 + 3.2);
      noiseCoord.x *= aspect;
      
      // Calculate warp displacement from noise
      vec2 warp = vec2(0.0);
      for (int i = 1; i < 20; i++) {
        if (i >= uDepth) break;
        float fi = float(i);
        warp += warpEffect(noiseCoord + warp, fi, uSeed) * uWarpStrength;
      }
      
      // Apply warp as UV offset
      vec2 warpedUV = uv + warp * 0.15;
      warpedUV = clamp(warpedUV, 0.0, 1.0);
      
      // Sample texture at warped position
      vec3 texColor = texture2D(uTexture, warpedUV).rgb;
      
      // Oil slick lighting overlay based on noise
      float h = fbm(noiseCoord + warp, uSeed);
      float hx = fbm(noiseCoord + warp + vec2(0.05, 0.0), uSeed);
      float hy = fbm(noiseCoord + warp + vec2(0.0, 0.05), uSeed);
      
      // Fake normal from height field
      vec3 normal = normalize(vec3((h - hx) * 8.0, (h - hy) * 8.0, 1.0));
      
      // Light from top-left
      vec3 lightDir = normalize(vec3(0.5, 0.6, 1.0));
      float diffuse = max(dot(normal, lightDir), 0.0);
      
      // Specular highlight
      vec3 viewDir = vec3(0.0, 0.0, 1.0);
      vec3 reflectDir = reflect(-lightDir, normal);
      float spec = pow(max(dot(viewDir, reflectDir), 0.0), 24.0);
      
      // Lighting adjustment
      float lighting = 0.85 + diffuse * 0.2;
      float highlight = spec * 0.25;
      
      vec3 color = texColor * lighting + vec3(highlight);
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  gl.uniform1i(gl.getUniformLocation(program, 'uDepth'), depth);
  gl.uniform1f(gl.getUniformLocation(program, 'uWarpStrength'), warpStrength);
  gl.uniform1f(gl.getUniformLocation(program, 'uPatternScale'), patternScale);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnTilde(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const waveN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const amplitude = Math.sin(y * 0.05) * waveN * 8;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = Math.floor(((x + amplitude) % ctx.width + ctx.width) % ctx.width);
      
      const srcXR = Math.floor(((x + amplitude + waveN) % ctx.width + ctx.width) % ctx.width);
      const srcXB = Math.floor(((x + amplitude - waveN) % ctx.width + ctx.width) % ctx.width);
      
      const [rr] = getPixel(prev, srcXR, y);
      const [, gg] = getPixel(prev, srcX, y);
      const [, , bb] = getPixel(prev, srcXB, y);
      
      setPixel(out, x, y, rr, gg, bb);
    }
  }
  
  return out;
}

function fnHoles(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(pr, pg, pb);
      
      const midSat = s >= 0.35 && s <= 0.65;
      const midVal = l >= 0.35 && l <= 0.65;
      
      if (midSat || midVal) {
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y, or, og, ob);
      } else {
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

function wrapText(text: string, maxWidth: number): string[] {
  const lines: string[] = [];
  const paragraphs = text.split('\n');
  
  for (const para of paragraphs) {
    if (para.length === 0) {
      lines.push('');
      continue;
    }
    
    const words = para.split(' ');
    let currentLine = '';
    
    for (const word of words) {
      if (currentLine.length === 0) {
        currentLine = word;
      } else if (currentLine.length + 1 + word.length <= maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.length > 0) {
      lines.push(currentLine);
    }
  }
  
  return lines;
}

function generateIntroPage(charsPerLine: number): string[] {
  const introText = `QQQLANG: A syntax-free programming language for image synthesis

In QQQLANG, any string of visible uppercase ascii characters is a valid program.

Each character has three properties:
* An integer ('A'=1, 'B'=2, [...], '}'=67, '~'=68)
* A color
* A function

Functions can take zero or more arguments. If a function takes arguments, the characters that follow are interpreted as arguments. Otherwise characters are interpreted as functions. The exception is the first character of the program string which sets an initial solid color.

For example, the program 'ABCD' has the following interpretation:

* 'A' sets the intial color to #78A10F
* 'B' is the 'border' function that creates a circular gradient around the edges. It takes one argument, the border color.
* 'C' becomes the argument to 'B', the color of 'C' is #FF6B35
* 'D' is the 'drip' function, which creates a water drop effect. It takes no arguments.

If the program string ends before the last function has had arguments defined, it will use its own number and color as default arguments. For example, the programs 'AL', 'ALL', and 'ALLL' are equivalent.

The question mark character '?' is also a function that displays help text. '?1' and '??' show the first page of help, and '?A', '?B', etc. show subsequent pages of help text.`;

  return wrapText(introText, charsPerLine);
}

function generateCharacterRefLines(char: string, def: CharDef, charsPerLine: number): string[] {
  const lines: string[] = [];
  
  const argsStr = def.arity > 0 ? ` [${def.argTypes.join(', ')}]` : '';
  const header = `${char} (${def.number}) ${def.color} - ${def.functionName}${argsStr}`;
  lines.push(header);
  
  const docLines = wrapText('  ' + def.documentation, charsPerLine);
  lines.push(...docLines);
  
  return lines;
}

function getPageChar(pageNum: number): string {
  if (pageNum <= 0) return '?';
  if (pageNum === 1) return '?';
  if (pageNum <= 26) return String.fromCharCode('A'.charCodeAt(0) + pageNum - 1);
  return '?';
}

function generateAllHelpPages(charsPerLine: number, linesPerPage: number, defs: Record<string, CharDef>): string[][] {
  const pages: string[][] = [];
  
  const introLines = generateIntroPage(charsPerLine);
  
  let introPage: string[] = [];
  for (let i = 0; i < introLines.length; i++) {
    if (introPage.length >= linesPerPage - 2) {
      pages.push(introPage);
      introPage = [];
    }
    introPage.push(introLines[i]);
  }
  if (introPage.length > 0) {
    pages.push(introPage);
  }
  
  const chars = Object.keys(defs).sort((a, b) => defs[a].number - defs[b].number);
  
  let currentPage: string[] = [];
  currentPage.push('=== CHARACTER REFERENCE ===');
  currentPage.push('');
  let linesUsed = 2;
  
  for (const char of chars) {
    const def = defs[char];
    const charLines = generateCharacterRefLines(char, def, charsPerLine);
    
    if (linesUsed + charLines.length + 1 > linesPerPage - 2) {
      pages.push(currentPage);
      currentPage = [];
      currentPage.push('=== CHARACTER REFERENCE (continued) ===');
      currentPage.push('');
      linesUsed = 2;
    }
    
    currentPage.push(...charLines);
    currentPage.push('');
    linesUsed += charLines.length + 1;
  }
  
  if (currentPage.length > 2) {
    pages.push(currentPage);
  }
  
  const totalPages = pages.length;
  for (let i = 0; i < pages.length; i++) {
    const pageNum = i + 1;
    const nextPageChar = getPageChar(pageNum + 1);
    pages[i].push('');
    if (pageNum < totalPages) {
      pages[i].push(`[Page ${pageNum}/${totalPages}, type '?${nextPageChar}' for next page]`);
    } else {
      pages[i].push(`[Page ${pageNum}/${totalPages}]`);
    }
  }
  
  return pages;
}

function generateIndexPage(numPages: number): string[] {
  const lines: string[] = [];
  lines.push('=== QQQLANG HELP INDEX ===');
  lines.push('');
  lines.push('Available pages:');
  lines.push('');
  lines.push('?? or ?A - Introduction to QQQLANG');
  
  for (let i = 2; i <= Math.min(numPages, 26); i++) {
    const char = String.fromCharCode('A'.charCodeAt(0) + i - 1);
    if (i === 2) {
      lines.push(`?${char} - Character reference`);
    } else {
      lines.push(`?${char} - Character reference (continued)`);
    }
  }
  
  lines.push('');
  lines.push('Enter a valid page code to view help.');
  lines.push('Invalid page codes show this index.');
  
  return lines;
}

function fnHelp(ctx: FnContext, pageArg: number): Image {
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = '#000000';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  const marginFraction = 0.03;
  const margin = Math.max(10, Math.floor(Math.min(ctx.width, ctx.height) * marginFraction));
  
  const baseFontSize = Math.min(ctx.width, ctx.height) * 0.025;
  const fontSize = Math.max(8, Math.min(16, baseFontSize));
  const lineHeight = Math.floor(fontSize * 1.4);
  
  tempCtx.font = `${fontSize}px monospace`;
  tempCtx.fillStyle = '#00FF00';
  
  const charWidth = tempCtx.measureText('M').width;
  const charsPerLine = Math.max(20, Math.floor((ctx.width - margin * 2) / charWidth));
  const linesPerPage = Math.max(5, Math.floor((ctx.height - margin * 2) / lineHeight));
  
  let page: number;
  if (pageArg === 58 || pageArg === 1) {
    page = 1;
  } else {
    page = pageArg;
  }
  
  const pages = generateAllHelpPages(charsPerLine, linesPerPage, characterDefs);
  
  let lines: string[];
  if (page >= 1 && page <= pages.length) {
    lines = pages[page - 1];
  } else {
    lines = generateIndexPage(pages.length);
  }
  
  let y = margin + fontSize;
  for (let i = 0; i < Math.min(lines.length, linesPerPage); i++) {
    tempCtx.fillText(lines[i], margin, y);
    y += lineHeight;
  }
  
  const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  out.data.set(imageData.data);
  
  return out;
}

export const characterDefs: Record<string, CharDef> = {
  'A': {
    color: '#78A10F',
    number: 1,
    fn: fnA,
    arity: 0,
    argTypes: [],
    functionName: "sphere-overlay",
    documentation: "Renders prev as texture on two 3D spheres with lighting in top-right and bottom-left quadrants"
  },
  
  'B': {
    color: '#8B4513',
    number: 2,
    fn: fnV,
    arity: 1,
    argTypes: ['color'],
    functionName: "border",
    documentation: "Circular gradient darkening edges, tinted toward color c"
  },
  
  'C': {
    color: '#FF6B35',
    number: 3,
    fn: fnC,
    arity: 1,
    argTypes: ['int'],
    functionName: "concentric-hue",
    documentation: "Creates n concentric circles alternating between original and hue-shifted versions"
  },
  
  'D': {
    color: '#FF1493',
    number: 4,
    fn: fnD,
    arity: 0,
    argTypes: [],
    functionName: "drip",
    documentation: "Metaball-based dripping effect with blobby liquid drips"
  },
  
  'E': {
    color: '#50C878',
    number: 5,
    fn: fnE,
    arity: 0,
    argTypes: [],
    functionName: "emerald",
    documentation: "Renders bright reflective 3D emeralds in symmetric pattern with large center emerald"
  },
  
  'F': {
    color: '#FFD700',
    number: 6,
    fn: fnO,
    arity: 1,
    argTypes: ['int'],
    functionName: "fft-overflow",
    documentation: "2D FFT with magnitude overflow/wrap and per-channel phase shifts - creates banded halos and chromatic frequency ghosts"
  },
  
  'G': {
    color: '#9370DB',
    number: 7,
    fn: fnG,
    arity: 1,
    argTypes: ['int'],
    functionName: "grayscale-colorize",
    documentation: "Converts to grayscale then applies n-color rainbow palette based on brightness"
  },
  
  'H': {
    color: '#DC143C',
    number: 8,
    fn: fnH,
    arity: 0,
    argTypes: [],
    functionName: "hourglass",
    documentation: "Hourglass gradient: NAND blend inside hourglass shape, XOR/add/diff blend outside, creates colors from gradients"
  },
  
  'I': {
    color: '#00FF7F',
    number: 9,
    fn: fnI,
    arity: 0,
    argTypes: [],
    functionName: "invert-edges",
    documentation: "Inverts prev colors, then applies Sobel edge detection and draws edges in white"
  },
  
  'J': {
    color: '#FF8C00',
    number: 10,
    fn: fnF,
    arity: 1,
    argTypes: ['int'],
    functionName: "julia-fractal",
    documentation: "Julia set fractal masks prev - inside set shows prev, outside darkened; n controls zoom level"
  },
  
  'K': {
    color: '#4B0082',
    number: 11,
    fn: fnK,
    arity: 1,
    argTypes: ['int'],
    functionName: "kaleidoscope",
    documentation: "Creates n-way kaleidoscope effect centered on image with 1.1x zoom"
  },
  
  'L': {
    color: '#20B2AA',
    number: 12,
    fn: fnL,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "lissajous",
    documentation: "3D Lissajous tube textured with prev, old_image as background; j=old image, rot=rotation"
  },
  
  'M': {
    color: '#FF69B4',
    number: 13,
    fn: fnM,
    arity: 1,
    argTypes: ['int'],
    functionName: "moire",
    documentation: "Moiré interference pattern: 3 overlapping line grids create 8 zones with different hue/saturation/lightness shifts"
  },
  
  'N': {
    color: '#8A2BE2',
    number: 14,
    fn: fnN,
    arity: 0,
    argTypes: [],
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnOilSlick,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "oil-slick",
    documentation: "Domain warping effect; first arg controls warp strength, second controls iterations/complexity"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
    documentation: "Pixelates with cell size n+1, diagonal split: top-left = average, bottom-right = most saturated"
  },
  
  'Q': {
    color: '#32CD32',
    number: 17,
    fn: fnQ,
    arity: 0,
    argTypes: [],
    functionName: "prism",
    documentation: "Creates negative prism: diagonal split with inversion, then mirrors into 4 quadrants (h-flip right, v-flip bottom)"
  },
  
  'R': {
    color: '#DA70D6',
    number: 18,
    fn: fnR,
    arity: 0,
    argTypes: [],
    functionName: "room",
    documentation: "3D room with three walls, ceiling, and floor textured with prev, lit from center"
  },
  
  'S': {
    color: '#87CEEB',
    number: 19,
    fn: fnS,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "sierpinski",
    documentation: "Sierpiński triangle fractal: j=old image for interior, size=detail level (1-68); outer shells get hue shifts, invert, grayscale"
  },
  
  'T': {
    color: '#F0E68C',
    number: 20,
    fn: fnT,
    arity: 1,
    argTypes: ['int'],
    functionName: "cubes",
    documentation: "n+1 3D cubes protrude from prev plane toward camera, tops textured from prev, sides use edge pixels, lit from front"
  },
  
  'U': {
    color: '#DDA0DD',
    number: 21,
    fn: fnU,
    arity: 1,
    argTypes: ['int'],
    functionName: "undertone",
    documentation: "HSL color shift with three gradient directions 120° apart: hue rotation, saturation multiply, lightness adjust (midtone-weighted); n controls angle and intensity"
  },
  
  'V': {
    color: '#40E0D0',
    number: 22,
    fn: fnB,
    arity: 1,
    argTypes: ['int'],
    functionName: "voronoi",
    documentation: "Breaks image into 36 voronoi cells, alternating between prev and old image"
  },
  
  'W': {
    color: '#EE82EE',
    number: 23,
    fn: fnW,
    arity: 1,
    argTypes: ['int'],
    functionName: "swirl",
    documentation: "Swirl distortion from center, rotation = n*45°, quadratic falloff"
  },
  
  'X': {
    color: '#F5DEB3',
    number: 24,
    fn: fnX,
    arity: 2,
    argTypes: ['int', 'color'],
    functionName: "shape-overlay",
    documentation: "Draws unicode shape k%64 at center in color c (★●■▲◆♥✦⬡✚◐☽⚡∞☀✿⬢...)"
  },
  
  'Y': {
    color: '#98FB98',
    number: 25,
    fn: fnY,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-hue",
    documentation: "Splits into n radial sections, each hue-rotated by i*(360/n)°"
  },
  
  'Z': {
    color: '#AFEEEE',
    number: 26,
    fn: fnZ,
    arity: 1,
    argTypes: ['int'],
    functionName: "zoom-blur",
    documentation: "Radial motion blur from center, blur amount n*4px, center 20% stays sharp"
  },
  
  '0': {
    color: '#E6E6FA',
    number: 27,
    fn: fn0,
    arity: 1,
    argTypes: ['int'],
    functionName: "overlay",
    documentation: "Overlay blend mode: combines prev with old_image at index j, darkening darks and lightening lights"
  },
  
  '1': {
    color: '#FFA07A',
    number: 28,
    fn: fn1,
    arity: 0,
    argTypes: [],
    functionName: "center-bar",
    documentation: "Middle third of image shows prev sharpened and contrast-boosted, rest is desaturated"
  },
  
  '2': {
    color: '#98D8C8',
    number: 29,
    fn: fn2,
    arity: 0,
    argTypes: [],
    functionName: "time-echo",
    documentation: "Left third shows 3rd previous image, middle shows 2nd previous, right shows prev - recent history triptych"
  },
  
  '3': {
    color: '#F7DC6F',
    number: 30,
    fn: fn3,
    arity: 0,
    argTypes: [],
    functionName: "triple-rotate",
    documentation: "Divides into 3 vertical strips; left rotated 90° CW, middle unchanged, right rotated 90° CCW"
  },
  
  '4': {
    color: '#BB8FCE',
    number: 31,
    fn: fn4,
    arity: 0,
    argTypes: [],
    functionName: "quad-rotate",
    documentation: "Divides into 2x2 quadrants, each rotated (0°, 90°, 180°, 270°)"
  },
  
  '5': {
    color: '#85C1E9',
    number: 32,
    fn: fn5,
    arity: 1,
    argTypes: ['int'],
    functionName: "triangular-split",
    documentation: "Splits prev into triangles based on cell width, each with hue shift and lightness variation"
  },
  
  '6': {
    color: '#F1948A',
    number: 33,
    fn: fn6,
    arity: 0,
    argTypes: [],
    functionName: "posterize",
    documentation: "Posterizes prev to 4 levels per channel"
  },
  
  '7': {
    color: '#82E0AA',
    number: 34,
    fn: fn7,
    arity: 0,
    argTypes: [],
    functionName: "chromatic",
    documentation: "Chromatic aberration: R shifted left 4px, G centered, B shifted right 4px"
  },
  
  '8': {
    color: '#F8C471',
    number: 35,
    fn: fn8,
    arity: 1,
    argTypes: ['int'],
    functionName: "lemniscate",
    documentation: "Infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along curve"
  },
  
  '9': {
    color: '#D7BDE2',
    number: 36,
    fn: fn9,
    arity: 1,
    argTypes: ['int'],
    functionName: "xor-blend",
    documentation: "XORs prev with old_image at index j, creating glitchy digital artifacts"
  },
  
  '<': {
    color: '#E74C3C',
    number: 37,
    fn: fnLessThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-left",
    documentation: "Shifts prev 1/3 of the width to the left with wraparound"
  },
  
  '>': {
    color: '#3498DB',
    number: 38,
    fn: fnGreaterThan,
    arity: 0,
    argTypes: [],
    functionName: "rotate-90",
    documentation: "Rotates prev 90 degrees clockwise"
  },
  
  '^': {
    color: '#2ECC71',
    number: 39,
    fn: fnCaret,
    arity: 0,
    argTypes: [],
    functionName: "shift-up",
    documentation: "Shifts prev 1/3 of the height up with wraparound"
  },
  
  '!': {
    color: '#FF4500',
    number: 40,
    fn: fnExclaim,
    arity: 0,
    argTypes: [],
    functionName: "fur",
    documentation: "Fur/hair effect: strands grow from each pixel with direction based on hue plus turbulence and swirl"
  },
  
  '"': {
    color: '#9932CC',
    number: 41,
    fn: fnDoubleQuote,
    arity: 1,
    argTypes: ['int'],
    functionName: "band-transform",
    documentation: "Splits into n horizontal bands; odd bands hue-rotated 180°, even bands have saturation inverted"
  },
  
  '#': {
    color: '#228B22',
    number: 42,
    fn: fnQuestion,
    arity: 0,
    argTypes: [],
    functionName: "corner-effect",
    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
  },
  
  '$': {
    color: '#FFD700',
    number: 43,
    fn: fnDollar,
    arity: 0,
    argTypes: [],
    functionName: "segment-hue-sort",
    documentation: "Color-based flood-fill segmentation, then sorts pixels within each segment by hue vertically"
  },
  
  '%': {
    color: '#8B0000',
    number: 44,
    fn: fnPercent,
    arity: 1,
    argTypes: ['int'],
    functionName: "floyd-steinberg",
    documentation: "Floyd-Steinberg dithers prev to 4-corner color palette with cell size n+1"
  },
  
  '&': {
    color: '#4169E1',
    number: 45,
    fn: fnAmpersand,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-sat-transfer",
    documentation: "Output has prev's luminance but hue/saturation from old_image at index j"
  },
  
  "'": {
    color: '#FF1493',
    number: 46,
    fn: fnJ,
    arity: 1,
    argTypes: ['int'],
    functionName: "variable-checkerboard",
    documentation: "Checkerboard blend where square size increases from top-left (2px) to bottom-right (52px)"
  },
  
  '(': {
    color: '#00CED1',
    number: 47,
    fn: fnOpenParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "pinch",
    documentation: "Pinch distortion toward center with strength n/10, brightens pixels near center"
  },
  
  ')': {
    color: '#FF69B4',
    number: 48,
    fn: fnCloseParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "bulge",
    documentation: "Bulge distortion from center with strength n/10, darkens pixels near edge"
  },
  
  '*': {
    color: '#FFD700',
    number: 49,
    fn: fnAsterisk,
    arity: 1,
    argTypes: ['int'],
    functionName: "rays",
    documentation: "n rays emanate from center, color sampled from prev at angle*width/n, soft edges at 60% opacity"
  },
  
  '+': {
    color: '#32CD32',
    number: 50,
    fn: fnPlus,
    arity: 0,
    argTypes: [],
    functionName: "zoom",
    documentation: "Zooms in 1.2x from center, can be repeated for more zoom"
  },
  
  ',': {
    color: '#BA55D3',
    number: 51,
    fn: fnComma,
    arity: 1,
    argTypes: ['color'],
    functionName: "stipple",
    documentation: "Stipples prev with dots of color c at positions where (x*13+y*7) % (1+luminance/32) == 0"
  },
  
  '-': {
    color: '#708090',
    number: 52,
    fn: fnMinus,
    arity: 0,
    argTypes: [],
    functionName: "scanlines",
    documentation: "CRT scanline effect: every 2nd row darkened 50%, every 4th row samples from 2 pixels above"
  },
  
  '.': {
    color: '#20B2AA',
    number: 53,
    fn: fnDot,
    arity: 1,
    argTypes: ['int'],
    functionName: "pointillism",
    documentation: "Rebuilds prev from circles of radius (n%8)+2, color from center with +10% saturation"
  },
  
  '/': {
    color: '#CD853F',
    number: 54,
    fn: fnSlash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines",
    documentation: "Diagonal lines top-left to bottom-right in color c, spacing based on luminance (bright=sparse)"
  },
  
  ':': {
    color: '#6B8E23',
    number: 55,
    fn: fnColon,
    arity: 1,
    argTypes: ['int'],
    functionName: "porthole",
    documentation: "Shows old image j in a center circle (radius 90% of half-size), prev image outside"
  },
  
  ';': {
    color: '#DB7093',
    number: 56,
    fn: fnSemicolon,
    arity: 0,
    argTypes: [],
    functionName: "semicircle-reflect",
    documentation: "Semicircle arc (top half) crops prev, bottom half is reflection with wave distortion"
  },
  
  '=': {
    color: '#5F9EA0',
    number: 57,
    fn: fnEquals,
    arity: 1,
    argTypes: ['int'],
    functionName: "shifted-stripes",
    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
  },
  
  '?': {
    color: '#D2691E',
    number: 58,
    fn: fnHelp,
    arity: 1,
    argTypes: ['int'],
    functionName: "help",
    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, invalid pages show index"
  },
  
  '@': {
    color: '#7B68EE',
    number: 59,
    fn: fnHoles,
    arity: 1,
    argTypes: ['int'],
    functionName: "midtone-reveal",
    documentation: "Shows old image j where prev has mid-range (35-65%) saturation or lightness; extremes show prev"
  },
  
  '[': {
    color: '#48D1CC',
    number: 60,
    fn: fnOpenBracket,
    arity: 0,
    argTypes: [],
    functionName: "rotate-left",
    documentation: "Rotates prev 20 degrees counter-clockwise"
  },
  
  '\\': {
    color: '#C71585',
    number: 61,
    fn: fnBackslash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines-reverse",
    documentation: "Diagonal lines from top-right to bottom-left in color c, spacing based on luminance"
  },
  
  ']': {
    color: '#00FA9A',
    number: 62,
    fn: fnCloseBracket,
    arity: 0,
    argTypes: [],
    functionName: "left-half-offset",
    documentation: "Offsets the left half of the image vertically by 20% with wraparound"
  },
  
  '_': {
    color: '#FF7F50',
    number: 63,
    fn: fnUnderscore,
    arity: 1,
    argTypes: ['int'],
    functionName: "blur-luminosity",
    documentation: "Luminosity blend: colors from heavily blurred old image j, luminance/structure from prev"
  },
  
  '`': {
    color: '#6495ED',
    number: 64,
    fn: fnBacktick,
    arity: 1,
    argTypes: ['int'],
    functionName: "glitch",
    documentation: "Glitch effect: horizontal strips shifted right with RGB separation of n pixels"
  },
  
  '{': {
    color: '#DC143C',
    number: 65,
    fn: fnSkewLeft,
    arity: 0,
    argTypes: [],
    functionName: "skew-left",
    documentation: "Skews image 20 degrees left (top shifts left, bottom shifts right) with wraparound"
  },
  
  '|': {
    color: '#00BFFF',
    number: 66,
    fn: fnPipe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-split",
    documentation: "Left half is prev, right half is old_image, center column is 10px blend"
  },
  
  '}': {
    color: '#9400D3',
    number: 67,
    fn: fnSkewRight,
    arity: 0,
    argTypes: [],
    functionName: "skew-right",
    documentation: "Skews image 20 degrees right (top shifts right, bottom shifts left) with wraparound"
  },
  
  '~': {
    color: '#FF6347',
    number: 68,
    fn: fnTilde,
    arity: 1,
    argTypes: ['int'],
    functionName: "wave-chromatic",
    documentation: "Horizontal wave distortion with amplitude = sin(y*0.05)*n*8, chromatic aberration (R +n px, B -n px)"
  },
};
</eval-result-223027560053>}

---

# index.html:

${:sh cat index.html<eval-result-223027633229><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QQQLANG</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="favicon-192.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
      background: #000;
    }
    
    #app {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    
    #input-container {
      flex-shrink: 0;
      padding: 10px;
      background: #000;
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    
    #input-wrapper {
      position: relative;
      flex: 1;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      height: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      background: transparent;
      color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      background: #1a1a1a;
      color: transparent;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      padding: 1px 0;
    }
    
    .toolbar-button {
      padding: 10px 15px;
      font-size: 14px;
      font-family: monospace;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .toolbar-button:hover {
      border-color: #888;
      background: #333;
    }
    
    .toolbar-button:active {
      background: #444;
    }
    
    .btn-icon {
      display: none;
    }
    
    @media (max-width: 600px) {
      .btn-text {
        display: none;
      }
      .btn-icon {
        display: inline;
        font-size: 18px;
      }
      .toolbar-button {
        padding: 10px 12px;
      }
    }
    
    #canvas-container {
      flex: 1;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #canvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
    
    #intro-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 1000;
      transition: opacity 1s ease-out;
    }
    
    #intro-overlay.fading {
      opacity: 0;
      pointer-events: none;
    }
    
    #intro-overlay.hidden {
      display: none;
    }
    
    #intro-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
  </style>
</head>
<body>
  <div id="app">
    <div id="input-container">
      <div id="input-wrapper">
        <div id="input-background"></div>
        <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
      </div>
      <button id="download-button" class="toolbar-button"><span class="btn-text">Download</span><span class="btn-icon">⬇</span></button>
      <button id="help-button" class="toolbar-button"><span class="btn-text">Help</span><span class="btn-icon">?</span></button>
    </div>
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div id="debug-pane"></div>
  
  <div id="intro-overlay" class="hidden">
    <video id="intro-video" playsinline muted></video>
  </div>

  <script type="module">
    import { runProgram, getParsedOperations } from './runtime.ts';
    import { characterDefs, emeraldReady } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');
    const helpButton = document.getElementById('help-button');
    const downloadButton = document.getElementById('download-button');

    const introOverlay = document.getElementById('intro-overlay');
    const introVideo = document.getElementById('intro-video');

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    const INTRO_SEEN_KEY = 'qqqlang-intro-seen';
    const INTRO_DURATION_MS = 4000;
    const FADE_DURATION_MS = 1000;
    
    function shouldShowIntro() {
      const params = new URLSearchParams(window.location.search);
      if (params.has('show-intro')) return true;
      if (params.has('p')) return false;
      if (localStorage.getItem(INTRO_SEEN_KEY)) return false;
      return true;
    }
    
    function showIntro() {
      introOverlay.classList.remove('hidden');
      
      introVideo.src = 'intro.mp4';
      introVideo.loop = true;
      introVideo.play().catch(() => {});
      
      setTimeout(() => {
        introOverlay.classList.add('fading');
        
        setTimeout(() => {
          introOverlay.classList.add('hidden');
          introVideo.pause();
          introVideo.src = '';
          
          localStorage.setItem(INTRO_SEEN_KEY, 'true');
          
          const program = '???';
          input.value = program;
          updateURL(program);
          render();
          input.focus();
        }, FADE_DURATION_MS);
      }, INTRO_DURATION_MS);
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs;
    }
    
    function completeProgram(program) {
      if (!program) return program;
      const ops = getParsedOperations(program);
      if (ops.length === 0) return program;
      
      const lastOp = ops[ops.length - 1];
      if (lastOp.type === 'function') {
        const def = lastOp.fnDef;
        const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
        const currentOpChars = lastOp.identifier.substring(prevIdentifier.length);
        const argsProvided = currentOpChars.length - 1;
        const argsNeeded = def.arity - argsProvided;
        
        if (argsNeeded > 0) {
          const fnChar = currentOpChars[0];
          for (let i = 0; i < argsNeeded; i++) {
            program += fnChar;
          }
        }
      }
      return program;
    }
    
    helpButton.addEventListener('click', () => {
      let program = input.value;
      if (!program) {
        program = 'A';
      }
      program = completeProgram(program);
      program += '??';
      input.value = program;
      updateURL(program);
      render();
      input.focus();
    });
    
    downloadButton.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'qqqlang-' + (input.value || 'empty') + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    function getProgramFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('p') || '';
    }

    function updateURL(program) {
      const params = new URLSearchParams(window.location.search);
      if (program) {
        params.set('p', program);
      } else {
        params.delete('p');
      }
      const newSearch = params.toString();
      const newURL = window.location.pathname + (newSearch ? '?' + newSearch : '');
      if (window.location.pathname + window.location.search !== newURL) {
        window.history.pushState({ program }, '', newURL);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
      
      let html = '';
      let charIdx = 0;
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            html += `<span style="background-color: ${bgColor};">${chars[charIdx]}</span>`;
            charIdx++;
          }
        }
      }
      
      inputBackground.innerHTML = html;
    }

    function resize() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }

    function updateFaviconAndTitle(program) {
      let favicon = document.getElementById('dynamic-favicon');
      if (!favicon) {
        favicon = document.createElement('link');
        favicon.id = 'dynamic-favicon';
        favicon.rel = 'icon';
        favicon.type = 'image/png';
        document.head.appendChild(favicon);
      }
      
      if (program) {
        document.title = 'QQQLANG - ' + program;
        
        const size = Math.min(canvas.width, canvas.height);
        const x = Math.floor((canvas.width - size) / 2);
        const y = Math.floor((canvas.height - size) / 2);
        
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.drawImage(canvas, x, y, size, size, 0, 0, 32, 32);
        
        favicon.href = faviconCanvas.toDataURL('image/png');
      } else {
        document.title = 'QQQLANG';
        favicon.href = 'favicon-32.png';
      }
    }

    function render() {
      const program = input.value || '';
      const images = runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
      updateFaviconAndTitle(program);
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
    });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    // Wait for emerald model to load before first render
    emeraldReady.then(() => {
      if (shouldShowIntro()) {
        showIntro();
        resize();
      } else {
        loadProgramFromURL();
        resize();
      }
    });
  </script>
</body>
</html>
</eval-result-223027633229>}


---

# NEXT TASK

the glitch at `` ` `` is kind of dull compared to the other functions. come up with 10 alternatives for more interesting procedural glitch effects. do something with a fairly complex algorithm.

# THINKING

Signature: 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

The user wants me to come up with 10 alternative glitch effects for the backtick character. Let me think about interesting procedural glitch effects that would be visually compelling.

Current implementation just does horizontal strips with RGB separation. Let me think of more complex/interesting glitch effects:

1. **Databend/JPEG artifact simulation** - Simulate the look of corrupted JPEG compression by creating blocky artifacts, color bleeding, and quantization errors

2. **VHS tracking glitch** - Simulate VHS tape tracking issues with horizontal displacement that varies over time, color bleeding, and noise bands

3. **Digital signal corruption** - Simulate what happens when digital video signal gets corrupted - macroblocking, frame tearing, pixel sorting within blocks

4. **Pixel sorting glitch** - Sort pixels within horizontal bands by brightness/hue, creating those distinctive sorted streaks

5. **Bit-depth reduction with dithering artifacts** - Reduce color depth in specific regions creating banding and posterization with error diffusion artifacts

6. **Channel displacement with feedback** - More sophisticated RGB separation that includes rotation, scaling, and feedback loops

7. **Block shuffle/swap** - Divide image into blocks and swap/shuffle them based on some deterministic pattern, like a corrupted video codec

8. **Interlacing artifacts** - Simulate deinterlacing failures with combing, field blending issues

9. **Compression artifact simulation** - DCT block artifacts, mosquito noise around edges, color subsampling artifacts

10. **Memory corruption glitch** - Simulate what happens when image data in memory gets corrupted - wrong offsets, byte swaps, pointer errors

Let me write out 10 detailed proposals:

1. **Pixel sorting bands** - Sort pixels within horizontal bands by luminance or hue, creating distinctive sorted streaks. Different bands get sorted in different directions or by different criteria.

2. **Block displacement with DCT artifacts** - Divide into 8x8 blocks (like JPEG), displace some blocks, add quantization-like color banding within blocks, simulate mosquito noise at edges.
 
I'll simulate a VHS tracking effect with dynamic horizontal band shifts, introducing vertical instability and color smearing. The effect will create a nostalgic analog video breakdown, with random noise bursts interrupting the visual signal. Bands will slide unpredictably, mimicking tape tracking problems.

For databending, I'll treat the image as raw data, intentionally corrupting byte sequences. This will create unexpected color channel shifts, generating repeating patterns that simulate text editor manipulation. The effect will look like the image's digital structure has been deliberately disrupted.

I'll explore recursive feedback by sampling from offset positions, creating cascading echo trails across the image. This technique will generate complex, self-referential visual artifacts that evolve dynamically.

Bitplane corruption will involve manipulating individual color channel bit planes. By flipping bits and swapping bitplanes, I'll create a distinctive low-fidelity, crushed visual aesthetic that exposes the raw digital structure of the image.

Segment duplication and deletion will simulate video frame data loss. Some horizontal image strips will repeat, while others vanish entirely, generating stretching and compression artifacts that reveal the fragility of digital video encoding.

I'll corrupt color palettes by deliberately mismatching color indices, creating unexpected color cycling effects. This will transform the image's chromatic landscape through intentional palette manipulation.

Scan line phase shifting will introduce diagonal tearing and rainbow fringing by offsetting each scan line's phase. This technique will create a sense of digital instability and visual disintegration.

Memory pointer glitches will sample from incorrect memory addresses, displacing image chunks and generating repeated sections. The result will look like the image's data has been randomly scrambled, creating surreal visual dislocations.

# ASSISTANT

Here are 10 alternative glitch effect ideas for the backtick character, ranging from simple to complex:

---

## 1. **Pixel Sorting Bands**
Sort pixels within horizontal bands by luminance, hue, or saturation. Creates those distinctive "sorted streak" glitch aesthetics.
- Divide image into horizontal bands of varying heights
- Within each band, sort pixels along rows by brightness (or hue)
- Some bands sort left-to-right, others right-to-left
- Threshold: only sort pixels above/below certain brightness

---

## 2. **Block Displacement (DCT Corruption)**
Simulate JPEG/video codec corruption with displaced macroblocks.
- Divide image into 8x8 or 16x16 blocks
- Deterministically select blocks to displace (swap with neighbors or distant blocks)
- Add quantization banding within affected blocks
- Simulate "mosquito noise" at block edges with high-frequency artifacts

---

## 3. **VHS Tracking Simulation**
Classic analog video distortion with horizontal displacement and color bleeding.
- Horizontal bands shift left/right with sine-wave variation
- Color channels (especially chroma) blur/smear horizontally
- Occasional "noise burst" bands with random pixel values
- Vertical sync issues: duplicate or skip certain scanlines

---

## 4. **Bitplane Manipulation**
Corrupt individual bit planes of RGB channels for that distinctive digital corruption look.
- Extract 8 bit planes per channel
- Swap bitplanes between channels (R's bit 3 ↔ B's bit 5)
- Flip/invert certain bitplanes
- Shift bitplanes horizontally by different amounts
- Creates harsh color posterization with geometric patterns

---

## 5. **Recursive Feedback Echo**
Sample from offset positions with accumulated feedback, creating cascading trails.
- For each pixel, blend with pixel at offset position
- Offset direction rotates based on position
- Multiple feedback iterations create echo trails
- Intensity fades with each iteration
- Creates psychedelic trailing/smearing effects

---

## 6. **Segment Stretch/Delete**
Simulate data stream corruption where bytes are duplicated or missing.
- Divide into horizontal strips
- Some strips get "stretched" (repeated rows)
- Some strips get "compressed" (skipped rows)
- Creates vertical stretching/squishing artifacts
- Source row indices calculated with cumulative offset errors

---

## 7. **Scanline Phase Drift**
Each scanline has a phase offset that accumulates, creating diagonal tearing.
- Phase offset accumulates row by row
- Creates diagonal "tearing" lines across image
- RGB channels have different phase drift rates
- Creates rainbow fringing at tear boundaries
- Phase wraps creating repeating diagonal bands

---

## 8. **Memory Address Corruption**
Simulate reading image data from wrong memory addresses.
- Calculate "corrupted" source coordinates using bit manipulation
- XOR, bit rotation, or modular arithmetic on x/y coordinates
- Creates displaced chunks, repeated sections, mirrored fragments
- Some regions read from completely wrong locations
- Others have subtle coordinate errors

---

## 9. **Interlace Combing**
Simulate deinterlacing failures with field mixing artifacts.
- Separate odd/even scanlines as two "fields"
- Offset one field horizontally and/or temporally (sample from different image in history)
- Blend fields with combing artifacts at motion boundaries
- Create "feathered" edges where fields don't align
- Add field-rate flicker simulation

---

## 10. **Data Moshing (I-Frame Deletion)**
Simulate video compression artifacts when keyframes are corrupted.
- Divide into blocks, calculate "motion vectors" (based on gradient/color flow)
- Displace blocks according to motion vectors
- Blocks "slide" in direction of dominant gradient
- Edge pixels smear into gaps
- Creates fluid, melting appearance with hard block edges

---

**Which of these would you like me to implement?** I'd recommend **#4 (Bitplane Manipulation)** or **#10 (Data Moshing)** for the most visually striking and algorithmically interesting results. #1 (Pixel Sorting) is also a classic that always looks good.

# USER

no i meant something more algorithmic and deterministic based on the input image. the scanline phase drift is the closest. come up with five more ideas

# THINKING

Signature: Er0QCkYIChgCKkCRhkNkn6MY/HuhE/muNb/Xmd/WbkwXYpcX5dv+mAl3TY8Q0qNvG/P3yOlocpkiuvqHcZtPeTCdSsrZ6S2z0N5jEgzOZNfQh0wDObHndosaDJT4pMoCJy8lJxeNqSIwsiDvcF54y/pJjr4Dph1zicul+eqEuA6dLAf0QXtT+v6Wh0vSFKXjKrx1N05Iq/aVKqQPc4Ak3m21dgdVV/43oBLbXpZHOg/fMpGtY2JDt8hzLDN3OGb6z3/xSF2f934GwKasy62OEuZqoXVUqt/j5A3g6ZrGvqYuaY5MMLvgLDCD1DdCKBUh+vGy8u0A/vIzbe2VhkuL4AMS5nZU/hznwdWHi0DKguo+CSs4RtaiUlmu+tmZhEG+XLPWEpPNPkocVyKo3/9VWDNBKzclFMVCUjhQzD4ttLHACfVbUq4XupwnEsAJhjFFeBgjbnR04rt+RFTgwMP6/OUfPBUPB0KVJBJP5nwJtVmjV0ZErsjm8jOfu29mgC5+v13tfVgV9VkvoFmiux7A1QEbaVWPb6Fbxc643AFZb/U8IHbndVlVXEqkThH3U0g/j42sxYfEqaX0ElR3LS5rASTRx/yTBvY9GCu1XXP5+HPdMNx60xGuffSMQJfhCdjTIdX2NmrQw/Zi9H+dJOxbDly5VNpdvtw6+SNW5LifNXHmve7rUiNLBBXPBg7PYjqUlPlUoTiWVezx7CFEm2Pqy7Z+Yd5U4uGFXDpYq03uVJPUBUU6FDjtzZP1cRl6yKQpATg8D9SPR5SFMwRPRNMVrr5d6oeVW3Bq07Iig+nmaHsC9m5h3F5sEFuVn+5fDCDQ9YxZteQgYVLfzoMfMJTkM2dga4zv3NRiM7l2zlhHvM2xVV3GyvygxcB8EYAFftO7pICjlFuYJ80xQ/FWQQcXkwiNAczFZlr+A1ojPdK5Wd5VNIHvhyFujlowk9lr7fyu2m0aQhMjpxqy4XoKR1epwk+qvDrL94LXxADNnVAYQQ4XgVSdZzIl6eUYGspYM4Sa5W3b/0bYHc7ER6JFr2TuyYA0uqBOmKvgKKzR0eS1Jl7OX3GJdO0UIgflp/bjb5wiuzTxbNDtSOzDC/3/5aLEfnEY63JtFBAFf+7jqtbIuvKL++RTx3ZTT9Mq56HluqxQr7tpmJJvvcMwwOiB64PbJNNSJaSIFLGSEstXf5R3Ej0n9GtIb8W8i19fUlsIhLAd+EAXDKuMNkM1WHmh8BkGL+CFVxmCioWJyy62vz0V6rFz80L/hxXSfxGtM4/KJgNvWVMsNzSMikNNzChsiAuHzelGf1za09fCffTZmdQd9sV4iRsvkQBNJ88M1ts8ArKpQMhi/kWFBE8TRsI3U88ih6CicEMKOjyWo3lPR5iG/RoiOZNibFXEvnJWzkoe3WZYmO/N9/x0OtCdJOuHnYPbkYTSFoSbAsSJjdYEToujbBnwjBAp1xaXfsrqxz6jWC9lFd3o2mDTqDMHTIFC5jAwSDrm4bbyQ7w6LuSJ+wfS0ZViHxSXogG026D2Vl2StqbvTXjSr+MYcnCosW1lnWtCAezlh54FQRHqBpTZAoU3KFeFaFKwtz7v2/iI2p4ecaU+oNeDNunNxaCydbWBkGtuym21/szetL1w17VIHmSq9c9Ubia0v54A5StXRPNEC79uOBvciGQxhSZz8Qrea5IzS/9YBtadrJ27KGXC9dKiWbmo9zQvTTSpm58nk3/UUv9AInfIew5PsrzU4Jf41oov8D4ChrKc0guQyVdt9HfxVquRYn3nnnwG+QwdGlNVqwOqeCCl1kXNHjpsvqeYiPp220R+tzSkf5QxjnspSSpMr41Se1r3mcShHG9LZGxXKaPuRGTi8kIISeuamMdZ33VLHr8dmfPDJZjvqRyxbO6ymjNMspvo1CytA9YkUKsfBByisAinmm0OIWNatZl6mrYDMZ+WX+UrDy7NFO8nuVsdBhCRkn8ActDD7lDQg28j4KaGcoaPGIkJXBB4w8zU2B/tVT5eraz1Q/y/c4YGeUq8s4uiNJVggNIWma/P6zjs2FjNpxPIoi92cNF2UvRnij2Jc14FBqCxJ48joi5FBZyswzpSYdE/U2Ymt/neeVuN5LLM0MT1CxNMl4pEnwMHkzTK6RelSL/gIQcVdP+z4h1QGtAgPj/BvbGVt1ba8WkOF9jGChYKKt/zH1C/2SYMiSGi+y5gbJkwxfJ+3LMWxuZQ4XZhjG/cPLf+lyGrOW90n4x5VvFFWULGPCvaz9e6wKfvebQxoOfCAbVNgaEsgcd4i1WYodrNwNFX3p/jZmHLdoNGZoHFdtzg/PgAcXI6G2CMFLE3bg/9sAR7N7omH80SQ3/F9pkl3qSoKChvjYaB3OSIlLItrBNRhcuZ59iin9Z4M+uR7JSpnHmltTUlq74k0DQnhl/Gan1dNuRaECNi3PZLweceIhbyAin8rB3hsPZTmiDwwidw3oUW8Myf7ubBzwMTVBs3X6IGmYlhpmuHKzVqJHXAlyxBDUzidyajwncWm4t6BqILCU/91BNrfdXbFkwZO/BscrSjegpJ06eswpZmaUqHoLw6XrIEA6Yxem59wfItFb5srE51ZPshXhxrjs1UMao015L9GbsuJ4sYXmPiBug7bTQ7FNmCphnFoEUyx4wa717tkYuPlMt+swxtV+3Oa79jqZ+t0rZBilXWtGToHUQnHSPkahk+uTzQmNU57Ha+QNSc0DS8PRT3FtfEWmLKpaZPAMfwFVLJAOjBdepT4vX18wLnrzfKcRpUdfllBadqn6IaQp1763l9dvls+CcrqB2zMfge50/y/yBMw5GfGAE=

The user wants more algorithmic/deterministic glitch effects that are based on the input image content, not just random displacement. The scanline phase drift was closest because it creates structured patterns. Let me think of more content-aware, algorithmic glitch effects:

1. **Luminance-driven displacement** - Use the brightness of each pixel to determine how much to shift neighboring pixels. Bright areas push pixels away, dark areas pull them in.

2. **Edge-triggered corruption** - Detect edges in the image, and use edge locations as "corruption seeds" - pixels near edges get displaced, color-shifted, or duplicated based on edge direction/strength.

3. **Frequency-domain manipulation** - Do something in frequency space that creates visible artifacts - shift phases, amplify certain frequencies, create interference patterns.

4. **Gradient flow displacement** - Calculate image gradients and displace pixels along gradient directions, creating flow-field distortion.

5. **Color histogram remapping corruption** - Use the color distribution of the image to create a corrupted remapping - colors get shifted based on their frequency in the image.

6. **Recursive self-sampling** - Sample pixel colors and use them as coordinates to sample other pixels, creating feedback loops based on image content.

7. **Local variance-driven effects** - High variance (detailed) areas get one treatment, low variance (flat) areas get another.

8. **Bit-interleaving with image data** - Use pixel values from one region as bit masks or offsets for another region.

9. **Checksum-based corruption** - Calculate local "checksums" of pixel blocks and use mismatches to trigger corruption effects.

10. **Self-referential coordinate transform** - Use the R channel as X offset, G as Y offset, B as rotation - the image literally transforms itself based on its own content.

Let me pick 5 good ones that are algorithmic, deterministic, and content-aware:

# ASSISTANT

Here are 5 more algorithmic, deterministic, content-driven glitch effects:

---

## 1. **Self-Referential Coordinate Warp**
Use the image's own pixel values as displacement coordinates.
- For each pixel at (x,y), read its RGB values
- Use R as X offset, G as Y offset (scaled and centered around 128)
- Sample from the displaced position
- Creates feedback-like warping where bright red areas push right, bright green pushes down
- The distortion pattern is entirely determined by image content
- Iterate multiple times for more extreme warping

---

## 2. **Luminance Accumulator Drift**
Running sum of luminance values causes progressive horizontal drift.
- Maintain a running sum as you scan left-to-right
- Each pixel's luminance adds to the accumulator
- Accumulator (mod width) determines X offset for sampling
- Bright regions cause rapid drift, dark regions stabilize
- Creates content-aware horizontal tearing where bright areas "push" subsequent pixels
- Different rows drift independently based on their content

---

## 3. **Gradient Flow Smear**
Calculate image gradients and smear pixels along the gradient direction.
- Compute Sobel gradient (dx, dy) at each pixel
- Displace pixel position along gradient vector, scaled by gradient magnitude
- Strong edges cause large displacements perpendicular to the edge
- Flat areas remain stable
- Creates directional smearing that follows image structure
- Multiple iterations create motion-blur-like trails along edges

---

## 4. **Local Hash Corruption**
Use local pixel neighborhoods as hash inputs to determine corruption type.
- For each 4x4 block, compute a hash from its pixel values
- Hash determines: displacement amount, channel swap, bit flip pattern
- Blocks with similar content get similar corruption
- Creates structured, repeating artifacts in uniform areas
- Detailed areas get chaotic, unique corruption per block
- Entirely deterministic - same image always produces same glitch

---

## 5. **Entropy-Gated Channel Displacement**
Measure local entropy/complexity to control RGB separation intensity.
- Calculate local entropy in sliding window (histogram-based)
- High entropy (detailed) regions: large RGB channel separation
- Low entropy (flat) regions: minimal or no separation
- Separation direction follows local gradient
- Flat colored areas stay clean, busy areas explode into chromatic chaos
- Creates content-aware chromatic aberration that emphasizes texture

---

**My recommendation:** #2 (Luminance Accumulator Drift) is elegant and creates very distinctive, image-dependent tearing patterns. #1 (Self-Referential Warp) produces wild, unique results where the image literally reshapes itself. Both are simple to implement but produce complex, deterministic outputs.

# USER

yeah do the gradient flow smear on `` ` ``

# THINKING

Signature: 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

The user wants me to implement the "Gradient Flow Smear" effect for the backtick character. Let me look at the current implementation and replace it.

Current implementation:
```typescript
function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const glitchN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const shouldGlitch = (y * 17) % 23 < glitchN;
    const shiftAmount = shouldGlitch ? ((y * 31) % (glitchN * 20)) : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      if (shouldGlitch) {
        const srcXR = ((x - shiftAmount - glitchN) % ctx.width + ctx.width) % ctx.width;
        const srcXG = ((x - shiftAmount) % ctx.width + ctx.width) % ctx.width;
        const srcXB = ((x - shiftAmount + glitchN) % ctx.width + ctx.width) % ctx.width;
        
        const [rr] = getPixel(prev, srcXR, y);
        const [, gg] = getPixel(prev, srcXG, y);
        const [, , bb] = getPixel(prev, srcXB, y);
        
        setPixel(out, x, y, rr, gg, bb);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}
```

I'll design a gradient-based displacement algorithm that creates a fluid, motion-like smearing effect. The approach will involve computing edge gradients and using them to dynamically shift pixel positions, creating organic, directional distortions that follow image contours.

The implementation will leverage Sobel edge detection to generate displacement vectors, allowing pixels to flow along and perpendicular to detected edges. This technique will produce a more sophisticated visual transformation compared to the previous random shifting approach.

Key steps include converting the image to grayscale, calculating directional gradients, and then using those gradients to guide pixel movement across multiple iterations.

```typescript
function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const { width, height } = ctx;
  
  // Compute image gradients using precise Sobel convolution
  const gradX = new Float32Array(width * height);
  const gradY = new Float32Array(width * height);
  const gradMag = new Float32Array(width * height);
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  // Iterate through image pixels, calculating gradient vectors
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let gx = 0, gy = 0;
      
      // Apply Sobel kernel to neighborhood
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const [r, g, b] = getPixel(prev, x + kx, y + ky);
          const gray = r * 0.299 + g * 0.587 + b * 0.114;
          const kidx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kidx];
          gy += gray * sobelY[kidx];
        }
      }
      
      const idx = y * width + x;
      gradX[idx] = gx;
      gradY[idx] = gy;
      gradMag[idx] = Math.sqrt(gx * gx + gy * gy);
    }
  }
}
``` I'll compute gradients using the Sobel operator, systematically analyzing pixel neighborhoods to detect edge intensity and direction. By applying convolution kernels, I'll calculate horizontal and vertical gradient components for each pixel, tracking the maximum gradient magnitude to normalize later processing.

The nested loops will iterate through image pixels, strategically sampling surrounding pixel values. I'll carefully apply Sobel kernels to extract gradient information, determining how pixel intensities change across horizontal and vertical axes. This approach enables precise edge detection and gradient flow characterization.

For pixels with minimal gradient magnitude, I'll directly copy original pixel values. Where significant gradient exists, I'll prepare for a directional smearing effect, using the computed gradient information to guide subsequent image transformation.

The implementation ensures comprehensive pixel-level analysis, transforming the image by intelligently interpreting local intensity variations and directional gradients.

I'll normalize the gradient vector, calculate a proportional smearing distance based on magnitude, and strategically sample surrounding pixels. The sampling technique uses a weighted approach, emphasizing central pixel contributions while exploring the gradient's directional influence.

By sampling along the gradient with carefully calculated weights, I create a directional pixel blending that produces a subtle streak effect. The algorithm ensures smooth transitions by averaging pixel values proportionally to their distance from the center point.

The final pixel color emerges from a weighted interpolation, capturing the gradient's directional momentum while maintaining visual coherence across the image transformation. I'll continue the gradient computation, completing the partial thought about gradient calculation in the Sobel operator implementation. The code calculates horizontal and vertical image gradients by applying convolution kernels to grayscale pixel values, which helps detect edge directions and magnitudes.

The nested loops iterate through a 3x3 neighborhood around each pixel, converting RGB to grayscale and multiplying pixel intensities with Sobel kernel coefficients to compute horizontal and vertical gradient components. This technique allows precise edge detection and directional gradient estimation across the image.

After computing gradients, the code finds the maximum gradient magnitude to normalize edge intensities. It then performs an iterative smearing process, using gradient magnitudes to guide pixel blending and create a stylized edge-enhanced effect with controlled iterations and strength.

The implementation dynamically adjusts smearing parameters based on input complexity, ensuring adaptive edge processing across different image characteristics.

For each pixel, it calculates a displacement vector scaled by gradient magnitude, sampling source pixels from the gradient direction and blending them with the original pixel to create a smooth, directional smearing effect.

The algorithm progressively transforms the image by iteratively moving pixels along detected gradient flows, resulting in a dynamic visual distortion that emphasizes structural edges and directional movement.

By controlling iteration count and gradient scaling, the technique allows fine-tuned control over the smearing intensity and visual characteristics of the image transformation.

# TOOL USE

Name: str-replace
ID: toolu_017hvDEgYQZp1Es2T79TsCxg

## path

<tool.toolu_017hvDEgYQZp1Es2T79TsCxg>
character-defs.ts
</tool.toolu_017hvDEgYQZp1Es2T79TsCxg>

## original-content

<tool.toolu_017hvDEgYQZp1Es2T79TsCxg>
function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const glitchN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const shouldGlitch = (y * 17) % 23 < glitchN;
    const shiftAmount = shouldGlitch ? ((y * 31) % (glitchN * 20)) : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      if (shouldGlitch) {
        const srcXR = ((x - shiftAmount - glitchN) % ctx.width + ctx.width) % ctx.width;
        const srcXG = ((x - shiftAmount) % ctx.width + ctx.width) % ctx.width;
        const srcXB = ((x - shiftAmount + glitchN) % ctx.width + ctx.width) % ctx.width;
        
        const [rr] = getPixel(prev, srcXR, y);
        const [, gg] = getPixel(prev, srcXG, y);
        const [, , bb] = getPixel(prev, srcXB, y);
        
        setPixel(out, x, y, rr, gg, bb);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}
</tool.toolu_017hvDEgYQZp1Es2T79TsCxg>

## new-content

<tool.toolu_017hvDEgYQZp1Es2T79TsCxg>
function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const { width, height } = ctx;
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  const gradX = new Float32Array(width * height);
  const gradY = new Float32Array(width * height);
  const gradMag = new Float32Array(width * height);
  
  let maxMag = 1;
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const [r, g, b] = getPixel(prev, x + kx, y + ky);
          const gray = r * 0.299 + g * 0.587 + b * 0.114;
          const kidx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kidx];
          gy += gray * sobelY[kidx];
        }
      }
      
      const idx = y * width + x;
      gradX[idx] = gx;
      gradY[idx] = gy;
      const mag = Math.sqrt(gx * gx + gy * gy);
      gradMag[idx] = mag;
      if (mag > maxMag) maxMag = mag;
    }
  }
  
  const iterations = Math.max(2, Math.min(n + 3, 20));
  const baseStrength = 2.0 + n * 0.8;
  const threshold = 12;
  
  let current = cloneImage(prev);
  
  for (let iter = 0; iter < iterations; iter++) {
    const next = createSolidImage(width, height, '#000000');
    const iterDecay = 1 - (iter / iterations) * 0.4;
    const iterStrength = baseStrength * iterDecay;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        const mag = gradMag[idx];
        
        if (mag < threshold) {
          const [r, g, b] = getPixel(current, x, y);
          setPixel(next, x, y, r, g, b);
          continue;
        }
        
        const normMag = mag / maxMag;
        const scale = normMag * iterStrength;
        const dx = (gradX[idx] / mag) * scale;
        const dy = (gradY[idx] / mag) * scale;
        
        const srcX = x - dx;
        const srcY = y - dy;
        
        const [r1, g1, b1] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
        const [r2, g2, b2] = getPixel(current, x, y);
        
        const blend = Math.min(0.9, normMag * 0.7 + 0.2);
        setPixel(next, x, y,
          Math.round(r1 * blend + r2 * (1 - blend)),
          Math.round(g1 * blend + g2 * (1 - blend)),
          Math.round(b1 * blend + b2 * (1 - blend))
        );
      }
    }
    
    current = next;
  }
  
  return current;
}
</tool.toolu_017hvDEgYQZp1Es2T79TsCxg>

## git-commit-message

<tool.toolu_017hvDEgYQZp1Es2T79TsCxg>
Replace backtick glitch with gradient flow smear effect
</tool.toolu_017hvDEgYQZp1Es2T79TsCxg>

# TOOL RESULT

ID: toolu_017hvDEgYQZp1Es2T79TsCxg

<tool.toolu_017hvDEgYQZp1Es2T79TsCxg>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Replace backtick glitch with gradient flow smear effect
</tool.toolu_017hvDEgYQZp1Es2T79TsCxg>

# ASSISTANT

Now let me update the documentation for this character:

# TOOL USE

Name: str-replace
ID: toolu_01K8ojdvUa1RVhJBNzrRZjXU

## path

<tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>
character-defs.ts
</tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>

## diff

<tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>
   '`': {
     color: '#6495ED',
     number: 64,
     fn: fnBacktick,
     arity: 1,
     argTypes: ['int'],
-    functionName: "glitch",
-    documentation: "Glitch effect: horizontal strips shifted right with RGB separation of n pixels"
+    functionName: "gradient-smear",
+    documentation: "Iteratively smears pixels along image gradients; edges create directional streaks, n controls iterations and strength"
   },
\ No newline at end of file

</tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>

## git-commit-message

<tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>
Update backtick documentation for gradient-smear effect
</tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>

# TOOL RESULT

ID: toolu_01K8ojdvUa1RVhJBNzrRZjXU

<tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update backtick documentation for gradient-smear effect
</tool.toolu_01K8ojdvUa1RVhJBNzrRZjXU>

# ASSISTANT

Done! The new **gradient-smear** effect:

1. **Computes Sobel gradients** from the original image to find edge directions and magnitudes
2. **Iteratively displaces pixels** along their gradient direction - pixels flow from high-gradient areas toward low-gradient areas
3. **Blends displaced samples** with original pixels, weighted by gradient magnitude
4. **Iteration decay** - each iteration has slightly less strength to prevent over-smearing
5. **Threshold filtering** - flat areas (gradient < 12) remain untouched

The `n` parameter controls:
- Number of iterations (n+3, capped at 20)
- Base displacement strength (2.0 + n*0.8)

The effect creates directional streaking at edges - strong edges get pulled/smeared along their gradient direction, while flat areas stay stable. Multiple iterations compound the effect, creating elongated trails that follow image structure.

# USER

make the effect a lot more pronounced

# THINKING

Signature: Es4DCkYIChgCKkBF/5n51wqPvAYflDw8O/2fEeb9nlor+WZ84v1xGiVHuO+0DQskdD3VSpa0s1o3YT56KnBbP63T6Ga0nMMvHV3jEgyPeoJ15FtdJcTsukEaDCXY+qBVrJyTtrWvVyIw3mMYw3jCowbdEmM6KaF4TgrATwd2bkLng1q6OJbwhKx5ZosOn7PBZAaO/zhQ8TQYKrUCfA9kcbQNSkX+kJz9kRRPVLX3oVRW4HyPD71pXhu0wb2yGIgW4eCP1JdfP/W0ULmCSHsTmDjzCg9CMX9Em2sU59S7xGVEcZA4A3UuF4GuzSV2WWw3CZoiUHJbflLt5LIZAtgKK7XlBSZNEA2E9frPWjqs1wmm/kTBrqJAp2inx5MStvDVb+q9FM5vNBxYROCmEwecPB9YpMaEs4iX9nG2UM7Obo48/4MsURZLckY5tiFg7t5cGlFJ8E2CdcdAISr9kvugyqitc3wmfeE3mCqz/Ymdr7sra7xxnumMi9oHj7Lw3jhKB8ryK1oBbnpGeD9HCzBj3xXN0m0bmTdEFaGgBAGk92FPrZFhW78V0kYQbk/FKqY3yxHsmogJ0bLcPI0odu9/b24F2V1JroLE7tmg+DHPZkH9GAE=

The user wants the gradient smear effect to be more pronounced/extreme. I should increase:
1. The base strength
2. The number of iterations
3. Maybe lower the threshold so more pixels are affected
4. Increase the blend factor so displaced pixels dominate more

Let me make it much more aggressive.

# TOOL USE

Name: str-replace
ID: toolu_01A93Q4hiH4JZK5EPjo5rc1K

## path

<tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>
character-defs.ts
</tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>

## diff

<tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>
 function fnBacktick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const { width, height } = ctx;
   
   const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
   const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
   
   const gradX = new Float32Array(width * height);
   const gradY = new Float32Array(width * height);
   const gradMag = new Float32Array(width * height);
   
   let maxMag = 1;
   
   for (let y = 1; y < height - 1; y++) {
     for (let x = 1; x < width - 1; x++) {
       let gx = 0, gy = 0;
       
       for (let ky = -1; ky <= 1; ky++) {
         for (let kx = -1; kx <= 1; kx++) {
           const [r, g, b] = getPixel(prev, x + kx, y + ky);
           const gray = r * 0.299 + g * 0.587 + b * 0.114;
           const kidx = (ky + 1) * 3 + (kx + 1);
           gx += gray * sobelX[kidx];
           gy += gray * sobelY[kidx];
         }
       }
       
       const idx = y * width + x;
       gradX[idx] = gx;
       gradY[idx] = gy;
       const mag = Math.sqrt(gx * gx + gy * gy);
       gradMag[idx] = mag;
       if (mag > maxMag) maxMag = mag;
     }
   }
   
-  const iterations = Math.max(2, Math.min(n + 3, 20));
-  const baseStrength = 2.0 + n * 0.8;
-  const threshold = 12;
+  const iterations = Math.max(8, Math.min(n * 4 + 12, 50));
+  const baseStrength = 6.0 + n * 2.5;
+  const threshold = 5;
   
   let current = cloneImage(prev);
   
   for (let iter = 0; iter < iterations; iter++) {
     const next = createSolidImage(width, height, '#000000');
-    const iterDecay = 1 - (iter / iterations) * 0.4;
+    const iterDecay = 1 - (iter / iterations) * 0.3;
     const iterStrength = baseStrength * iterDecay;
     
     for (let y = 0; y < height; y++) {
       for (let x = 0; x < width; x++) {
         const idx = y * width + x;
         const mag = gradMag[idx];
         
         if (mag < threshold) {
           const [r, g, b] = getPixel(current, x, y);
           setPixel(next, x, y, r, g, b);
           continue;
         }
         
         const normMag = mag / maxMag;
         const scale = normMag * iterStrength;
         const dx = (gradX[idx] / mag) * scale;
         const dy = (gradY[idx] / mag) * scale;
         
         const srcX = x - dx;
         const srcY = y - dy;
         
-        const [r1, g1, b1] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
-        const [r2, g2, b2] = getPixel(current, x, y);
-        
-        const blend = Math.min(0.9, normMag * 0.7 + 0.2);
-        setPixel(next, x, y,
-          Math.round(r1 * blend + r2 * (1 - blend)),
-          Math.round(g1 * blend + g2 * (1 - blend)),
-          Math.round(b1 * blend + b2 * (1 - blend))
-        );
+        const [r, g, b] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
+        setPixel(next, x, y, r, g, b);
       }
     }
     
     current = next;
   }
   
   return current;
 }
\ No newline at end of file

</tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>

## git-commit-message

<tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>
Make gradient-smear effect much more pronounced
</tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>

# TOOL RESULT

ID: toolu_01A93Q4hiH4JZK5EPjo5rc1K

<tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Make gradient-smear effect much more pronounced
</tool.toolu_01A93Q4hiH4JZK5EPjo5rc1K>

# ASSISTANT

Changes made:

1. **More iterations**: `n*4 + 12` (was `n + 3`), up to 50 (was 20)
2. **Much stronger displacement**: `6.0 + n*2.5` (was `2.0 + n*0.8`)
3. **Lower threshold**: 5 (was 12) - more pixels get smeared
4. **No blending**: Displaced pixels now fully replace originals instead of blending, creating harder streaks
5. **Less decay per iteration**: 0.3 (was 0.4) - maintains strength longer through iterations

The effect should now create much more dramatic directional streaking, with edges pulling pixels into long visible trails.

# USER

that's too much, do something in between

# THINKING

Signature: EvMECkYIChgCKkAO62T1KCZjvypUvwrdVIC5YAPAGp0nxrdVuWSiUbYZZ5X+ds0HuZ0i4IOSoA+wKqP87Hg7eIF2P3oYk1VDbDZrEgzvPOBB9CiffwjOERkaDCJT4OfFtVSQcCf72SIwWdRIZm/QbGpIWRy4i82TWbnzDZIB1XHwyvLNdeFiwQi+/8h9V9nVUAkAgrOT/AvkKtoDq0LnlnrLdR1VQXT5Rg+6LVOrnCmgUuwJaN/XOkTb4lJJl0yNLAc1Tr6SgajCRCgzjG6aigP9rIhX2EgnKBOSrI99X2bA+bfqnT5FHpTSP+98/W0bWGKCePdxqQ+8u3lAgb1qcqH7M9IioH2E6qhiuxZuh9ak+4mU7dTbckSFalBNmqFyaCOywvMeXucFHXclM9IFStSW7jhj4VmLd91BbWsDxVik1nyk6Uk+bbtpOnks08a0s4aVYOSRaQeLN1o4I2qKwYDU5epukRPxTXvNYGMNGFkrHSQoMnWMDEEdcZ0vEFIVLc36G5UJncTtuN00R7dQWA2uxn9i4KD1Lxjdu8GI3GBoEhEHMvfqsdD3Dgnso+1Hm2ZLwLIYIvzZY/A2lOpwhgSRLlBKvPo+vDMWWKHNOkElmmyoVyWJF1OhYg1rTjxo2ep42+4hDPZK2LrbC1kNoBwnu38Ic1o72IDB0vJGPGxWJAp8yitZ3FFDuzdivz4st+0MGS2XoF7A6JlA9SP46TVShTEBbO583Z4lqgr+rNJ8d8CecipkquvXFi47I4CZ4FhMRJriDUGDRBZworV0N6dfYzsAn9/gBbRD6ybwy8fncGDoMbzWX8zSojgZ+yclkTdd+/ddGAE=

The user wants something between the original subtle version and the overly aggressive version. Let me find a middle ground:

Original:
- iterations: n + 3, max 20
- baseStrength: 2.0 + n * 0.8
- threshold: 12
- blend: yes (0.7-0.9)

Too much:
- iterations: n * 4 + 12, max 50
- baseStrength: 6.0 + n * 2.5
- threshold: 5
- blend: no

Middle ground:
- iterations: n * 2 + 6, max 30
- baseStrength: 4.0 + n * 1.5
- threshold: 8
- blend: partial (higher blend factor)

# TOOL USE

Name: str-replace
ID: toolu_01FALZ2cRBaSgM4TgUefWs8D

## path

<tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>
character-defs.ts
</tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>

## git-commit-message

<tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>
Tune gradient-smear to balanced intensity
</tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>

## diff

<tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>
 function fnBacktick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const { width, height } = ctx;
   
   const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
   const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
   
   const gradX = new Float32Array(width * height);
   const gradY = new Float32Array(width * height);
   const gradMag = new Float32Array(width * height);
   
   let maxMag = 1;
   
   for (let y = 1; y < height - 1; y++) {
     for (let x = 1; x < width - 1; x++) {
       let gx = 0, gy = 0;
       
       for (let ky = -1; ky <= 1; ky++) {
         for (let kx = -1; kx <= 1; kx++) {
           const [r, g, b] = getPixel(prev, x + kx, y + ky);
           const gray = r * 0.299 + g * 0.587 + b * 0.114;
           const kidx = (ky + 1) * 3 + (kx + 1);
           gx += gray * sobelX[kidx];
           gy += gray * sobelY[kidx];
         }
       }
       
       const idx = y * width + x;
       gradX[idx] = gx;
       gradY[idx] = gy;
       const mag = Math.sqrt(gx * gx + gy * gy);
       gradMag[idx] = mag;
       if (mag > maxMag) maxMag = mag;
     }
   }
   
-  const iterations = Math.max(8, Math.min(n * 4 + 12, 50));
-  const baseStrength = 6.0 + n * 2.5;
-  const threshold = 5;
+  const iterations = Math.max(5, Math.min(n * 2 + 8, 30));
+  const baseStrength = 4.0 + n * 1.5;
+  const threshold = 8;
   
   let current = cloneImage(prev);
   
   for (let iter = 0; iter < iterations; iter++) {
     const next = createSolidImage(width, height, '#000000');
-    const iterDecay = 1 - (iter / iterations) * 0.3;
+    const iterDecay = 1 - (iter / iterations) * 0.35;
     const iterStrength = baseStrength * iterDecay;
     
     for (let y = 0; y < height; y++) {
       for (let x = 0; x < width; x++) {
         const idx = y * width + x;
         const mag = gradMag[idx];
         
         if (mag < threshold) {
           const [r, g, b] = getPixel(current, x, y);
           setPixel(next, x, y, r, g, b);
           continue;
         }
         
         const normMag = mag / maxMag;
         const scale = normMag * iterStrength;
         const dx = (gradX[idx] / mag) * scale;
         const dy = (gradY[idx] / mag) * scale;
         
         const srcX = x - dx;
         const srcY = y - dy;
         
-        const [r, g, b] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
-        setPixel(next, x, y, r, g, b);
+        const [r1, g1, b1] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
+        const [r2, g2, b2] = getPixel(current, x, y);
+        
+        const blend = Math.min(0.95, normMag * 0.6 + 0.35);
+        setPixel(next, x, y,
+          Math.round(r1 * blend + r2 * (1 - blend)),
+          Math.round(g1 * blend + g2 * (1 - blend)),
+          Math.round(b1 * blend + b2 * (1 - blend))
+        );
       }
     }
     
     current = next;
   }
   
   return current;
 }
\ No newline at end of file

</tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>

# TOOL RESULT

ID: toolu_01FALZ2cRBaSgM4TgUefWs8D

<tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Tune gradient-smear to balanced intensity
</tool.toolu_01FALZ2cRBaSgM4TgUefWs8D>

# ASSISTANT

Balanced settings now:

| Parameter | Original | Too Much | Now |
|-----------|----------|----------|-----|
| Iterations | n+3, max 20 | n*4+12, max 50 | **n*2+8, max 30** |
| Strength | 2.0 + n*0.8 | 6.0 + n*2.5 | **4.0 + n*1.5** |
| Threshold | 12 | 5 | **8** |
| Blend | 0.7-0.9 | none (1.0) | **0.35-0.95** |

This should give noticeable directional streaking at edges without completely obliterating the image.

# USER

for the |, do a much larger blend (e.g. 20% of the image) but make the blend more interesting with pixel arithmetic than just a plain interoplation

# THINKING

Signature: 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

The user wants to modify the pipe `|` function (fnPipe) to have a larger blend region (20% of the image width) and use more interesting pixel arithmetic instead of simple linear interpolation.

Let me look at the current implementation:

```typescript
function fnPipe(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const midX = Math.floor(ctx.width / 2);
  const blendWidth = 5;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX - blendWidth) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (x > midX + blendWidth) {
        const [r, g, b] = getPixel(old, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const t = (x - (midX - blendWidth)) / (blendWidth * 2);
        const [pr, pg, pb] = getPixel(prev, x, y);
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y,
          Math.round(pr * (1 - t) + or * t),
          Math.round(pg * (1 - t) + og * t),
          Math.round(pb * (1 - t) + ob * t)
        );
      }
    }
  }
  
  return out;
}
```

I'll explore advanced blending techniques that introduce more visual complexity. The blend region could use non-linear transformations like screen or overlay modes, which create more dynamic interactions between pixel values. Channel swapping during the blend could produce unexpected and intriguing visual effects, breaking the predictable linear interpolation. Implementing techniques like XOR or difference blending might generate fascinating transitional artifacts across the image's midpoint.

By varying blend modes across horizontal bands or dynamically selecting operations based on pixel luminance, I can create a more organic, responsive blending process. The goal is to move beyond simple linear interpolation and craft a blend that feels alive and reactive to the image's inherent characteristics.

I'll implement a nuanced blending strategy with a centered transition zone. The approach involves dynamically selecting blend modes that respond to pixel values, creating visual complexity. By mapping different arithmetic operations across the blend region - from additive near one side to subtractive in the middle and multiplicative near the other - I can generate unexpected and intriguing visual transformations.

The implementation involves carefully calculating a transition factor, then applying sophisticated blending logic that considers pixel position and content. This allows for a more intelligent, context-aware image merging technique that goes beyond traditional linear blending methods.

The core innovation involves using screen, difference, and multiply blend modes strategically, with horizontal variation introduced through a row-based modulation factor. This creates subtle textural shifts across the transition zone.

I calculate localized transition points within each blend segment, smoothly interpolating between color channels. The approach allows for nuanced, non-linear color transformations that feel organic and dynamic.

By segmenting the transition into thirds and applying different blend techniques, I generate visually interesting color progressions that aren't simply linear fades. The row factor adds an extra dimension of visual complexity.

I round the final color values and set each pixel, ensuring precise color mapping while maintaining the wave-like transition characteristics. The method creates a fluid, almost organic visual transformation between different image states.

The implementation suggests potential for more experimental blending techniques, potentially incorporating wave patterns, bitwise operations, or more complex interpolation strategies to generate unique visual effects.

# TOOL USE

Name: str-replace
ID: toolu_01DYBRjQxMAqtmsXjmmj1tVG

## path

<tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>
character-defs.ts
</tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>

## git-commit-message

<tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>
Make pipe blend zone 20% width with interesting pixel arithmetic
</tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>

## diff

<tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>
 function fnPipe(ctx: FnContext, j: number): Image {
   const prev = getPrevImage(ctx);
   const old = getOldImage(ctx, j);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const midX = Math.floor(ctx.width / 2);
-  const blendWidth = 5;
+  const blendWidth = Math.floor(ctx.width * 0.1);
   
   for (let y = 0; y < ctx.height; y++) {
+    const waveOffset = Math.sin(y * 0.05) * 15;
+    const effectiveMidX = midX + waveOffset;
+    
     for (let x = 0; x < ctx.width; x++) {
-      if (x < midX - blendWidth) {
-        const [r, g, b] = getPixel(prev, x, y);
-        setPixel(out, x, y, r, g, b);
-      } else if (x > midX + blendWidth) {
-        const [r, g, b] = getPixel(old, x, y);
-        setPixel(out, x, y, r, g, b);
+      const [pr, pg, pb] = getPixel(prev, x, y);
+      const [or, og, ob] = getPixel(old, x, y);
+      
+      if (x < effectiveMidX - blendWidth) {
+        setPixel(out, x, y, pr, pg, pb);
+      } else if (x > effectiveMidX + blendWidth) {
+        setPixel(out, x, y, or, og, ob);
       } else {
-        const t = (x - (midX - blendWidth)) / (blendWidth * 2);
-        const [pr, pg, pb] = getPixel(prev, x, y);
-        const [or, og, ob] = getPixel(old, x, y);
-        setPixel(out, x, y,
-          Math.round(pr * (1 - t) + or * t),
-          Math.round(pg * (1 - t) + og * t),
-          Math.round(pb * (1 - t) + ob * t)
-        );
+        const t = (x - (effectiveMidX - blendWidth)) / (blendWidth * 2);
+        
+        const screenR = 255 - ((255 - pr) * (255 - or)) / 255;
+        const screenG = 255 - ((255 - pg) * (255 - og)) / 255;
+        const screenB = 255 - ((255 - pb) * (255 - ob)) / 255;
+        
+        const diffR = Math.abs(pr - or);
+        const diffG = Math.abs(pg - og);
+        const diffB = Math.abs(pb - ob);
+        
+        const xorR = pr ^ or;
+        const xorG = pg ^ og;
+        const xorB = pb ^ ob;
+        
+        const band = Math.floor(y / 20) % 3;
+        
+        let r: number, g: number, b: number;
+        
+        if (band === 0) {
+          if (t < 0.5) {
+            const localT = t * 2;
+            r = pr * (1 - localT) + screenR * localT;
+            g = pg * (1 - localT) + screenG * localT;
+            b = pb * (1 - localT) + screenB * localT;
+          } else {
+            const localT = (t - 0.5) * 2;
+            r = screenR * (1 - localT) + or * localT;
+            g = screenG * (1 - localT) + og * localT;
+            b = screenB * (1 - localT) + ob * localT;
+          }
+        } else if (band === 1) {
+          const centerDist = Math.abs(t - 0.5) * 2;
+          const diffWeight = 1 - centerDist;
+          r = (pr * (1 - t) + or * t) * (1 - diffWeight) + diffR * diffWeight;
+          g = (pg * (1 - t) + og * t) * (1 - diffWeight) + diffG * diffWeight;
+          b = (pb * (1 - t) + ob * t) * (1 - diffWeight) + diffB * diffWeight;
+        } else {
+          const xorWeight = Math.sin(t * Math.PI) * 0.7;
+          const baseR = pr * (1 - t) + or * t;
+          const baseG = pg * (1 - t) + og * t;
+          const baseB = pb * (1 - t) + ob * t;
+          r = baseR * (1 - xorWeight) + xorR * xorWeight;
+          g = baseG * (1 - xorWeight) + xorG * xorWeight;
+          b = baseB * (1 - xorWeight) + xorB * xorWeight;
+        }
+        
+        setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
       }
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>

# TOOL RESULT

ID: toolu_01DYBRjQxMAqtmsXjmmj1tVG

<tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Make pipe blend zone 20% width with interesting pixel arithmetic
</tool.toolu_01DYBRjQxMAqtmsXjmmj1tVG>

# ASSISTANT

Now update the documentation:

# TOOL USE

Name: str-replace
ID: toolu_01SgFeE1B91nk3GvKnPU5Ei9

## path

<tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>
character-defs.ts
</tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>

## git-commit-message

<tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>
Update pipe documentation
</tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>

## diff

<tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>
   '|': {
     color: '#00BFFF',
     number: 66,
     fn: fnPipe,
     arity: 1,
     argTypes: ['int'],
     functionName: "vertical-split",
-    documentation: "Left half is prev, right half is old_image, center column is 10px blend"
+    documentation: "Left=prev, right=old image j; 20% wavy blend zone uses screen/difference/xor in alternating horizontal bands"
   },
\ No newline at end of file

</tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>

# TOOL RESULT

ID: toolu_01SgFeE1B91nk3GvKnPU5Ei9

<tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update pipe documentation
</tool.toolu_01SgFeE1B91nk3GvKnPU5Ei9>

# ASSISTANT

Done! The new pipe `|` blend:

1. **20% blend zone** (10% on each side of center)
2. **Wavy edge** - sine wave distorts the center line vertically
3. **Three blend modes in horizontal bands** (every 20 rows):
   - **Band 0 (Screen)**: prev → screen blend → old (brightening blend good for highlights)
   - **Band 1 (Difference)**: linear blend with difference peaking at center (creates edge-highlighting effect)
   - **Band 2 (XOR)**: linear blend with XOR weighted by sine curve (digital glitch aesthetic)

The combination creates a visually interesting seam with varied textures rather than a plain gradient.

# USER

replace % with a plain vertical or horizontal flip based on the %2 of the argument

# THINKING

Signature: Eo0DCkYIChgCKkBPZheakfx+NS84E4Mhkw+5e67F4pfA7CbC94TTL/tstIjErvONkX3nAHBPhPl0ht4c2xot+iM2Ejj1Jr3Luvp1EgwZwmzXjvTZsCwNzj0aDJ5bHgx8m17pW04o6yIwS+gLX+jCHx7I8xyfr5pUxZ5sDq337AWiuDIuWRkbbUQWgiYbdBkvy5lgAmR3I7kgKvQBqXIzd7QZ4UXHVn2n0QwxbE6dCfGMS0Lg+G5Zu1jw+uEIO1yRScSTvaza/80HTtJ9RWANBmYlEV9pb+aoKmrlvNLH7w0miPKBEbDqneUXUEH9/r06KE1YRaED8/6zZnWuKhLL0md/feOJXpaeNiCGrdn37R6AMvkDKd8OSn7hWpcZDpltsNNHY0tUNFsA6d85VDATSuSbxxj2/3lERiyGPWtHTm/Kzl3oKO6rO4XxvCsum5DPSlLpl6rabEIlAhBiK2Goc++bheEU0Gu+5wccBKa6C1chy8E0t11/KOJggLgpCWnLqv3HErHXbH2TdaxFEqkYbBgB

The user wants to replace the current `%` function (Floyd-Steinberg dithering) with a simple vertical or horizontal flip based on whether the argument is even or odd (n % 2).

Let me find the current implementation and replace it.

# TOOL USE

Name: str-replace
ID: toolu_01Nz5eBs9JeoQwhjYv3fHBYf

## path

<tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>
character-defs.ts
</tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>

## git-commit-message

<tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>
Replace % with simple vertical/horizontal flip based on arg parity
</tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>

## diff

<tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>
 function fnPercent(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const cellSize = Math.max(1, n + 1);
-  const corners = [
-    getPixel(prev, 0, 0),
-    getPixel(prev, ctx.width - 1, 0),
-    getPixel(prev, 0, ctx.height - 1),
-    getPixel(prev, ctx.width - 1, ctx.height - 1)
-  ];
-  const palette = corners.map(([r, g, b]) => [r, g, b] as [number, number, number]);
+  const horizontal = n % 2 === 0;
   
-  const findClosest = (r: number, g: number, b: number): [number, number, number] => {
-    let minDist = Infinity;
-    let closest = palette[0];
-    for (const [pr, pg, pb] of palette) {
-      const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
-      if (dist < minDist) {
-        minDist = dist;
-        closest = [pr, pg, pb];
-      }
-    }
-    return closest;
-  };
-  
-  const tempData = new Float32Array(ctx.width * ctx.height * 3);
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
-      const [r, g, b] = getPixel(prev, x, y);
-      const idx = (y * ctx.width + x) * 3;
-      tempData[idx] = r;
-      tempData[idx + 1] = g;
-      tempData[idx + 2] = b;
+      const srcX = horizontal ? ctx.width - 1 - x : x;
+      const srcY = horizontal ? y : ctx.height - 1 - y;
+      const [r, g, b] = getPixel(prev, srcX, srcY);
+      setPixel(out, x, y, r, g, b);
     }
   }
   
-  for (let y = 0; y < ctx.height; y += cellSize) {
-    for (let x = 0; x < ctx.width; x += cellSize) {
-      const idx = (y * ctx.width + x) * 3;
-      const oldR = tempData[idx];
-      const oldG = tempData[idx + 1];
-      const oldB = tempData[idx + 2];
-      
-      const [newR, newG, newB] = findClosest(oldR, oldG, oldB);
-      
-      for (let cy = 0; cy < cellSize && y + cy < ctx.height; cy++) {
-        for (let cx = 0; cx < cellSize && x + cx < ctx.width; cx++) {
-          setPixel(out, x + cx, y + cy, newR, newG, newB);
-        }
-      }
-      
-      const errR = oldR - newR;
-      const errG = oldG - newG;
-      const errB = oldB - newB;
-      
-      const distribute = (dx: number, dy: number, factor: number) => {
-        const nx = x + dx * cellSize;
-        const ny = y + dy * cellSize;
-        if (nx >= 0 && nx < ctx.width && ny >= 0 && ny < ctx.height) {
-          const nidx = (ny * ctx.width + nx) * 3;
-          tempData[nidx] += errR * factor;
-          tempData[nidx + 1] += errG * factor;
-          tempData[nidx + 2] += errB * factor;
-        }
-      };
-      
-      distribute(1, 0, 7 / 16);
-      distribute(-1, 1, 3 / 16);
-      distribute(0, 1, 5 / 16);
-      distribute(1, 1, 1 / 16);
-    }
-  }
-  
   return out;
 }
\ No newline at end of file

</tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>

# TOOL RESULT

ID: toolu_01Nz5eBs9JeoQwhjYv3fHBYf

<tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>

</tool.toolu_01Nz5eBs9JeoQwhjYv3fHBYf>

# SYSTEM

You are Greger, and expert coding agent.

${greger-prompt-code-style<eval-result-142104709123>
# Code style

## Don't be overly defensive

I don't trust the code you write, so I want you to fail early and loudly.

**Don't** add fallbacks, guards, or try/catch blocks against errors unless I specifically ask you to. I don't trust the code you write so I'd rather fail hard early and detect your errors than softly receive a fallback and not detect your errors.

## Imports go at the top

Don't sprinkle the code with imports unless in very special circumstances or if I explicltly ask you to.

## No unnecessary comments

You have a tendency to comment every line. I'm an expert programmer and I prefer reading code to prose. Most of the time I can read the code faster than the comment to understand what's going on. Only add comments in cases where the code is unintuitive or particularly hard to follow (e.g. custom parsers).

## Read full files

Important: The first time you read a source code file, read the _entire_ file (_not_ piecemeal with start-line and end-line) so you get a real holistic understanding of the logic.

## IMPORTANT: NO SUMMARY DOCUMENTS!!!

IMPORTANT: DON'T write summary documents (e.g. SUMMARY.md, FINAL_REPORT.md) unless the user explicitly asks you to. If you feel the need to explain something, just do it in the chat. The ONLY exception to this rule is if the user explicitly asks you to write up a markdown file on disk.
</eval-result-142104709123>}

# USER

I want to create an esoteric programming language for generating images, where _every_ combination of uppercase ascii characters (excluding "invisible characters" like space, return) create an image.

Every character have an associated color, integer, and function.

Some functions have arity 0, some are unary, some are binary (some are maybe ternary?). Arguments to functions may be colors or integers. When arity > 0, the default argument are defined in the function, and color values usually default to the color of the character. Each function outputs a 2D RGB image.

A program is a list of characters that outputs a list of images (where the number of images <= number of characters, since some characters may be function arguments)

Functions have access to the entire history of output images up to the point in the program where they're defined. By convention, each function does some transformation on the previous image.

The first character is always used by its color, creating a single color image. Subsequent characters are parsed until the end of the program string. The default arguments are only used if the last function in the program string is missing inputs.

Note that

These are all valid programs: FJID)WIJF, FH)Y*#, I0ASDFJ0IDFSJOJOSF280EFY2HFUDSOH)DFSHFD, 8DFS632&@DSFJFDJSINCSJNIJSHOF, etc.

Implement this as a table in typescript in the following form:

```
// character-defs.ts
const characterDefs = {
  'A': {
    color: '#78A10F',
    number: 7,
    function: (images, a, c) => ..., // a and c are the arguments here. `images` is passed to as the first argument to every function. width and height are implicit from the previous image. images are inputs to every function. images is a list of 3D tensors, and the function returns a 3D tensor
    arity: 2,
    functionName: "short-name",
    documentation: "one sentence about what the function does"
  }
}
```

I have already made index.html, runtime.ts, and parts of character-defs.ts. You just need to implement the rest of character-defs.ts.

All functions need to be completely deterministic! You must not use the random function anywhere!

Assign a random color to each character, and a number that starts at 1 at `A`, incrementing by one to `Z`, followed by `0` through `9`, followed by symbols.

---

# runtime.ts:

${:sh cat runtime.ts<eval-result-140713483217>import { characterDefs, createSolidImage, Image, FnContext, CharDef } from './character-defs.js';

interface ParsedSolidColor {
  type: 'solid';
  identifier: string;
  color: string;
}

interface ParsedFunction {
  type: 'function';
  identifier: string;
  fnDef: CharDef;
  args: (number | string)[];
}

type ParsedOp = ParsedSolidColor | ParsedFunction;

class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }

  clear(): void {
    this.cache.clear();
  }
}

function parseProgram(program: string): ParsedOp[] {
  console.log(`\n=== PARSING: "${program}" ===`);
  const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
  console.log(`Filtered chars: "${chars.join('')}"`);
  
  if (chars.length === 0) {
    console.log('Empty program, returning []');
    return [];
  }

  const ops: ParsedOp[] = [];
  
  const firstChar = chars[0];
  const firstDef = characterDefs[firstChar];
  const firstColor = firstDef ? firstDef.color : '#000000';
  
  console.log(`[0] First char '${firstChar}' -> solid color ${firstColor}`);
  ops.push({
    type: 'solid',
    identifier: firstChar,
    color: firstColor
  });

  let i = 1;
  while (i < chars.length) {
    const char = chars[i];
    const def = characterDefs[char];
    
    if (!def) {
      console.log(`[${i}] '${char}' undefined, skipping`);
      i++;
      continue;
    }

    const args: (number | string)[] = [];
    let argsConsumed = 0;

    console.log(`[${i}] '${char}' -> ${def.functionName}, arity ${def.arity}`);

    for (let argIdx = 0; argIdx < def.arity; argIdx++) {
      const argType = def.argTypes[argIdx];
      const nextCharIdx = i + 1 + argIdx;
      
      if (nextCharIdx < chars.length) {
        const argChar = chars[nextCharIdx];
        const argDef = characterDefs[argChar];
        
        if (argDef) {
          if (argType === 'int') {
            args.push(argDef.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.number}`);
          } else {
            args.push(argDef.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.color}`);
          }
          argsConsumed++;
        } else {
          if (argType === 'int') {
            args.push(def.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.number}`);
          } else {
            args.push(def.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.color}`);
          }
        }
      } else {
        if (argType === 'int') {
          args.push(def.number);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.number}`);
        } else {
          args.push(def.color);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.color}`);
        }
      }
    }

    const endIndex = i + 1 + argsConsumed;
    const identifier = chars.slice(0, endIndex).join('');
    
    console.log(`  identifier: "${identifier}"`);
    
    ops.push({
      type: 'function',
      identifier,
      fnDef: def,
      args
    });
    
    i += 1 + argsConsumed;
  }

  console.log(`Parsed into ${ops.length} operations`);
  return ops;
}

const imageCache = new LRUCache<string, Image>(100);
let lastWidth = 0;
let lastHeight = 0;

export function runProgram(program: string, width: number, height: number): Image[] {
  console.log(`\n=== EXECUTION: ${width}x${height} ===`);
  
  if (width !== lastWidth || height !== lastHeight) {
    console.log(`Dimensions changed (${lastWidth}x${lastHeight} -> ${width}x${height}), clearing cache`);
    imageCache.clear();
    lastWidth = width;
    lastHeight = height;
  }

  const ops = parseProgram(program);
  
  if (ops.length === 0) {
    console.log('No operations, returning black image');
    return [createSolidImage(width, height, '#000000')];
  }

  const images: Image[] = [createSolidImage(width, height, '#000000')];
  let cacheHits = 0;
  let cacheMisses = 0;
  
  for (let opIdx = 0; opIdx < ops.length; opIdx++) {
    const op = ops[opIdx];
    console.log(`\n[Op ${opIdx}] identifier="${op.identifier}"`);
    
    const cached = imageCache.get(op.identifier);
    if (cached) {
      console.log(`  ✓ CACHE HIT`);
      images.push(cached);
      cacheHits++;
      continue;
    }

    console.log(`  ✗ CACHE MISS`);
    cacheMisses++;

    let result: Image;
    
    if (op.type === 'solid') {
      console.log(`  Creating solid image: ${op.color}`);
      result = createSolidImage(width, height, op.color);
    } else {
      console.log(`  Executing function: ${op.fnDef.functionName} with args:`, op.args);
      const ctx: FnContext = {
        width,
        height,
        images: [...images],
        currentIndex: images.length,
      };
      
      result = op.fnDef.fn(ctx, ...op.args);
    }
    
    images.push(result);
    imageCache.set(op.identifier, result);
    console.log(`  ✓ Cached result for "${op.identifier}"`);
  }

  console.log(`\n=== EXECUTION COMPLETE ===`);
  console.log(`Cache hits: ${cacheHits}, Cache misses: ${cacheMisses}`);
  console.log(`Total images: ${images.length}`);
  return images;
}

export function getFinalImage(program: string, width: number, height: number): Image {
  const images = runProgram(program, width, height);
  return images[images.length - 1];
}

export function getParsedOperations(program: string): ParsedOp[] {
  return parseProgram(program);
}
</eval-result-140713483217>}

---

# character-defs.ts:

${:sh cat character-defs.ts<eval-result-140713407848>import * as THREE from 'three';
import FFT from 'fft.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

export interface Image {
  width: number;
  height: number;
  data: Uint8ClampedArray;
}

export interface FnContext {
  width: number;
  height: number;
  images: Image[];
  currentIndex: number;
}

export interface CharDef {
  color: string;
  number: number;
  fn: (ctx: FnContext, ...args: any[]) => Image;
  arity: number;
  argTypes: ('int' | 'color')[];
  functionName: string;
  documentation: string;
}

let glCanvas: HTMLCanvasElement | null = null;
let gl: WebGLRenderingContext | null = null;
let glTexture: WebGLTexture | null = null;
let glFramebuffer: WebGLFramebuffer | null = null;

function initWebGL(width: number, height: number): WebGLRenderingContext {
  if (!glCanvas || glCanvas.width !== width || glCanvas.height !== height) {
    glCanvas = document.createElement('canvas');
    glCanvas.width = width;
    glCanvas.height = height;
    gl = glCanvas.getContext('webgl', { 
      premultipliedAlpha: false,
      preserveDrawingBuffer: true 
    });
    if (!gl) throw new Error('WebGL not supported');
    
    glTexture = gl.createTexture();
    glFramebuffer = gl.createFramebuffer();
  }
  return gl!;
}

function createShaderProgram(gl: WebGLRenderingContext, vertSource: string, fragSource: string): WebGLProgram {
  const vertShader = gl.createShader(gl.VERTEX_SHADER)!;
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);
  
  const fragShader = gl.createShader(gl.FRAGMENT_SHADER)!;
  gl.shaderSource(fragShader, fragSource);
  gl.compileShader(fragShader);
  
  const program = gl.createProgram()!;
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  
  return program;
}

export function createSolidImage(width: number, height: number, color: string): Image {
  const [r, g, b] = hexToRgb(color);
  const data = new Uint8ClampedArray(width * height * 4);
  for (let i = 0; i < width * height; i++) {
    data[i * 4] = r;
    data[i * 4 + 1] = g;
    data[i * 4 + 2] = b;
    data[i * 4 + 3] = 255;
  }
  return { width, height, data };
}

function hexToRgb(hex: string): [number, number, number] {
  const h = hex.replace('#', '');
  return [
    parseInt(h.substring(0, 2), 16),
    parseInt(h.substring(2, 4), 16),
    parseInt(h.substring(4, 6), 16),
  ];
}

function cloneImage(img: Image): Image {
  return {
    width: img.width,
    height: img.height,
    data: new Uint8ClampedArray(img.data),
  };
}

function getPrevImage(ctx: FnContext): Image {
  if (ctx.images.length === 0) {
    return createSolidImage(ctx.width, ctx.height, '#000000');
  }
  return ctx.images[ctx.images.length - 1];
}

function getOldImage(ctx: FnContext, j: number): Image {
  if (ctx.images.length === 0) return createSolidImage(ctx.width, ctx.height, '#000000');
  if (ctx.images.length === 1) return ctx.images[0];
  const idx = Math.abs(j) % ctx.images.length;
  return ctx.images[idx];
}

function getPixel(img: Image, x: number, y: number): [number, number, number, number] {
  const cx = Math.max(0, Math.min(img.width - 1, Math.floor(x)));
  const cy = Math.max(0, Math.min(img.height - 1, Math.floor(y)));
  const i = (cy * img.width + cx) * 4;
  return [img.data[i], img.data[i + 1], img.data[i + 2], img.data[i + 3]];
}

function setPixel(img: Image, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {
  if (x < 0 || x >= img.width || y < 0 || y >= img.height) return;
  const i = (y * img.width + x) * 4;
  img.data[i] = r;
  img.data[i + 1] = g;
  img.data[i + 2] = b;
  img.data[i + 3] = a;
}

function rgbToHsl(r: number, g: number, b: number): [number, number, number] {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0, s = 0;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
  }
  
  return [h * 360, s, l];
}

function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  h = h / 360;
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function fnA(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    vec3 renderSphere(vec2 uv, vec2 center, float radius, sampler2D tex) {
      vec2 p = (uv - center) / radius;
      float d = length(p);
      
      if (d > 1.0) return vec3(-1.0);
      
      float z = sqrt(1.0 - d * d);
      vec3 normal = normalize(vec3(p.x, -p.y, z));
      vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.0));
      
      float diffuse = max(dot(normal, lightDir), 0.0);
      float ambient = 0.3;
      float lighting = ambient + diffuse * 0.7;
      
      vec2 texCoord = vec2(
        atan(normal.x, normal.z) / (2.0 * 3.14159) + 0.5,
        acos(normal.y) / 3.14159
      );
      
      vec3 color = texture2D(tex, texCoord).rgb;
      return color * lighting;
    }
    
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;
      vec3 bg = texture2D(texture, vec2(1.0 - uv.x, 1.0 - uv.y)).rgb;
      
      vec2 topRight = vec2(0.75, 0.75);
      vec2 bottomLeft = vec2(0.25, 0.25);
      float radius = 0.15;
      
      vec3 sphere1 = renderSphere(uv, topRight, radius, texture);
      vec3 sphere2 = renderSphere(uv, bottomLeft, radius, texture);
      
      vec3 color = bg;
      if (sphere1.x >= 0.0) color = sphere1;
      if (sphere2.x >= 0.0) color = sphere2;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  const textureLoc = gl.getUniformLocation(program, 'texture');
  const resolutionLoc = gl.getUniformLocation(program, 'resolution');
  
  gl.uniform1i(textureLoc, 0);
  gl.uniform2f(resolutionLoc, ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnB(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const seeds: [number, number][] = [];
  for (let i = 0; i < 36; i++) {
    seeds.push([
      (i * 47) % ctx.width,
      (i * 89) % ctx.height
    ]);
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let minDist = Infinity;
      let closestIdx = 0;
      
      for (let i = 0; i < seeds.length; i++) {
        const dx = x - seeds[i][0];
        const dy = y - seeds[i][1];
        const dist = dx * dx + dy * dy;
        if (dist < minDist) {
          minDist = dist;
          closestIdx = i;
        }
      }
      
      const src = closestIdx % 2 === 0 ? prev : old;
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnC(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const rings = Math.max(2, Math.min(n, 50));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxRadius = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const ringIdx = Math.floor((dist / maxRadius) * rings);
      const [r, g, b] = getPixel(prev, x, y);
      
      if (ringIdx % 2 === 0) {
        setPixel(out, x, y, r, g, b);
      } else {
        const hueShift = (360 / rings) * ringIdx;
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fn5(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const cellSize = Math.max(20, n * 4);
  const cols = Math.max(2, Math.floor(ctx.width / cellSize));
  const rows = Math.max(2, Math.floor(ctx.height / cellSize));
  const totalTriangles = cols * rows * 2;
  
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x0 = Math.floor((col / cols) * ctx.width);
      const y0 = Math.floor((row / rows) * ctx.height);
      const x1 = Math.floor(((col + 1) / cols) * ctx.width);
      const y1 = Math.floor(((row + 1) / rows) * ctx.height);
      const cellW = x1 - x0;
      const cellH = y1 - y0;
      
      const triIndex1 = (row * cols + col) * 2;
      const triIndex2 = triIndex1 + 1;
      
      const hueShift1 = (triIndex1 * 137.5) % 360;
      const hueShift2 = (triIndex2 * 137.5) % 360;
      const lightMod1 = (triIndex1 % 2 === 0) ? 0.15 : -0.15;
      const lightMod2 = (triIndex2 % 2 === 0) ? 0.15 : -0.05;
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const localX = (x - x0) / cellW;
          const localY = (y - y0) / cellH;
          
          const [r, g, b] = getPixel(prev, x, y);
          const [h, s, l] = rgbToHsl(r, g, b);
          const isUpperTriangle = localX + localY < 1;
          
          const hueShift = isUpperTriangle ? hueShift1 : hueShift2;
          const lightMod = isUpperTriangle ? lightMod1 : lightMod2;
          const newL = Math.max(0, Math.min(1, l + lightMod));
          
          const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, Math.min(1, s * 1.3), newL);
          setPixel(out, x, y, nr, ng, nb);
        }
      }
    }
  }
  
  return out;
}

function fnF(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const zoomPower = Math.max(1, n);
  const scale = Math.pow(0.7, zoomPower);
  const maxIterations = 10 + zoomPower * 5;
  
  const cReal = -0.7;
  const cImag = 0.27015;
  
  const centerReal = 0.15;
  const centerImag = 0.6;
  
  const aspect = ctx.height / ctx.width;
  
  for (let py = 0; py < ctx.height; py++) {
    for (let px = 0; px < ctx.width; px++) {
      let zReal = centerReal + ((px / ctx.width) - 0.5) * 3 * scale;
      let zImag = centerImag + ((py / ctx.height) - 0.5) * 3 * scale * aspect;
      
      let iteration = 0;
      let zReal2 = zReal * zReal;
      let zImag2 = zImag * zImag;
      
      while (iteration < maxIterations && zReal2 + zImag2 < 256) {
        zImag = 2 * zReal * zImag + cImag;
        zReal = zReal2 - zImag2 + cReal;
        zReal2 = zReal * zReal;
        zImag2 = zImag * zImag;
        iteration++;
      }
      
      if (iteration === maxIterations) {
        const [pr, pg, pb] = getPixel(prev, px, py);
        setPixel(out, px, py, pr, pg, pb);
      } else {
        const log_zn = Math.log(zReal2 + zImag2) / 2;
        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
        const smoothed = iteration + 1 - nu;
        
        const t = (smoothed % 20) / 20;
        const sampleX = Math.floor(t * ctx.width);
        const sampleY = py;
        
        const [pr, pg, pb] = getPixel(prev, sampleX, sampleY);
        const brightness = 0.85 + 0.3 * t;
        setPixel(out, px, py, 
          Math.min(255, Math.round(pr * brightness)),
          Math.min(255, Math.round(pg * brightness)),
          Math.min(255, Math.round(pb * brightness)));
      }
    }
  }
  
  return out;
}

function fnG(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const histogram = new Array(256).fill(0);
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
    out.data[i] = gray;
    out.data[i + 1] = gray;
    out.data[i + 2] = gray;
    histogram[gray]++;
  }
  
  const numColors = Math.max(2, Math.min(n, 16));
  const colors: [number, number, number][] = [];
  
  for (let i = 0; i < numColors; i++) {
    const hue = (i / numColors) * 360;
    colors.push(hslToRgb(hue, 0.7, 0.5));
  }
  
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = out.data[i];
    const colorIndex = Math.floor((gray / 256) * numColors);
    const clampedIndex = Math.min(colorIndex, numColors - 1);
    
    out.data[i] = colors[clampedIndex][0];
    out.data[i + 1] = colors[clampedIndex][1];
    out.data[i + 2] = colors[clampedIndex][2];
  }
  
  return out;
}

function fnH(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / cx;
      const ny = (y - cy) / cy;
      
      const hourglassWidth = Math.abs(ny);
      const inHourglass = Math.abs(nx) < hourglassWidth;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      const distFromCenter = Math.sqrt(nx * nx + ny * ny);
      const angle = Math.atan2(ny, nx);
      
      if (inHourglass) {
        const gr = Math.floor((1 - Math.abs(ny)) * 255);
        const gg = Math.floor((Math.abs(nx) / Math.max(0.01, hourglassWidth)) * 255);
        const gb = Math.floor(distFromCenter * 180);
        
        const nr = 255 - (pr & gr);
        const ng = 255 - (pg & gg);
        const nb = 255 - (pb & gb);
        
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const gr = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 255);
        const gg = Math.floor((1 - distFromCenter) * 200 + 55);
        const gb = Math.floor(((nx + 1) / 2) * 255);
        
        const nr = (pr + gr) % 256;
        const ng = Math.abs(pg - gg);
        const nb = pb ^ gb;
        
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnI(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = 255 - out.data[i];
    out.data[i + 1] = 255 - out.data[i + 1];
    out.data[i + 2] = 255 - out.data[i + 2];
  }
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  for (let y = 1; y < ctx.height - 1; y++) {
    for (let x = 1; x < ctx.width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const px = getPixel(prev, x + kx, y + ky);
          const gray = px[0] * 0.299 + px[1] * 0.587 + px[2] * 0.114;
          const kernelIdx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kernelIdx];
          gy += gray * sobelY[kernelIdx];
        }
      }
      
      const magnitude = Math.sqrt(gx * gx + gy * gy);
      
      if (magnitude > 50) {
        setPixel(out, x, y, 255, 255, 255);
      }
    }
  }
  
  return out;
}

function fnJ(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = x / ctx.width;
      const ny = y / ctx.height;
      
      const squareSize = Math.max(2, Math.floor(2 + (nx + ny) * 50));
      
      const gridX = Math.floor(x / squareSize);
      const gridY = Math.floor(y / squareSize);
      
      const useOld = (gridX + gridY) % 2 === 0;
      const src = useOld ? old : prev;
      
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnK(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const segments = Math.max(1, Math.min(n + 2, 18));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const angleStep = (Math.PI * 2) / segments;
  const zoom = 1.1;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = (x - cx) * zoom;
      const dy = (y - cy) * zoom;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const segmentAngle = angle % angleStep;
      const mirroredAngle = segmentAngle > angleStep / 2 ? angleStep - segmentAngle : segmentAngle;
      
      const r = Math.sqrt(dx * dx + dy * dy);
      const sx = cx + r * Math.cos(mirroredAngle);
      const sy = cy + r * Math.sin(mirroredAngle);
      
      const [pr, pg, pb] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, pr, pg, pb);
    }
  }
  
  return out;
}

function fnL(ctx: FnContext, j: number, rot: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const rotation = rot * 0.3;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uModelView;
    uniform mat3 uNormalMatrix;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vPosition = (uModelView * vec4(aPosition, 1.0)).xyz;
      vNormal = uNormalMatrix * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * vec4(vPosition, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightPos;
    uniform vec3 uLightPos2;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vec3 normal = normalize(vNormal);
      vec3 viewDir = normalize(-vPosition);
      
      // Light 1 - main light
      vec3 lightDir1 = normalize(uLightPos - vPosition);
      vec3 halfDir1 = normalize(lightDir1 + viewDir);
      float diff1 = max(dot(normal, lightDir1), 0.0);
      float spec1 = pow(max(dot(normal, halfDir1), 0.0), 32.0);
      
      // Light 2 - fill light
      vec3 lightDir2 = normalize(uLightPos2 - vPosition);
      vec3 halfDir2 = normalize(lightDir2 + viewDir);
      float diff2 = max(dot(normal, lightDir2), 0.0);
      float spec2 = pow(max(dot(normal, halfDir2), 0.0), 32.0);
      
      float ambient = 0.35;
      float diffuse = diff1 * 0.6 + diff2 * 0.35;
      float specular = (spec1 * 0.8 + spec2 * 0.4);
      
      vec2 tiledCoord = fract(vTexCoord);
      vec3 texColor = texture2D(uTexture, tiledCoord).rgb;
      vec3 color = texColor * (ambient + diffuse) + vec3(1.0) * specular;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const bgVertShader = `
    attribute vec2 aPosition;
    varying vec2 vUV;
    void main() {
      vUV = aPosition * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 0.999, 1.0);
    }
  `;
  
  const bgFragShader = `
    precision highp float;
    uniform sampler2D uBgTexture;
    varying vec2 vUV;
    void main() {
      gl_FragColor = texture2D(uBgTexture, vec2(vUV.x, 1.0 - vUV.y));
    }
  `;
  
  const tubeProgram = createShaderProgram(gl, vertexShader, fragmentShader);
  const bgProgram = createShaderProgram(gl, bgVertShader, bgFragShader);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const positions: number[] = [];
  const normals: number[] = [];
  const texCoords: number[] = [];
  
  const a = 3, b = 2, c = 1;
  const tubeRadius = 0.08;
  const segments = 400;
  const radialSegments = 12;
  
  const cross = (a: number[], b: number[]): number[] => [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
  const normalize = (v: number[]): number[] => {
    const len = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
    if (len < 0.0001) return [1, 0, 0];
    return [v[0]/len, v[1]/len, v[2]/len];
  };
  const dot = (a: number[], b: number[]): number => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  
  const getPoint = (t: number): number[] => [
    Math.sin(a * t) * 0.7,
    Math.sin(b * t) * 0.7,
    Math.sin(c * t) * 0.5
  ];
  
  const getTangent = (t: number): number[] => {
    const eps = 0.0001;
    const p1 = getPoint(t - eps);
    const p2 = getPoint(t + eps);
    return normalize([p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]]);
  };
  
  const frames: {point: number[], normal: number[], binormal: number[]}[] = [];
  
  let prevNormal = [1, 0, 0];
  const firstTan = getTangent(0);
  if (Math.abs(dot(prevNormal, firstTan)) > 0.9) {
    prevNormal = [0, 1, 0];
  }
  prevNormal = normalize(cross(cross(firstTan, prevNormal), firstTan));
  
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const point = getPoint(t);
    const tangent = getTangent(t);
    
    let normal = normalize(cross(cross(tangent, prevNormal), tangent));
    const binormal = normalize(cross(tangent, normal));
    
    frames.push({ point, normal, binormal });
    prevNormal = normal;
  }
  
  const firstFrame = frames[0];
  const lastFrame = frames[segments];
  const twistAngle = Math.atan2(
    dot(lastFrame.normal, firstFrame.binormal),
    dot(lastFrame.normal, firstFrame.normal)
  );
  
  for (let i = 0; i <= segments; i++) {
    const correction = -twistAngle * (i / segments);
    const cos_c = Math.cos(correction), sin_c = Math.sin(correction);
    const f = frames[i];
    const newNormal = [
      f.normal[0] * cos_c + f.binormal[0] * sin_c,
      f.normal[1] * cos_c + f.binormal[1] * sin_c,
      f.normal[2] * cos_c + f.binormal[2] * sin_c
    ];
    const newBinormal = [
      -f.normal[0] * sin_c + f.binormal[0] * cos_c,
      -f.normal[1] * sin_c + f.binormal[1] * cos_c,
      -f.normal[2] * sin_c + f.binormal[2] * cos_c
    ];
    f.normal = newNormal;
    f.binormal = newBinormal;
  }
  
  for (let i = 0; i < segments; i++) {
    const f0 = frames[i];
    const f1 = frames[i + 1];
    
    for (let r = 0; r < radialSegments; r++) {
      const angle0 = (r / radialSegments) * Math.PI * 2;
      const angle1 = ((r + 1) / radialSegments) * Math.PI * 2;
      
      const cos0 = Math.cos(angle0), sin0 = Math.sin(angle0);
      const cos1 = Math.cos(angle1), sin1 = Math.sin(angle1);
      
      const v00 = [
        f0.point[0] + (f0.normal[0] * cos0 + f0.binormal[0] * sin0) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos0 + f0.binormal[1] * sin0) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos0 + f0.binormal[2] * sin0) * tubeRadius
      ];
      const v01 = [
        f0.point[0] + (f0.normal[0] * cos1 + f0.binormal[0] * sin1) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos1 + f0.binormal[1] * sin1) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos1 + f0.binormal[2] * sin1) * tubeRadius
      ];
      const v10 = [
        f1.point[0] + (f1.normal[0] * cos0 + f1.binormal[0] * sin0) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos0 + f1.binormal[1] * sin0) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos0 + f1.binormal[2] * sin0) * tubeRadius
      ];
      const v11 = [
        f1.point[0] + (f1.normal[0] * cos1 + f1.binormal[0] * sin1) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos1 + f1.binormal[1] * sin1) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos1 + f1.binormal[2] * sin1) * tubeRadius
      ];
      
      const n00 = [f0.normal[0] * cos0 + f0.binormal[0] * sin0, f0.normal[1] * cos0 + f0.binormal[1] * sin0, f0.normal[2] * cos0 + f0.binormal[2] * sin0];
      const n01 = [f0.normal[0] * cos1 + f0.binormal[0] * sin1, f0.normal[1] * cos1 + f0.binormal[1] * sin1, f0.normal[2] * cos1 + f0.binormal[2] * sin1];
      const n10 = [f1.normal[0] * cos0 + f1.binormal[0] * sin0, f1.normal[1] * cos0 + f1.binormal[1] * sin0, f1.normal[2] * cos0 + f1.binormal[2] * sin0];
      const n11 = [f1.normal[0] * cos1 + f1.binormal[0] * sin1, f1.normal[1] * cos1 + f1.binormal[1] * sin1, f1.normal[2] * cos1 + f1.binormal[2] * sin1];
      
      const u0 = i / segments * 3;
      const u1 = (i + 1) / segments * 3;
      const v0 = r / radialSegments;
      const v1 = (r + 1) / radialSegments;
      
      positions.push(...v00, ...v10, ...v11, ...v00, ...v11, ...v01);
      normals.push(...n00, ...n10, ...n11, ...n00, ...n11, ...n01);
      texCoords.push(u0, v0, u1, v0, u1, v1, u0, v0, u1, v1, u0, v1);
    }
  }
  
  gl.enable(gl.DEPTH_TEST);
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  gl.useProgram(bgProgram);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(bgProgram, 'uBgTexture'), 0);
  
  const bgVerts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const bgBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, bgVerts, gl.STATIC_DRAW);
  const bgPosLoc = gl.getAttribLocation(bgProgram, 'aPosition');
  gl.enableVertexAttribArray(bgPosLoc);
  gl.vertexAttribPointer(bgPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.disableVertexAttribArray(bgPosLoc);
  
  gl.useProgram(tubeProgram);
  
  const posLoc = gl.getAttribLocation(tubeProgram, 'aPosition');
  const normLoc = gl.getAttribLocation(tubeProgram, 'aNormal');
  const texLoc = gl.getAttribLocation(tubeProgram, 'aTexCoord');
  
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  
  const normBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  
  const texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 3.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const projection = new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) / (near - far), -1,
    0, 0, (2 * far * near) / (near - far), 0
  ]);
  
  const angleY = -55 * Math.PI / 180 + rotation;
  const angleX = 0.3;
  const cy = Math.cos(angleY), sy = Math.sin(angleY);
  const cx = Math.cos(angleX), sx = Math.sin(angleX);
  const modelView = new Float32Array([
    cy, sy * sx, sy * cx, 0,
    0, cx, -sx, 0,
    -sy, cy * sx, cy * cx, 0,
    0, 0, -2.2, 1
  ]);
  
  const normalMatrix = new Float32Array([
    cy, sy * sx, sy * cx,
    0, cx, -sx,
    -sy, cy * sx, cy * cx
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uProjection'), false, projection);
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uModelView'), false, modelView);
  gl.uniformMatrix3fv(gl.getUniformLocation(tubeProgram, 'uNormalMatrix'), false, normalMatrix);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos'), 3.0, 3.0, 3.0);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos2'), -2.0, 1.0, 2.0);
  
  gl.activeTexture(gl.TEXTURE1);
  const tubeTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tubeTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.uniform1i(gl.getUniformLocation(tubeProgram, 'uTexture'), 1);
  
  gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disable(gl.DEPTH_TEST);
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE0);
  gl.deleteTexture(tubeTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(oldTexture);
  gl.deleteBuffer(bgBuffer);
  gl.deleteBuffer(posBuffer);
  gl.deleteBuffer(normBuffer);
  gl.deleteBuffer(texBuffer);
  gl.deleteProgram(tubeProgram);
  gl.deleteProgram(bgProgram);
  gl.useProgram(null);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnM(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hash = (i: number) => {
    const x = Math.sin(i * 127.1 + n * 311.7) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const scale = 12 + hash(0) * 30;
  const freqRatio = 1.02 + hash(1) * 0.1;
  const amp1 = 15 + hash(2) * 80;
  const amp2 = 15 + hash(3) * 80;
  const freq1 = 0.006 + hash(4) * 0.025;
  const angle1 = hash(5) * Math.PI;
  const angle2 = angle1 + (hash(6) - 0.5) * 0.3;
  const phase = hash(7) * Math.PI * 2;
  const hueShift = Math.floor(hash(8) * 360);
  const harmonic1 = 0.3 + hash(9) * 0.7;
  const harmonic2 = hash(10) * 0.5;
  const scaleRatio = 0.95 + hash(11) * 0.1;
  const crossAmp = hash(12) * 40;
  const crossFreq = 0.01 + hash(13) * 0.02;
  
  const cos_a1 = Math.cos(angle1), sin_a1 = Math.sin(angle1);
  const cos_a2 = Math.cos(angle2), sin_a2 = Math.sin(angle2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const rx1 = x * cos_a1 + y * sin_a1;
      const ry1 = -x * sin_a1 + y * cos_a1;
      const rx2 = x * cos_a2 + y * sin_a2;
      const ry2 = -x * sin_a2 + y * cos_a2;
      
      const wobble1 = Math.sin(rx1 * freq1) * amp1 
                    + Math.sin(rx1 * freq1 * 2.1) * amp1 * harmonic1
                    + Math.sin(ry1 * crossFreq) * crossAmp;
      const wobble2 = Math.sin(rx2 * freq1 * freqRatio + phase) * amp2
                    + Math.sin(rx2 * freq1 * freqRatio * 2.3 + phase) * amp2 * harmonic2
                    + Math.sin(ry2 * crossFreq * 1.1) * crossAmp;
      
      const wave1 = ry1 + wobble1;
      const wave2 = ry2 + wobble2;
      
      const line1 = Math.floor(wave1 / scale) % 2;
      const line2 = Math.floor(wave2 / (scale * scaleRatio)) % 2;
      
      const moire = line1 !== line2;
      
      const [r, g, b] = getPixel(prev, x, y);
      
      if (moire) {
        setPixel(out, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnN(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const scale = Math.min(ctx.width, ctx.height);
  const numLights = 15;
  
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const lights: { x: number; y: number; r: number; g: number; b: number; size: number }[] = [];
  for (let i = 0; i < numLights; i++) {
    const px = hash(i * 127.1) * ctx.width;
    const py = hash(i * 311.7) * ctx.height;
    const colorAngle = hash(i * 74.3) * Math.PI * 2;
    const size = 0.03 + hash(i * 191.3) * 0.04;
    lights.push({
      x: px, y: py,
      r: Math.cos(colorAngle) * 0.5 + 0.5,
      g: Math.cos(colorAngle + Math.PI * 2 / 3) * 0.5 + 0.5,
      b: Math.cos(colorAngle + Math.PI * 4 / 3) * 0.5 + 0.5,
      size
    });
  }
  
  const glowRadius = 8;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / (255 * 3);
      
      let tr = (pr / 255) * 0.3;
      let tg = (pg / 255) * 0.3;
      let tb = (pb / 255) * 0.3;
      
      if (brightness > 0.3) {
        let glowSum = 0;
        let glowR = 0, glowG = 0, glowB = 0;
        for (let dy = -glowRadius; dy <= glowRadius; dy += 2) {
          for (let dx = -glowRadius; dx <= glowRadius; dx += 2) {
            const sx = Math.max(0, Math.min(ctx.width - 1, x + dx));
            const sy = Math.max(0, Math.min(ctx.height - 1, y + dy));
            const [sr, sg, sb] = getPixel(prev, sx, sy);
            const sBright = (sr + sg + sb) / (255 * 3);
            if (sBright > 0.3) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              const weight = Math.max(0, 1 - dist / glowRadius);
              glowR += (sr / 255) * weight * sBright;
              glowG += (sg / 255) * weight * sBright;
              glowB += (sb / 255) * weight * sBright;
              glowSum += weight;
            }
          }
        }
        if (glowSum > 0) {
          tr += (glowR / glowSum) * brightness * 1.5;
          tg += (glowG / glowSum) * brightness * 1.5;
          tb += (glowB / glowSum) * brightness * 1.5;
        }
      }
      
      for (const light of lights) {
        const dx = (x - light.x) / scale;
        const dy = (y - light.y) / scale;
        const distSq = dx * dx + dy * dy;
        const glow = (light.size * light.size) / Math.max(0.0001, distSq);
        const cappedGlow = Math.min(1, glow);
        tr += cappedGlow * light.r;
        tg += cappedGlow * light.g;
        tb += cappedGlow * light.b;
      }
      
      setPixel(out, x, y,
        Math.min(255, Math.floor(tr * 255)),
        Math.min(255, Math.floor(tg * 255)),
        Math.min(255, Math.floor(tb * 255))
      );
    }
  }
  
  return out;
}

function fnO(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  
  const multiplier = 1.5 + n * 0.8;
  
  const nextPow2 = (v: number) => {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return v + 1;
  };
  
  const fftW = nextPow2(ctx.width);
  const fftH = nextPow2(ctx.height);
  
  const fftRow = new FFT(fftW);
  const fftCol = new FFT(fftH);
  
  const processChannel = (channel: Float32Array, mult: number, phaseShift: number): Float32Array => {
    const data = new Float64Array(fftW * fftH * 2);
    
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        data[(y * fftW + x) * 2] = channel[y * ctx.width + x];
      }
    }
    
    const rowIn = fftRow.createComplexArray();
    const rowOut = fftRow.createComplexArray();
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.transform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
        data[(y * fftW + x) * 2 + 1] = rowOut[x * 2 + 1];
      }
    }
    
    const colIn = fftCol.createComplexArray();
    const colOut = fftCol.createComplexArray();
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.transform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    const cx = fftW / 2;
    const cy = fftH / 2;
    const maxFreqDist = Math.sqrt(cx * cx + cy * cy);
    const wrapLimit = 255 * fftW * fftH / 4;
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        const i = (y * fftW + x) * 2;
        const re = data[i];
        const im = data[i + 1];
        const mag = Math.sqrt(re * re + im * im);
        let phase = Math.atan2(im, re);
        
        const dx = (x < cx ? x : x - fftW);
        const dy = (y < cy ? y : y - fftH);
        const freqDist = Math.sqrt(dx * dx + dy * dy) / maxFreqDist;
        
        let newMag = mag * mult;
        while (newMag > wrapLimit) {
          newMag = Math.abs(newMag - wrapLimit * 2);
        }
        
        phase += phaseShift * freqDist;
        
        data[i] = newMag * Math.cos(phase);
        data[i + 1] = newMag * Math.sin(phase);
      }
    }
    
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.inverseTransform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.inverseTransform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
      }
    }
    
    const result = new Float32Array(ctx.width * ctx.height);
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        result[y * ctx.width + x] = data[(y * fftW + x) * 2];
      }
    }
    
    return result;
  };
  
  const rIn = new Float32Array(ctx.width * ctx.height);
  const gIn = new Float32Array(ctx.width * ctx.height);
  const bIn = new Float32Array(ctx.width * ctx.height);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = y * ctx.width + x;
      rIn[idx] = r;
      gIn[idx] = g;
      bIn[idx] = b;
    }
  }
  
  const rOut = processChannel(rIn, multiplier, 0);
  const gOut = processChannel(gIn, multiplier * 1.1, Math.PI * 0.1);
  const bOut = processChannel(bIn, multiplier * 0.9, -Math.PI * 0.1);
  
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const idx = y * ctx.width + x;
      let r = rOut[idx];
      let g = gOut[idx];
      let b = bOut[idx];
      
      r = ((r % 256) + 256) % 256;
      g = ((g % 256) + 256) % 256;
      b = ((b % 256) + 256) % 256;
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnP(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(2, Math.min(n + 1, 50));
  
  for (let by = 0; by < ctx.height; by += cellSize) {
    for (let bx = 0; bx < ctx.width; bx += cellSize) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      let maxSat = 0;
      let mostSatR = 0, mostSatG = 0, mostSatB = 0;
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
          
          const [h, s, l] = rgbToHsl(r, g, b);
          if (s > maxSat) {
            maxSat = s;
            mostSatR = r;
            mostSatG = g;
            mostSatB = b;
          }
        }
      }
      
      const avgR = Math.round(sumR / count);
      const avgG = Math.round(sumG / count);
      const avgB = Math.round(sumB / count);
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const localX = x - bx;
          const localY = y - by;
          const isTopLeft = localX + localY < cellSize;
          
          if (isTopLeft) {
            setPixel(out, x, y, avgR, avgG, avgB);
          } else {
            setPixel(out, x, y, mostSatR, mostSatG, mostSatB);
          }
        }
      }
    }
  }
  
  return out;
}

let emeraldScene: THREE.Scene | null = null;
let emeraldRenderer: THREE.WebGLRenderer | null = null;
let emeraldCamera: THREE.PerspectiveCamera | null = null;
let emeraldModel: THREE.Group | null = null;
let emeraldModelLoaded = false;
let emeraldLoadPromise: Promise<void> | null = null;
let emeraldComposer: EffectComposer | null = null;

function initEmeraldScene(width: number, height: number) {
  if (!emeraldRenderer || emeraldRenderer.domElement.width !== width || emeraldRenderer.domElement.height !== height) {
    if (emeraldRenderer) {
      emeraldRenderer.dispose();
    }
    
    emeraldRenderer = new THREE.WebGLRenderer({ 
      alpha: true, 
      antialias: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance',
    });
    emeraldRenderer.setSize(width, height);
    emeraldRenderer.setPixelRatio(1);
    emeraldRenderer.setClearColor(0x000000, 0);
    emeraldRenderer.toneMapping = THREE.NoToneMapping;
    emeraldRenderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // Setup bloom for sparkle effect
    emeraldComposer = new EffectComposer(emeraldRenderer);
  }
  
  if (!emeraldScene) {
    emeraldScene = new THREE.Scene();
  }
  
  if (!emeraldCamera) {
    emeraldCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    emeraldCamera.position.set(0, 2, 5);
    emeraldCamera.lookAt(0, 0, 0);
  } else {
    emeraldCamera.aspect = width / height;
    emeraldCamera.updateProjectionMatrix();
  }
}

function loadEmeraldModel(): Promise<void> {
  if (emeraldLoadPromise) {
    return emeraldLoadPromise;
  }
  
  emeraldLoadPromise = new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    loader.load(
      './emerald.glb',
      (gltf) => {
        emeraldModel = gltf.scene;
        
        const box = new THREE.Box3().setFromObject(emeraldModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2.0 / maxDim;
        
        emeraldModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
        emeraldModel.scale.setScalar(scale);
        
        emeraldModelLoaded = true;
        resolve();
      },
      undefined,
      (error) => {
        console.error('Error loading emerald model:', error);
        reject(error);
      }
    );
  });
  
  return emeraldLoadPromise;
}

// Start loading immediately when module loads
export const emeraldReady = loadEmeraldModel();

function fnE(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  
  if (!emeraldModelLoaded || !emeraldModel) {
    throw new Error('Emerald model not loaded - await emeraldReady before rendering');
  }
  
  initEmeraldScene(ctx.width, ctx.height);
  
  while (emeraldScene!.children.length > 0) {
    emeraldScene!.remove(emeraldScene!.children[0]);
  }
  
  // Create background texture - preserve original colors
  const bgTexture = new THREE.DataTexture(
    prev.data,
    prev.width,
    prev.height,
    THREE.RGBAFormat
  );
  bgTexture.colorSpace = THREE.SRGBColorSpace;
  bgTexture.needsUpdate = true;
  bgTexture.flipY = true;
  emeraldScene!.background = bgTexture;

  // Create environment map for reflections
  const pmremGenerator = new THREE.PMREMGenerator(emeraldRenderer!);
  pmremGenerator.compileEquirectangularShader();
  const envRT = pmremGenerator.fromEquirectangular(bgTexture);
  emeraldScene!.environment = envRT.texture;

  // Low ambient for more contrast
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
  emeraldScene!.add(ambientLight);
  
  // Strong key light for highlights
  const keyLight = new THREE.DirectionalLight(0xffffff, 5.0);
  keyLight.position.set(5, 8, 10);
  emeraldScene!.add(keyLight);
  
  // Weak fill light - keeps shadows darker
  const fillLight = new THREE.DirectionalLight(0xeeffee, 0.8);
  fillLight.position.set(-5, 3, 8);
  emeraldScene!.add(fillLight);
  
  // Rim lights for edge highlights from multiple angles
  const rimLight = new THREE.DirectionalLight(0xffffff, 2.5);
  rimLight.position.set(0, -2, 8);
  emeraldScene!.add(rimLight);
  
  const rimLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight2.position.set(-6, 0, -2);
  emeraldScene!.add(rimLight2);
  
  const rimLight3 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight3.position.set(6, 0, -2);
  emeraldScene!.add(rimLight3);
  
  // Seeded random for deterministic light positions based on image count
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  // Dramatic point lights - fewer but more intense for contrast
  const numLights = 8;
  for (let i = 0; i < numLights; i++) {
    const angle = hash(i * 127.1) * Math.PI * 2;
    const elevation = hash(i * 311.7) * Math.PI * 0.5 + 0.3;
    const distance = 3 + hash(i * 74.3) * 5;
    
    const px = Math.cos(angle) * Math.cos(elevation) * distance;
    const py = Math.sin(elevation) * distance + 2;
    const pz = Math.sin(angle) * Math.cos(elevation) * distance + 4;
    
    const intensity = 15.0 + hash(i * 191.3) * 25.0;
    const light = new THREE.PointLight(0xffffff, intensity, 30);
    light.decay = 2;
    light.position.set(px, py, pz);
    emeraldScene!.add(light);
  }

  // Glass emerald material - pronounced edges with sheen
  const emeraldMaterial = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(0.3, 0.95, 0.5),
    metalness: 0.0,
    roughness: 0.0,
    transmission: 0.92,
    thickness: 0.4,
    ior: 1.3,
    envMapIntensity: 0.25,
    clearcoat: 1.0,
    clearcoatRoughness: 0.0,
    transparent: true,
    side: THREE.DoubleSide,
    flatShading: true,
    attenuationColor: new THREE.Color(0.0, 0.75, 0.25),
    attenuationDistance: 0.4,
    specularIntensity: 1.5,
    specularColor: new THREE.Color(1, 1, 1),
    reflectivity: 0.3,
    sheen: 0.5,
    sheenRoughness: 0.2,
    sheenColor: new THREE.Color(0.8, 1.0, 0.9),
  });
  
  // Corner positions extracted from the emerald geometry
  // Girdle corners (8 points around y ≈ 0.07)
  const girdleCorners = [
    [0.0, 0.064, -0.323],    // front
    [0.227, 0.069, -0.226],  // front-right
    [0.322, 0.063, 0.0],     // right
    [0.224, 0.072, 0.228],   // back-right
    [0.0, 0.064, 0.322],     // back
    [-0.227, 0.07, 0.226],   // back-left
    [-0.322, 0.07, 0.0],     // left (inferred)
    [-0.225, 0.069, -0.227], // front-left
  ];
  
  // Crown corners (upper facet intersections around y ≈ 0.176)
  const crownCorners = [
    [-0.169, 0.176, -0.092],
    [-0.089, 0.176, 0.174],
    [0.169, 0.176, -0.092],  // mirrored
    [0.089, 0.176, 0.174],   // mirrored
    [0.0, 0.176, -0.18],     // front center
    [0.0, 0.176, 0.18],      // back center
    [-0.15, 0.176, 0.0],     // left center
    [0.15, 0.176, 0.0],      // right center
  ];
  
  // Create subtle sparkle sprite texture
  const sparkleCanvas = document.createElement('canvas');
  sparkleCanvas.width = 64;
  sparkleCanvas.height = 64;
  const sctx = sparkleCanvas.getContext('2d')!;
  const cx = 32, cy = 32;
  
  // Soft subtle glow
  const gradient = sctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.3)');
  gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.08)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  sctx.fillStyle = gradient;
  sctx.fillRect(0, 0, 64, 64);
  
  // Very subtle cross rays
  sctx.globalCompositeOperation = 'lighter';
  const rayGradient = sctx.createLinearGradient(0, cy, 64, cy);
  rayGradient.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradient.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradient.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradient;
  sctx.fillRect(0, cy-1, 64, 2);
  
  const rayGradientV = sctx.createLinearGradient(cx, 0, cx, 64);
  rayGradientV.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradientV.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradientV.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradientV;
  sctx.fillRect(cx-1, 0, 2, 64);
  
  const sparkleTexture = new THREE.CanvasTexture(sparkleCanvas);
  
  const createSparkleMaterial = () => new THREE.SpriteMaterial({
    map: sparkleTexture,
    color: 0xffffff,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    depthWrite: false,
  });

  const addEmerald = (x: number, y: number, scale: number, logGeometry: boolean = false) => {
    const gem = emeraldModel!.clone();
    
    gem.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        const geom = child.geometry.clone();
        geom.computeVertexNormals();
        child.geometry = geom;
        child.material = emeraldMaterial;
        child.renderOrder = 1;
        
        // Log geometry info for the first emerald
        if (logGeometry) {
          const positions = geom.attributes.position;
          const normals = geom.attributes.normal;
          
          console.log('=== EMERALD GEOMETRY ===');
          console.log('Vertex count:', positions.count);
          console.log('Triangle count:', positions.count / 3);
          
          // Find unique vertices and their positions
          const uniqueVerts = new Map<string, {pos: number[], count: number, indices: number[]}>();
          
          for (let i = 0; i < positions.count; i++) {
            const px = positions.getX(i).toFixed(3);
            const py = positions.getY(i).toFixed(3);
            const pz = positions.getZ(i).toFixed(3);
            const key = `${px},${py},${pz}`;
            
            if (!uniqueVerts.has(key)) {
              uniqueVerts.set(key, {pos: [parseFloat(px), parseFloat(py), parseFloat(pz)], count: 0, indices: []});
            }
            uniqueVerts.get(key)!.count++;
            uniqueVerts.get(key)!.indices.push(i);
          }
          
          console.log('Unique vertex positions:', uniqueVerts.size);
          
          // Sort by how many triangles share this vertex (corners have more)
          const sorted = [...uniqueVerts.entries()].sort((a, b) => b[1].count - a[1].count);
          
          console.log('\nTop 20 most-shared vertices (likely corners):');
          sorted.slice(0, 20).forEach(([key, data], i) => {
            console.log(`  ${i+1}. [${data.pos.join(', ')}] shared by ${data.count} triangles`);
          });
          
          // Also log bounding box
          geom.computeBoundingBox();
          const bb = geom.boundingBox!;
          console.log('\nBounding box:');
          console.log('  min:', bb.min.x.toFixed(3), bb.min.y.toFixed(3), bb.min.z.toFixed(3));
          console.log('  max:', bb.max.x.toFixed(3), bb.max.y.toFixed(3), bb.max.z.toFixed(3));
        }
      }
    });
    
    gem.scale.setScalar(scale * 3.0);
    gem.position.set(x, y, 0);
    emeraldScene!.add(gem);
    
    // Add sparkle sprites at corner positions
    const allCorners = [...girdleCorners, ...crownCorners];
    const scaleFactor = scale * 3.0;
    
    allCorners.forEach((corner, i) => {
      // Only show sparkles on front-facing corners (positive z)
      if (corner[2] > 0) {
        const sprite = new THREE.Sprite(createSparkleMaterial());
        const sparkleSize = 0.03 + (i % 3) * 0.01;
        sprite.scale.set(sparkleSize * scaleFactor, sparkleSize * scaleFactor, 1);
        // Position at the corner, pushed forward a bit to be visible
        sprite.position.set(
          x + corner[0] * scaleFactor,
          y + corner[1] * scaleFactor,
          corner[2] * scaleFactor + 0.02
        );
        sprite.renderOrder = 10;
        emeraldScene!.add(sprite);
      }
    });
  };
  
  addEmerald(0, 0, 1.0, false);  // Main emerald
  addEmerald(-2.5, 0, 0.5);
  addEmerald(2.5, 0, 0.5);
  addEmerald(-1.5, 1.2, 0.35);
  addEmerald(1.5, 1.2, 0.35);
  addEmerald(-1.5, -1.2, 0.35);
  addEmerald(1.5, -1.2, 0.35);
  
  // Setup bloom passes
  emeraldComposer!.passes = [];
  const renderPass = new RenderPass(emeraldScene!, emeraldCamera!);
  emeraldComposer!.addPass(renderPass);
  
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(ctx.width, ctx.height),
    0.3,
    0.15,
    0.97
  );
  emeraldComposer!.addPass(bloomPass);
  
  // Render multiple times - transmission needs multiple passes to converge
  for (let i = 0; i < 6; i++) {
    emeraldComposer!.render();
  }
  
  const glContext = emeraldRenderer!.getContext();
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  glContext.readPixels(0, 0, ctx.width, ctx.height, glContext.RGBA, glContext.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  // Clean up
  bgTexture.dispose();
  envRT.texture.dispose();
  pmremGenerator.dispose();
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnR(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    #define PI 3.14159265359
    
    // Ray-plane intersection
    float intersectPlane(vec3 ro, vec3 rd, vec3 planeNormal, float planeD) {
      float denom = dot(rd, planeNormal);
      if (abs(denom) < 0.0001) return -1.0;
      return -(dot(ro, planeNormal) + planeD) / denom;
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Camera setup - looking into the room
      vec3 ro = vec3(0.0, 0.0, 2.5); // camera position
      vec2 screenPos = (uv - 0.5) * 2.0;
      screenPos.x *= aspect;
      vec3 rd = normalize(vec3(screenPos * 0.8, -1.0)); // ray direction
      
      // Room dimensions
      float roomSize = 2.0;
      float roomDepth = 3.0;
      
      // Light position (center of room)
      vec3 lightPos = vec3(0.0, 0.0, -roomDepth * 0.4);
      
      // Find closest intersection
      float tMin = 1000.0;
      vec3 hitNormal = vec3(0.0);
      vec2 texCoord = vec2(0.0);
      
      // Back wall (z = -roomDepth)
      float t = intersectPlane(ro, rd, vec3(0.0, 0.0, 1.0), roomDepth);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (abs(hit.x) < roomSize && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 0.0, 1.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Left wall (x = -roomSize)
      t = intersectPlane(ro, rd, vec3(1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(1.0, 0.0, 0.0);
          texCoord = vec2((hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Right wall (x = roomSize)
      t = intersectPlane(ro, rd, vec3(-1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(-1.0, 0.0, 0.0);
          texCoord = vec2(1.0 - (hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Floor (y = -roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, 1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      // Ceiling (y = roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, -1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, -1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, 1.0 - (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      vec3 color = vec3(0.0);
      
      if (tMin < 1000.0) {
        vec3 hitPos = ro + rd * tMin;
        
        // Sample texture
        texCoord = clamp(texCoord, 0.0, 1.0);
        vec3 texColor = texture2D(uTexture, texCoord).rgb;
        
        // Lighting
        vec3 toLight = lightPos - hitPos;
        float lightDist = length(toLight);
        vec3 lightDir = toLight / lightDist;
        
        // Diffuse
        float diff = max(dot(hitNormal, lightDir), 0.0);
        
        // Attenuation
        float attenuation = 1.0 / (1.0 + 0.1 * lightDist + 0.05 * lightDist * lightDist);
        
        // Ambient
        float ambient = 0.25;
        
        color = texColor * (ambient + diff * attenuation * 1.5);
      }
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnS(ctx: FnContext, j: number, size: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const popcount = (n: number): number => {
    let count = 0;
    while (n) {
      count += n & 1;
      n >>= 1;
    }
    return count;
  };
  
  const resolution = Math.pow(2, Math.floor((size - 1) / 10) + 2);
  
  const centerX = ctx.width / 2;
  const centerY = ctx.height / 2;
  const triHeight = Math.min(ctx.width, ctx.height) * 0.95;
  const triWidth = triHeight / (Math.sqrt(3) / 2);
  
  const v0x = centerX, v0y = centerY - triHeight / 2;
  const v1x = centerX - triWidth / 2, v1y = centerY + triHeight / 2;
  const v2x = centerX + triWidth / 2, v2y = centerY + triHeight / 2;
  
  const denom = (v1y - v2y) * (v0x - v2x) + (v2x - v1x) * (v0y - v2y);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const baryA = ((v1y - v2y) * (x - v2x) + (v2x - v1x) * (y - v2y)) / denom;
      const baryB = ((v2y - v0y) * (x - v2x) + (v0x - v2x) * (y - v2y)) / denom;
      const baryC = 1 - baryA - baryB;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (baryA < 0 || baryB < 0 || baryC < 0) {
        setPixel(out, x, y, pr, pg, pb);
        continue;
      }
      
      const ai = Math.floor(baryA * resolution);
      const bi = Math.floor(baryB * resolution);
      const ci = Math.floor(baryC * resolution);
      
      const overlap = (ai & bi) | (bi & ci) | (ai & ci);
      const level = popcount(overlap) % 6;
      
      const [or, og, ob] = getPixel(old, x, y);
      
      let r: number, g: number, b: number;
      
      switch (level) {
        case 0: {
          r = or; g = og; b = ob;
          break;
        }
        case 1: {
          r = 255 - pr; g = 255 - pg; b = 255 - pb;
          break;
        }
        case 2: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 120) % 360, s, l);
          break;
        }
        case 3: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 240) % 360, s, l);
          break;
        }
        case 4: {
          const gray = Math.round(pr * 0.299 + pg * 0.587 + pb * 0.114);
          const contrast = gray < 128 ? gray * 0.5 : 128 + (gray - 128) * 1.5;
          r = g = b = Math.max(0, Math.min(255, Math.round(contrast)));
          break;
        }
        case 5: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 60) % 360, Math.min(1, s * 1.5), l);
          break;
        }
        default:
          r = pr; g = pg; b = pb;
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewLeft(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (1 - 2 * y / ctx.height);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewRight(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (2 * y / ctx.height - 1);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnT(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numCubes = Math.max(1, n + 1);
  const seed = ctx.images.length * 137.5 + n * 17.0;
  const hash = (i: number) => {
    const x = Math.sin(i + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  interface CubeData {
    cx: number; cy: number; hw: number; hh: number; depth: number;
  }
  const cubesData: CubeData[] = [];
  for (let i = 0; i < numCubes; i++) {
    cubesData.push({
      cx: hash(i * 127.1),
      cy: hash(i * 311.7),
      hw: 0.03 + hash(i * 74.3) * 0.08,
      hh: 0.025 + hash(i * 183.9) * 0.06,
      depth: 0.1 + hash(i * 271.3) * 0.2
    });
  }
  
  const lightDirX = -0.3;
  const lightDirY = -0.4;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec4 worldPos = uModel * vec4(aPosition, 1.0);
      vWorldPos = worldPos.xyz;
      vNormal = mat3(uModel) * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * uView * worldPos;
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightDir;
    uniform float uIsBackground;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec3 color = texture2D(uTexture, vTexCoord).rgb;
      
      if (uIsBackground > 0.5) {
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(uLightDir);
        
        float ambient = 0.5;
        float diffuse = max(dot(normal, lightDir), 0.0) * 0.5;
        float lighting = ambient + diffuse;
        
        gl_FragColor = vec4(color * lighting, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  function createBox(cx: number, cy: number, hw: number, hh: number, depth: number): { vertices: number[], normals: number[], texCoords: number[] } {
    const x0 = cx - hw, x1 = cx + hw;
    const y0 = cy - hh, y1 = cy + hh;
    const z0 = 0, z1 = depth;
    
    const u0 = cx - hw, u1 = cx + hw;
    const v0 = cy - hh, v1 = cy + hh;
    
    const vertices: number[] = [];
    const normals: number[] = [];
    const texCoords: number[] = [];
    
    // Top face - textured with image at this position
    vertices.push(x0,y0,z1, x1,y0,z1, x1,y1,z1, x0,y0,z1, x1,y1,z1, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(0,0,1);
    texCoords.push(u0,v0, u1,v0, u1,v1, u0,v0, u1,v1, u0,v1);
    
    // Right face (+x)
    vertices.push(x1,y0,z0, x1,y0,z1, x1,y1,z1, x1,y0,z0, x1,y1,z1, x1,y1,z0);
    for(let i=0;i<6;i++) normals.push(1,0,0);
    texCoords.push(u1,v0, u1,v0, u1,v1, u1,v0, u1,v1, u1,v1);
    
    // Left face (-x)
    vertices.push(x0,y0,z1, x0,y0,z0, x0,y1,z0, x0,y0,z1, x0,y1,z0, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(-1,0,0);
    texCoords.push(u0,v0, u0,v0, u0,v1, u0,v0, u0,v1, u0,v1);
    
    // Front face (+y)
    vertices.push(x0,y1,z1, x1,y1,z1, x1,y1,z0, x0,y1,z1, x1,y1,z0, x0,y1,z0);
    for(let i=0;i<6;i++) normals.push(0,1,0);
    texCoords.push(u0,v1, u1,v1, u1,v1, u0,v1, u1,v1, u0,v1);
    
    // Back face (-y)
    vertices.push(x0,y0,z0, x1,y0,z0, x1,y0,z1, x0,y0,z0, x1,y0,z1, x0,y0,z1);
    for(let i=0;i<6;i++) normals.push(0,-1,0);
    texCoords.push(u0,v0, u1,v0, u1,v0, u0,v0, u1,v0, u0,v0);
    
    return { vertices, normals, texCoords };
  }
  
  const allVertices: number[] = [];
  const allNormals: number[] = [];
  const allTexCoords: number[] = [];
  
  for (const c of cubesData) {
    const box = createBox(c.cx, c.cy, c.hw, c.hh, c.depth);
    allVertices.push(...box.vertices);
    allNormals.push(...box.normals);
    allTexCoords.push(...box.texCoords);
  }
  
  gl.useProgram(program);
  gl.disable(gl.DEPTH_TEST);
  
  const bgVertices = new Float32Array([0,0,0, 1,0,0, 1,1,0, 0,0,0, 1,1,0, 0,1,0]);
  const bgNormals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]);
  const bgTexCoords = new Float32Array([0,0, 1,0, 1,1, 0,0, 1,1, 0,1]);
  
  const posLoc = gl.getAttribLocation(program, 'aPosition');
  const normLoc = gl.getAttribLocation(program, 'aNormal');
  const texLoc = gl.getAttribLocation(program, 'aTexCoord');
  
  const identity = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  const ortho = new Float32Array([2,0,0,0, 0,2,0,0, 0,0,-1,0, -1,-1,0,1]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, ortho);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, identity);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uModel'), false, identity);
  gl.uniform3f(gl.getUniformLocation(program, 'uLightDir'), lightDirX, lightDirY, 1.0);
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 1.0);
  
  const bgPosBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgPosBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgNormBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgNormBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgNormals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgTexBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgTexCoords, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 2.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const perspective = new Float32Array([
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)/(near-far), -1,
    0, 0, (2*far*near)/(near-far), 0
  ]);
  
  const camZ = 0.5 / Math.tan(fov / 2);
  const view = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -0.5, -0.5, -camZ, 1
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, perspective);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, view);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 0.0);
  
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const normBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const texBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allTexCoords), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, allVertices.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = (y * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.disable(gl.DEPTH_TEST);
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(bgPosBuf);
  gl.deleteBuffer(bgNormBuf);
  gl.deleteBuffer(bgTexBuf);
  gl.deleteBuffer(posBuf);
  gl.deleteBuffer(normBuf);
  gl.deleteBuffer(texBuf);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnU(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const amplitude = n * 5;
  const frequency = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    let rowLuminance = 0;
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      rowLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    rowLuminance /= ctx.width;
    const phase = (rowLuminance / 255) * Math.PI * 2;
    
    for (let x = 0; x < ctx.width; x++) {
      const wave = Math.sin((y / ctx.height) * Math.PI * 2 * frequency + phase) * amplitude;
      const sx = ((x + wave) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnV(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [tr, tg, tb] = hexToRgb(c);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy) * 0.7;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const vignette = Math.max(0, 1 - Math.pow(dist / maxR, 2));
      const darken = vignette;
      const tint = 1 - vignette;
      
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * darken + tr * tint * 0.5);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * darken + tg * tint * 0.5);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * darken + tb * tint * 0.5);
    }
  }
  
  return out;
}

function fnW(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const maxRotation = (n * 20) * (Math.PI / 180);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const falloff = (1 - normDist) * (1 - normDist);
      const rotation = maxRotation * falloff;
      
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const sx = cx + dx * cos - dy * sin;
      const sy = cy + dx * sin + dy * cos;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnX(ctx: FnContext, k: number, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const shapes = [
    '★', '●', '■', '▲', '◆', '♥', '✦', '⬡', '✚', '◐', '☽', '⚡', '∞', '☀', '✿', '⬢',
    '◯', '△', '□', '◇', '♦', '♣', '♠', '⬟', '⬠', '▽', '◁', '▷', '⊕', '⊗', '⊛', '⊚',
    '▣', '▤', '▥', '▦', '▧', '▨', '▩', '⬣', '⬤', '◉', '◎', '◈', '◊', '○', '◌', '◍',
    '◢', '◣', '◤', '◥', '♯', '♮', '♩', '♪', '✶', '✴', '✳', '✲', '✱', '✰', '✯', '✮'
  ];
  
  const shapeIdx = Math.abs(k) % 64;
  const symbol = shapes[shapeIdx];
  
  const size = Math.min(ctx.width, ctx.height) * 0.9;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = 'black';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  tempCtx.fillStyle = 'white';
  tempCtx.font = `${size}px serif`;
  tempCtx.textAlign = 'center';
  tempCtx.textBaseline = 'alphabetic';
  
  const metrics = tempCtx.measureText(symbol);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const yOffset = metrics.actualBoundingBoxAscent - actualHeight / 2;
  
  tempCtx.fillText(symbol, ctx.width / 2, ctx.height / 2 + yOffset);
  
  const maskData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  
  let avgR = 0, avgG = 0, avgB = 0;
  for (let i = 0; i < prev.data.length; i += 4) {
    avgR += prev.data[i];
    avgG += prev.data[i + 1];
    avgB += prev.data[i + 2];
  }
  const numPixels = prev.data.length / 4;
  avgR = Math.round(avgR / numPixels);
  avgG = Math.round(avgG / numPixels);
  avgB = Math.round(avgB / numPixels);
  
  for (let y = 0; y < ctx.height; y++) {
    const t = y / ctx.height;
    
    const gr = cr * (1 - t) + avgR * t;
    const gg = cg * (1 - t) + avgG * t;
    const gb = cb * (1 - t) + avgB * t;
    
    for (let x = 0; x < ctx.width; x++) {
      const maskIdx = (y * ctx.width + x) * 4;
      if (maskData.data[maskIdx] > 128) {
        const [pr, pg, pb] = getPixel(prev, x, y);
        const nr = Math.round(gr * 0.9 + pr * 0.1);
        const ng = Math.round(gg * 0.9 + pg * 0.1);
        const nb = Math.round(gb * 0.9 + pb * 0.1);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnY(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const sections = Math.max(2, Math.min(n, 36));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const sectionIdx = Math.floor(angle / (Math.PI * 2) * sections);
      const hueShift = (sectionIdx / sections) * 360;
      
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnZ(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const blurAmount = n * 4;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const sharpRadius = 0.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      if (normDist < sharpRadius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const blurStrength = Math.min(1, (normDist - sharpRadius) / (1 - sharpRadius));
        const samples = Math.max(1, Math.floor(blurStrength * blurAmount / 2));
        
        let sumR = 0, sumG = 0, sumB = 0;
        for (let i = 0; i <= samples; i++) {
          const t = i / samples;
          const sx = cx + dx * (1 - t * blurStrength * 0.5);
          const sy = cy + dy * (1 - t * blurStrength * 0.5);
          const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
          sumR += r;
          sumG += g;
          sumB += b;
        }
        
        setPixel(out, x, y, 
          Math.round(sumR / (samples + 1)),
          Math.round(sumG / (samples + 1)),
          Math.round(sumB / (samples + 1))
        );
      }
    }
  }
  
  return out;
}

function fnQ(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const temp = createSolidImage(hw, hh, '#000000');
  
  for (let y = 0; y < hh; y++) {
    for (let x = 0; x < hw; x++) {
      const sx = (x / hw) * prev.width;
      const sy = (y / hh) * prev.height;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      if (x / hw + y / hh > 1) {
        setPixel(temp, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(temp, x, y, r, g, b);
      }
    }
  }
  
  for (let qy = 0; qy < 2; qy++) {
    for (let qx = 0; qx < 2; qx++) {
      for (let y = 0; y < hh; y++) {
        for (let x = 0; x < hw; x++) {
          const outX = qx * hw + x;
          const outY = qy * hh + y;
          if (outX < ctx.width && outY < ctx.height) {
            const [r, g, b] = getPixel(temp, x, y);
            setPixel(out, outX, outY, r, g, b);
          }
        }
      }
    }
  }
  
  return out;
}

function fn0(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const nr = pr < 128 ? (2 * pr * or) / 255 : 255 - (2 * (255 - pr) * (255 - or)) / 255;
      const ng = pg < 128 ? (2 * pg * og) / 255 : 255 - (2 * (255 - pg) * (255 - og)) / 255;
      const nb = pb < 128 ? (2 * pb * ob) / 255 : 255 - (2 * (255 - pb) * (255 - ob)) / 255;
      
      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
    }
  }
  
  return out;
}

function fn1(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const barStart = Math.floor(ctx.width / 3);
  const barEnd = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (x >= barStart && x < barEnd) {
        let sr = 0, sg = 0, sb = 0;
        const kernel = [
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0]
        ];
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = kernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        sr = Math.max(0, Math.min(255, sr));
        sg = Math.max(0, Math.min(255, sg));
        sb = Math.max(0, Math.min(255, sb));
        
        const contrast = 1.3;
        sr = Math.max(0, Math.min(255, ((sr / 255 - 0.5) * contrast + 0.5) * 255));
        sg = Math.max(0, Math.min(255, ((sg / 255 - 0.5) * contrast + 0.5) * 255));
        sb = Math.max(0, Math.min(255, ((sb / 255 - 0.5) * contrast + 0.5) * 255));
        
        setPixel(out, x, y, Math.round(sr), Math.round(sg), Math.round(sb));
      } else {
        const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
        setPixel(out, x, y, gray, gray, gray);
      }
    }
  }
  
  return out;
}

function fn2(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const len = ctx.images.length;
  const img3 = len >= 3 ? ctx.images[len - 3] : (len >= 1 ? ctx.images[0] : prev);
  const img2 = len >= 2 ? ctx.images[len - 2] : prev;
  const img1 = prev;
  
  const third1 = Math.floor(ctx.width / 3);
  const third2 = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let src: Image;
      if (x < third1) {
        src = img3;
      } else if (x < third2) {
        src = img2;
      } else {
        src = img1;
      }
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn3(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripWidth = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < stripWidth; x++) {
      const srcX = Math.floor((y / ctx.height) * stripWidth);
      const srcY = Math.floor(((stripWidth - 1 - x) / stripWidth) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth; x < stripWidth * 2; x++) {
      const srcX = Math.floor(((x - stripWidth) / stripWidth) * stripWidth + stripWidth);
      const srcY = y;
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth * 2; x < ctx.width; x++) {
      const localX = x - stripWidth * 2;
      const srcX = Math.floor(((ctx.height - 1 - y) / ctx.height) * (ctx.width - stripWidth * 2) + stripWidth * 2);
      const srcY = Math.floor((localX / (ctx.width - stripWidth * 2)) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn4(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const rotatePoint = (x: number, y: number, cx: number, cy: number, angle: number): [number, number] => {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
  };
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const qx = x < hw ? 0 : 1;
      const qy = y < hh ? 0 : 1;
      const quadrant = qy * 2 + qx;
      const angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2];
      const angle = angles[quadrant];
      
      const localCx = qx === 0 ? hw / 2 : hw + hw / 2;
      const localCy = qy === 0 ? hh / 2 : hh + hh / 2;
      
      const [srcX, srcY] = rotatePoint(x, y, localCx, localCy, -angle);
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnD(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const n = 7;
  const numDrips = Math.max(1, n * 3);
  const dripStrength = Math.max(0.5, Math.min(n * 0.2 + 0.8, 2.0));
  const seed = ctx.images.length * 137.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uStrength;
    uniform int uNumDrips;
    uniform float uSeed;
    varying vec2 vUV;
    
    #define MAX_DRIPS 100
    #define MAX_STEPS 64
    #define WALL_Z 0.0
    #define EPS 0.001
    
    float hash(float n) {
      return fract(sin(n) * 43758.5453123);
    }
    
    // Smooth min for organic blending
    float smin(float a, float b, float k) {
      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
      return mix(b, a, h) - k * h * (1.0 - h);
    }
    
    // Simple sphere SDF
    float sdSphere(vec3 p, vec3 center, float r) {
      return length(p - center) - r;
    }
    
    // Scene SDF - randomly distributed clusters of 4 metaballs each
    float sceneSDF(vec3 p, int numClusters, float strength) {
      float d = 1000.0;
      
      for (int i = 0; i < MAX_DRIPS; i++) {
        if (i >= numClusters) break;
        
        float fi = float(i);
        
        // Random cluster center position across full screen (seeded by image count)
        float clusterX = (hash(fi * 127.1 + uSeed) * 2.0 - 1.0) * 1.5;
        float clusterY = (hash(fi * 311.7 + uSeed) * 2.0 - 1.0) * 1.2;
        
        // Cluster size
        float clusterSize = 0.15 + hash(fi * 74.3 + uSeed) * 0.15;
        
        // 4 balls per cluster (fixed to avoid dynamic loop issues)
        for (int j = 0; j < 4; j++) {
          float fj = float(j);
          float localSeed = fi * 100.0 + fj + uSeed;
          
          // Random offset from cluster center
          float offX = (hash(localSeed * 123.4) - 0.5) * clusterSize;
          float offY = (hash(localSeed * 234.5) - 0.5) * clusterSize * 1.5; // More vertical spread
          
          float x = clusterX + offX;
          float y = clusterY + offY;
          
          // Varying ball sizes within cluster
          float r = (0.06 + hash(localSeed * 345.6) * 0.08) * strength * 0.6;
          
          float z = 0.05 + r * 0.3;
          
          vec3 center = vec3(x, y, z);
          float sphere = sdSphere(p, center, r);
          
          // Smooth blend to merge balls in cluster
          d = smin(d, sphere, 0.12);
        }
      }
      
      return d;
    }
    
    // Calculate normal via gradient
    vec3 calcNormal(vec3 p, int numDrips, float strength) {
      vec2 e = vec2(0.001, 0.0);
      return normalize(vec3(
        sceneSDF(p + e.xyy, numDrips, strength) - sceneSDF(p - e.xyy, numDrips, strength),
        sceneSDF(p + e.yxy, numDrips, strength) - sceneSDF(p - e.yxy, numDrips, strength),
        sceneSDF(p + e.yyx, numDrips, strength) - sceneSDF(p - e.yyx, numDrips, strength)
      ));
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Ray origin and direction (orthographic-ish camera)
      vec3 ro = vec3((uv.x * 2.0 - 1.0) * aspect, uv.y * 2.0 - 1.0, 2.0);
      vec3 rd = vec3(0.0, 0.0, -1.0);
      
      // Raymarch to find metaball surface
      float t = 0.0;
      float d = 0.0;
      bool hit = false;
      vec3 p;
      
      for (int i = 0; i < MAX_STEPS; i++) {
        p = ro + rd * t;
        d = sceneSDF(p, uNumDrips, uStrength);
        
        if (d < EPS) {
          hit = true;
          break;
        }
        if (t > 4.0) break;
        
        t += d * 0.8;
      }
      
      // Sample wall texture
      vec4 wallColor = texture2D(uTexture, uv);
      
      if (hit) {
        vec3 normal = calcNormal(p, uNumDrips, uStrength);
        
        // Light from top (Y is flipped in screen coords)
        vec3 lightDir = normalize(vec3(0.0, -1.0, 0.6));
        vec3 viewDir = -rd;
        
        // Fresnel - edges reflect more
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
        
        // Specular highlight - bright and sharp
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 120.0);
        
        // Refraction - water has IOR ~1.33, so ratio is 1.0/1.33 ≈ 0.75
        vec3 refracted = refract(rd, normal, 0.75);
        vec2 refractUV = uv + refracted.xy * 0.06;
        refractUV = clamp(refractUV, 0.0, 1.0);
        vec4 refractColor = texture2D(uTexture, refractUV);
        
        // Clear water droplet - mostly shows refracted background
        vec3 dropletColor = refractColor.rgb;
        
        // Slight caustic brightening where light focuses
        float caustic = max(dot(normal, lightDir), 0.0);
        dropletColor *= 1.0 + caustic * 0.15;
        
        // Add crisp specular highlight
        dropletColor += vec3(1.0) * spec * 1.5;
        
        // Subtle rim highlight from fresnel
        dropletColor += vec3(1.0) * fresnel * 0.2;
        
        // Very subtle shadow directly under droplet on wall
        vec2 shadowUV = uv + vec2(0.01, 0.02);
        float shadowMask = smoothstep(0.05, 0.0, d) * 0.15;
        vec3 wallWithShadow = wallColor.rgb * (1.0 - shadowMask);
        
        // Droplet is almost fully transparent, just refracts
        gl_FragColor = vec4(dropletColor, 1.0);
      } else {
        gl_FragColor = wallColor;
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uStrength'), dripStrength);
  gl.uniform1i(gl.getUniformLocation(program, 'uNumDrips'), numDrips);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fn6(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const levels = 4;
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = Math.floor(out.data[i] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 1] = Math.floor(out.data[i + 1] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 2] = Math.floor(out.data[i + 2] / 256 * levels) * (255 / (levels - 1));
  }
  
  return out;
}

function fn7(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r] = getPixel(prev, x - 4, y);
      const [, g] = getPixel(prev, x, y);
      const [, , b] = getPixel(prev, x + 4, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn8(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.1, n / 5);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height) / 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / scale;
      const ny = (y - cy) / scale;
      
      const r2 = nx * nx + ny * ny;
      const denom = r2 + 1;
      
      const lemnX = nx * (r2 - 1) / denom;
      const lemnY = ny * (r2 + 1) / denom;
      
      const sx = cx + (nx + (lemnX - nx) * strength * 0.3) * scale;
      const sy = cy + (ny + (lemnY - ny) * strength * 0.3) * scale;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn9(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r1, g1, b1] = getPixel(prev, x, y);
      const [r2, g2, b2] = getPixel(old, x, y);
      
      setPixel(out, x, y, r1 ^ r2, g1 ^ g2, b1 ^ b2);
    }
  }
  
  return out;
}

function fnLessThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 8);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = (x + shift) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnGreaterThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = y * prev.width / ctx.height;
      const sy = (ctx.width - 1 - x) * prev.height / ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnCaret(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.height / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcY = (y + shift) % ctx.height;
      const [r, g, b] = getPixel(prev, x, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnExclaim(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const opacity = 0.3;
  const factor = n + 17;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
    }
  }
  
  return out;
}

function fnDoubleQuote(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const bands = Math.max(2, n);
  const bandHeight = ctx.height / bands;
  
  for (let y = 0; y < ctx.height; y++) {
    const bandIdx = Math.floor(y / bandHeight);
    const isOdd = bandIdx % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (isOdd) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnHash(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const gridSize = Math.max(2, n + 2);
  
  const getCellBounds = (gx: number, gy: number): [number, number, number, number] => {
    const x0 = Math.floor(gx * ctx.width / gridSize);
    const x1 = Math.floor((gx + 1) * ctx.width / gridSize);
    const y0 = Math.floor(gy * ctx.height / gridSize);
    const y1 = Math.floor((gy + 1) * ctx.height / gridSize);
    return [x0, y0, x1, y1];
  };
  
  const cells: { gx: number; gy: number; hue: number }[] = [];
  
  for (let gy = 0; gy < gridSize; gy++) {
    for (let gx = 0; gx < gridSize; gx++) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      const [x0, y0, x1, y1] = getCellBounds(gx, gy);
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
        }
      }
      
      const avgR = count > 0 ? sumR / count : 0;
      const avgG = count > 0 ? sumG / count : 0;
      const avgB = count > 0 ? sumB / count : 0;
      const [hue] = rgbToHsl(avgR, avgG, avgB);
      
      cells.push({ gx, gy, hue });
    }
  }
  
  const sortedIndices = cells.map((_, i) => i).sort((a, b) => cells[a].hue - cells[b].hue);
  
  for (let i = 0; i < sortedIndices.length; i++) {
    const srcIdx = sortedIndices[i];
    const srcCell = cells[srcIdx];
    const [sx0, sy0, sx1, sy1] = getCellBounds(srcCell.gx, srcCell.gy);
    const srcW = sx1 - sx0;
    const srcH = sy1 - sy0;
    
    const targetGX = i % gridSize;
    const targetGY = Math.floor(i / gridSize);
    const [tx0, ty0, tx1, ty1] = getCellBounds(targetGX, targetGY);
    const targetW = tx1 - tx0;
    const targetH = ty1 - ty0;
    
    for (let ty = ty0; ty < ty1; ty++) {
      for (let tx = tx0; tx < tx1; tx++) {
        const srcX = sx0 + Math.floor((tx - tx0) * srcW / targetW);
        const srcY = sy0 + Math.floor((ty - ty0) * srcH / targetH);
        const [r, g, b] = getPixel(prev, srcX, srcY);
        setPixel(out, tx, ty, r, g, b);
      }
    }
  }
  
  return out;
}

function fnDollar(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const w = ctx.width;
  const h = ctx.height;
  
  const threshold = 12;
  
  const labels = new Int32Array(w * h);
  labels.fill(-1);
  
  const colorDist = (x1: number, y1: number, x2: number, y2: number): number => {
    const [r1, g1, b1] = getPixel(prev, x1, y1);
    const [r2, g2, b2] = getPixel(prev, x2, y2);
    return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
  };
  
  let currentLabel = 0;
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const idx = y * w + x;
      if (labels[idx] !== -1) continue;
      
      const queue: [number, number][] = [[x, y]];
      labels[idx] = currentLabel;
      
      while (queue.length > 0) {
        const [cx, cy] = queue.shift()!;
        
        const neighbors = [
          [cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]
        ];
        
        for (const [nx, ny] of neighbors) {
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
          const nidx = ny * w + nx;
          if (labels[nidx] !== -1) continue;
          
          if (colorDist(cx, cy, nx, ny) < threshold) {
            labels[nidx] = currentLabel;
            queue.push([nx, ny]);
          }
        }
      }
      
      currentLabel++;
    }
  }
  
  const segments = new Map<number, { x: number; y: number; r: number; g: number; b: number; hue: number }[]>();
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const label = labels[y * w + x];
      const [r, g, b] = getPixel(prev, x, y);
      const [hue] = rgbToHsl(r, g, b);
      
      if (!segments.has(label)) {
        segments.set(label, []);
      }
      segments.get(label)!.push({ x, y, r, g, b, hue });
    }
  }
  
  for (const [, pixels] of segments) {
    pixels.sort((a, b) => a.hue - b.hue);
    
    const positions = pixels.map(p => ({ x: p.x, y: p.y }));
    positions.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    
    for (let i = 0; i < pixels.length; i++) {
      const color = pixels[i];
      const pos = positions[i];
      setPixel(out, pos.x, pos.y, color.r, color.g, color.b);
    }
  }
  
  return out;
}

function fnPercent(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(1, n + 1);
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  const palette = corners.map(([r, g, b]) => [r, g, b] as [number, number, number]);
  
  const findClosest = (r: number, g: number, b: number): [number, number, number] => {
    let minDist = Infinity;
    let closest = palette[0];
    for (const [pr, pg, pb] of palette) {
      const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
      if (dist < minDist) {
        minDist = dist;
        closest = [pr, pg, pb];
      }
    }
    return closest;
  };
  
  const tempData = new Float32Array(ctx.width * ctx.height * 3);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = (y * ctx.width + x) * 3;
      tempData[idx] = r;
      tempData[idx + 1] = g;
      tempData[idx + 2] = b;
    }
  }
  
  for (let y = 0; y < ctx.height; y += cellSize) {
    for (let x = 0; x < ctx.width; x += cellSize) {
      const idx = (y * ctx.width + x) * 3;
      const oldR = tempData[idx];
      const oldG = tempData[idx + 1];
      const oldB = tempData[idx + 2];
      
      const [newR, newG, newB] = findClosest(oldR, oldG, oldB);
      
      for (let cy = 0; cy < cellSize && y + cy < ctx.height; cy++) {
        for (let cx = 0; cx < cellSize && x + cx < ctx.width; cx++) {
          setPixel(out, x + cx, y + cy, newR, newG, newB);
        }
      }
      
      const errR = oldR - newR;
      const errG = oldG - newG;
      const errB = oldB - newB;
      
      const distribute = (dx: number, dy: number, factor: number) => {
        const nx = x + dx * cellSize;
        const ny = y + dy * cellSize;
        if (nx >= 0 && nx < ctx.width && ny >= 0 && ny < ctx.height) {
          const nidx = (ny * ctx.width + nx) * 3;
          tempData[nidx] += errR * factor;
          tempData[nidx + 1] += errG * factor;
          tempData[nidx + 2] += errB * factor;
        }
      };
      
      distribute(1, 0, 7 / 16);
      distribute(-1, 1, 3 / 16);
      distribute(0, 1, 5 / 16);
      distribute(1, 1, 1 / 16);
    }
  }
  
  return out;
}

function fnAmpersand(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const luminance = pr * 0.299 + pg * 0.587 + pb * 0.114;
      const [oh, os, ol] = rgbToHsl(or, og, ob);
      const [nr, ng, nb] = hslToRgb(oh, os, luminance / 255);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnApostrophe(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const spacing = n + 2;
  
  for (let x = 0; x < ctx.width; x++) {
    if (x % spacing !== 0) continue;
    
    let colLuminance = 0;
    for (let y = 0; y < ctx.height; y++) {
      const [r, g, b] = getPixel(prev, x, y);
      colLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    colLuminance /= ctx.height;
    
    const streakLength = Math.floor((colLuminance / 255) * 100);
    const startY = 0;
    
    for (let y = startY; y < startY + streakLength && y < ctx.height; y++) {
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * 0.5 + 127));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * 0.5 + 127));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * 0.5 + 127));
    }
  }
  
  return out;
}

function fnOpenParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const pinchFactor = 1 + strength * (1 - normDist);
      const sx = cx + dx * pinchFactor;
      const sy = cy + dy * pinchFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const brighten = (1 - normDist) * strength * 30;
      r = Math.min(255, r + brighten);
      g = Math.min(255, g + brighten);
      b = Math.min(255, b + brighten);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnCloseParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const bulgeFactor = 1 - strength * normDist * 0.5;
      const sx = cx + dx * bulgeFactor;
      const sy = cy + dy * bulgeFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const darken = normDist * strength * 50;
      r = Math.max(0, r - darken);
      g = Math.max(0, g - darken);
      b = Math.max(0, b - darken);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnAsterisk(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRays = Math.max(2, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const opacity = 0.6;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const rayAngle = (Math.PI * 2) / numRays;
      const nearestRay = Math.round(angle / rayAngle) * rayAngle;
      const angleDiff = Math.abs(angle - nearestRay);
      
      const rayWidth = 0.05;
      if (angleDiff < rayWidth) {
        const softness = 1 - angleDiff / rayWidth;
        const sampleX = Math.floor(cx + Math.cos(nearestRay) * (ctx.width / numRays));
        const [sr, sg, sb] = getPixel(prev, sampleX, Math.floor(cy));
        
        const idx = (y * ctx.width + x) * 4;
        const blend = softness * opacity;
        out.data[idx] = Math.round(out.data[idx] * (1 - blend) + sr * blend);
        out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - blend) + sg * blend);
        out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - blend) + sb * blend);
      }
    }
  }
  
  return out;
}

function fnPlus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const zoom = 1.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = cx + (x - cx) / zoom;
      const sy = cy + (y - cy) / zoom;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnComma(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = Math.floor(r * 0.299 + g * 0.587 + b * 0.114);
      const divisor = 1 + Math.floor(luminance / 32);
      
      if ((x * 13 + y * 7) % divisor === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnMinus(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const spacing = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let [r, g, b] = getPixel(prev, x, y);
      
      if (y % spacing === 0) {
        r = Math.floor(r * 0.5);
        g = Math.floor(g * 0.5);
        b = Math.floor(b * 0.5);
      }
      
      if (y % (spacing * 2) === 0) {
        const srcY = Math.max(0, y - spacing);
        [r, g, b] = getPixel(prev, x, srcY);
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnDot(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const radius = (n % 8) + 2;
  const diameter = radius * 2;
  
  for (let cy = radius; cy < ctx.height; cy += diameter) {
    for (let cx = radius; cx < ctx.width; cx += diameter) {
      const [r, g, b] = getPixel(prev, cx, cy);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb(h, Math.min(1, s + 0.1), l);
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx * dx + dy * dy <= radius * radius) {
            setPixel(out, cx + dx, cy + dy, nr, ng, nb);
          }
        }
      }
    }
  }
  
  return out;
}

function fnSlash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = (x + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnColon(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const numCircles = Math.max(1, Math.min(n, 10));
  const circleRadius = Math.min(ctx.width / (numCircles * 3), ctx.height / 4);
  const blurRadius = 5;
  
  const blurred = createSolidImage(ctx.width, ctx.height, '#000000');
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let sr = 0, sg = 0, sb = 0, count = 0;
      for (let ky = -blurRadius; ky <= blurRadius; ky++) {
        for (let kx = -blurRadius; kx <= blurRadius; kx++) {
          const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
          sr += pr;
          sg += pg;
          sb += pb;
          count++;
        }
      }
      setPixel(blurred, x, y, Math.round(sr / count), Math.round(sg / count), Math.round(sb / count));
    }
  }
  
  const circleCenters: [number, number][] = [];
  for (let i = 0; i < numCircles; i++) {
    const cx = Math.floor((i + 0.5) * ctx.width / numCircles);
    const cy = Math.floor(ctx.height / 2);
    circleCenters.push([cx, cy]);
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let inCircle = false;
      for (const [cx, cy] of circleCenters) {
        const dx = x - cx;
        const dy = y - cy;
        if (dx * dx + dy * dy < circleRadius * circleRadius) {
          const srcX = cx + dx * 0.5;
          const srcY = cy + dy * 0.5;
          const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
          setPixel(out, x, y, r, g, b);
          inCircle = true;
          break;
        }
      }
      if (!inCircle) {
        const [r, g, b] = getPixel(blurred, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnSemicolon(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const radius = Math.min(cx, cy) * 0.9;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (y < cy && dist < radius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (y >= cy) {
        const mirrorY = 2 * cy - y;
        const mirrorDx = x - cx;
        const mirrorDy = mirrorY - cy;
        const mirrorDist = Math.sqrt(mirrorDx * mirrorDx + mirrorDy * mirrorDy);
        
        if (mirrorDist < radius) {
          const wave = Math.sin(x * 0.1) * 10;
          const srcY = Math.floor(mirrorY + wave);
          const [r, g, b] = getPixel(prev, x, Math.max(0, Math.min(ctx.height - 1, srcY)));
          setPixel(out, x, y, r, g, b);
        }
      }
    }
  }
  
  return out;
}

function fnEquals(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripeHeight = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const stripeIdx = Math.floor(y / stripeHeight);
    const isOdd = stripeIdx % 2 === 1;
    const shift = isOdd ? stripeIdx * 5 : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = ((x + shift) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnQuestion(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  
  let sum = 0;
  for (const [r, g, b] of corners) {
    sum += r + g + b;
  }
  const effect = sum % 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (effect === 0) {
        const sr = r < 128 ? r : 255 - r;
        const sg = g < 128 ? g : 255 - g;
        const sb = b < 128 ? b : 255 - b;
        setPixel(out, x, y, sr * 2, sg * 2, sb * 2);
      } else if (effect === 1) {
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const weight = (kx === 0 && ky === 0) ? 8 : -1;
            gx += gray * weight;
          }
        }
        const embossVal = Math.max(0, Math.min(255, 128 + gx / 4));
        setPixel(out, x, y, embossVal, embossVal, embossVal);
      } else if (effect === 2) {
        const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
        const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const kidx = (ky + 1) * 3 + (kx + 1);
            gx += gray * sobelX[kidx];
            gy += gray * sobelY[kidx];
          }
        }
        const mag = Math.min(255, Math.sqrt(gx * gx + gy * gy));
        setPixel(out, x, y, mag, mag, mag);
      } else {
        const levels = 4;
        const pr = Math.floor(r / 256 * levels) * (255 / (levels - 1));
        const pg = Math.floor(g / 256 * levels) * (255 / (levels - 1));
        const pb = Math.floor(b / 256 * levels) * (255 / (levels - 1));
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

function fnOpenBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const angle = -20 * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const srcX = cx + dx * cos - dy * sin;
      const srcY = cy + dx * sin + dy * cos;
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnBackslash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = ((ctx.width - 1 - x) + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnCloseBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const offset = Math.floor(ctx.height * 0.2);
  const midX = Math.floor(ctx.width / 2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX) {
        const srcY = (y + offset) % ctx.height;
        const [r, g, b] = getPixel(prev, x, srcY);
        setPixel(out, x, y, r, g, b);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnUnderscore(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const reflectHeight = Math.floor(ctx.height * n * 0.05);
  const startY = ctx.height - reflectHeight;
  
  for (let y = startY; y < ctx.height; y++) {
    const mirrorY = 2 * startY - y - 1;
    const wave = Math.sin(y * 0.1) * 5;
    
    for (let x = 0; x < ctx.width; x++) {
      if (mirrorY >= 0 && mirrorY < ctx.height) {
        const srcX = Math.floor(((x + wave) % ctx.width + ctx.width) % ctx.width);
        const [r, g, b] = getPixel(prev, srcX, mirrorY);
        const idx = (y * ctx.width + x) * 4;
        out.data[idx] = Math.round(out.data[idx] * 0.5 + r * 0.5);
        out.data[idx + 1] = Math.round(out.data[idx + 1] * 0.5 + g * 0.5);
        out.data[idx + 2] = Math.round(out.data[idx + 2] * 0.5 + b * 0.5);
      }
    }
  }
  
  return out;
}

function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const glitchN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const shouldGlitch = (y * 17) % 23 < glitchN;
    const shiftAmount = shouldGlitch ? ((y * 31) % (glitchN * 20)) : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      if (shouldGlitch) {
        const srcXR = ((x - shiftAmount - glitchN) % ctx.width + ctx.width) % ctx.width;
        const srcXG = ((x - shiftAmount) % ctx.width + ctx.width) % ctx.width;
        const srcXB = ((x - shiftAmount + glitchN) % ctx.width + ctx.width) % ctx.width;
        
        const [rr] = getPixel(prev, srcXR, y);
        const [, gg] = getPixel(prev, srcXG, y);
        const [, , bb] = getPixel(prev, srcXB, y);
        
        setPixel(out, x, y, rr, gg, bb);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnOpenBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x < 0.5) {
        float localX = uv.x * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnPipe(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const midX = Math.floor(ctx.width / 2);
  const blendWidth = 5;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX - blendWidth) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (x > midX + blendWidth) {
        const [r, g, b] = getPixel(old, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const t = (x - (midX - blendWidth)) / (blendWidth * 2);
        const [pr, pg, pb] = getPixel(prev, x, y);
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y,
          Math.round(pr * (1 - t) + or * t),
          Math.round(pg * (1 - t) + og * t),
          Math.round(pb * (1 - t) + ob * t)
        );
      }
    }
  }
  
  return out;
}

function fnCloseBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x > 0.5) {
        float localX = (uv.x - 0.5) * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(0.5 + newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnTilde(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const waveN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const amplitude = Math.sin(y * 0.05) * waveN * 8;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = Math.floor(((x + amplitude) % ctx.width + ctx.width) % ctx.width);
      
      const srcXR = Math.floor(((x + amplitude + waveN) % ctx.width + ctx.width) % ctx.width);
      const srcXB = Math.floor(((x + amplitude - waveN) % ctx.width + ctx.width) % ctx.width);
      
      const [rr] = getPixel(prev, srcXR, y);
      const [, gg] = getPixel(prev, srcX, y);
      const [, , bb] = getPixel(prev, srcXB, y);
      
      setPixel(out, x, y, rr, gg, bb);
    }
  }
  
  return out;
}

function fnHoles(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(pr, pg, pb);
      
      const midSat = s >= 0.35 && s <= 0.65;
      const midVal = l >= 0.35 && l <= 0.65;
      
      if (midSat || midVal) {
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y, or, og, ob);
      } else {
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

export const characterDefs: Record<string, CharDef> = {
  'A': {
    color: '#78A10F',
    number: 1,
    fn: fnA,
    arity: 0,
    argTypes: [],
    functionName: "sphere-overlay",
    documentation: "Renders prev as texture on two 3D spheres with lighting in top-right and bottom-left quadrants"
  },
  
  'B': {
    color: '#8B4513',
    number: 2,
    fn: fnV,
    arity: 1,
    argTypes: ['color'],
    functionName: "border",
    documentation: "Circular gradient darkening edges, tinted toward color c"
  },
  
  'C': {
    color: '#FF6B35',
    number: 3,
    fn: fnC,
    arity: 1,
    argTypes: ['int'],
    functionName: "concentric-hue",
    documentation: "Creates n concentric circles alternating between original and hue-shifted versions"
  },
  
  'D': {
    color: '#FF1493',
    number: 4,
    fn: fnD,
    arity: 0,
    argTypes: [],
    functionName: "drip",
    documentation: "Metaball-based dripping effect with blobby liquid drips"
  },
  
  'E': {
    color: '#50C878',
    number: 5,
    fn: fnE,
    arity: 0,
    argTypes: [],
    functionName: "emerald",
    documentation: "Renders bright reflective 3D emeralds in symmetric pattern with large center emerald"
  },
  
  'F': {
    color: '#FFD700',
    number: 6,
    fn: fnO,
    arity: 1,
    argTypes: ['int'],
    functionName: "fft-overflow",
    documentation: "2D FFT with magnitude overflow/wrap and per-channel phase shifts - creates banded halos and chromatic frequency ghosts"
  },
  
  'G': {
    color: '#9370DB',
    number: 7,
    fn: fnG,
    arity: 1,
    argTypes: ['int'],
    functionName: "grayscale-colorize",
    documentation: "Converts to grayscale then applies n-color rainbow palette based on brightness"
  },
  
  'H': {
    color: '#DC143C',
    number: 8,
    fn: fnH,
    arity: 0,
    argTypes: [],
    functionName: "hourglass",
    documentation: "Hourglass gradient: NAND blend inside hourglass shape, XOR/add/diff blend outside, creates colors from gradients"
  },
  
  'I': {
    color: '#00FF7F',
    number: 9,
    fn: fnI,
    arity: 0,
    argTypes: [],
    functionName: "invert-edges",
    documentation: "Inverts prev colors, then applies Sobel edge detection and draws edges in white"
  },
  
  'J': {
    color: '#FF8C00',
    number: 10,
    fn: fnF,
    arity: 1,
    argTypes: ['int'],
    functionName: "julia-fractal",
    documentation: "Julia set fractal masks prev - inside set shows prev, outside darkened; n controls zoom level"
  },
  
  'K': {
    color: '#4B0082',
    number: 11,
    fn: fnK,
    arity: 1,
    argTypes: ['int'],
    functionName: "kaleidoscope",
    documentation: "Creates n-way kaleidoscope effect centered on image with 1.1x zoom"
  },
  
  'L': {
    color: '#20B2AA',
    number: 12,
    fn: fnL,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "lissajous",
    documentation: "3D Lissajous tube textured with prev, old_image as background; j=old image, rot=rotation"
  },
  
  'M': {
    color: '#FF69B4',
    number: 13,
    fn: fnM,
    arity: 1,
    argTypes: ['int'],
    functionName: "moire",
    documentation: "Moiré interference pattern: 3 overlapping line grids create 8 zones with different hue/saturation/lightness shifts"
  },
  
  'N': {
    color: '#8A2BE2',
    number: 14,
    fn: fnN,
    arity: 0,
    argTypes: [],
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnApostrophe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-streaks",
    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
    documentation: "Pixelates with cell size n+1, diagonal split: top-left = average, bottom-right = most saturated"
  },
  
  'Q': {
    color: '#32CD32',
    number: 17,
    fn: fnQ,
    arity: 0,
    argTypes: [],
    functionName: "inverted-tile",
    documentation: "Splits prev diagonally, inverts bottom-right half, then tiles in four quadrants"
  },
  
  'R': {
    color: '#DA70D6',
    number: 18,
    fn: fnR,
    arity: 0,
    argTypes: [],
    functionName: "room",
    documentation: "3D room with three walls, ceiling, and floor textured with prev, lit from center"
  },
  
  'S': {
    color: '#87CEEB',
    number: 19,
    fn: fnS,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "sierpinski",
    documentation: "Sierpiński triangle fractal: j=old image for interior, size=detail level (1-68); outer shells get hue shifts, invert, grayscale"
  },
  
  'T': {
    color: '#F0E68C',
    number: 20,
    fn: fnT,
    arity: 1,
    argTypes: ['int'],
    functionName: "cubes",
    documentation: "n+1 3D cubes protrude from prev plane toward camera, tops textured from prev, sides use edge pixels, lit from front"
  },
  
  'U': {
    color: '#DDA0DD',
    number: 21,
    fn: fnU,
    arity: 1,
    argTypes: ['int'],
    functionName: "undulate",
    documentation: "Vertical wave distortion with amplitude n*5px, frequency n cycles, phase based on luminance"
  },
  
  'V': {
    color: '#40E0D0',
    number: 22,
    fn: fnB,
    arity: 1,
    argTypes: ['int'],
    functionName: "voronoi",
    documentation: "Breaks image into 36 voronoi cells, alternating between prev and old image"
  },
  
  'W': {
    color: '#EE82EE',
    number: 23,
    fn: fnW,
    arity: 1,
    argTypes: ['int'],
    functionName: "swirl",
    documentation: "Swirl distortion from center, rotation = n*45°, quadratic falloff"
  },
  
  'X': {
    color: '#F5DEB3',
    number: 24,
    fn: fnX,
    arity: 2,
    argTypes: ['int', 'color'],
    functionName: "shape-overlay",
    documentation: "Draws unicode shape k%64 at center in color c (★●■▲◆♥✦⬡✚◐☽⚡∞☀✿⬢...)"
  },
  
  'Y': {
    color: '#98FB98',
    number: 25,
    fn: fnY,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-hue",
    documentation: "Splits into n radial sections, each hue-rotated by i*(360/n)°"
  },
  
  'Z': {
    color: '#AFEEEE',
    number: 26,
    fn: fnZ,
    arity: 1,
    argTypes: ['int'],
    functionName: "zoom-blur",
    documentation: "Radial motion blur from center, blur amount n*4px, center 20% stays sharp"
  },
  
  '0': {
    color: '#E6E6FA',
    number: 27,
    fn: fn0,
    arity: 1,
    argTypes: ['int'],
    functionName: "overlay",
    documentation: "Overlay blend mode: combines prev with old_image at index j, darkening darks and lightening lights"
  },
  
  '1': {
    color: '#FFA07A',
    number: 28,
    fn: fn1,
    arity: 0,
    argTypes: [],
    functionName: "center-bar",
    documentation: "Middle third of image shows prev sharpened and contrast-boosted, rest is desaturated"
  },
  
  '2': {
    color: '#98D8C8',
    number: 29,
    fn: fn2,
    arity: 0,
    argTypes: [],
    functionName: "time-echo",
    documentation: "Left third shows 3rd previous image, middle shows 2nd previous, right shows prev - recent history triptych"
  },
  
  '3': {
    color: '#F7DC6F',
    number: 30,
    fn: fn3,
    arity: 0,
    argTypes: [],
    functionName: "triple-rotate",
    documentation: "Divides into 3 vertical strips; left rotated 90° CW, middle unchanged, right rotated 90° CCW"
  },
  
  '4': {
    color: '#BB8FCE',
    number: 31,
    fn: fn4,
    arity: 0,
    argTypes: [],
    functionName: "quad-rotate",
    documentation: "Divides into 2x2 quadrants, each rotated (0°, 90°, 180°, 270°)"
  },
  
  '5': {
    color: '#85C1E9',
    number: 32,
    fn: fn5,
    arity: 1,
    argTypes: ['int'],
    functionName: "triangular-split",
    documentation: "Splits prev into triangles based on cell width, each with hue shift and lightness variation"
  },
  
  '6': {
    color: '#F1948A',
    number: 33,
    fn: fn6,
    arity: 0,
    argTypes: [],
    functionName: "posterize",
    documentation: "Posterizes prev to 4 levels per channel"
  },
  
  '7': {
    color: '#82E0AA',
    number: 34,
    fn: fn7,
    arity: 0,
    argTypes: [],
    functionName: "chromatic",
    documentation: "Chromatic aberration: R shifted left 4px, G centered, B shifted right 4px"
  },
  
  '8': {
    color: '#F8C471',
    number: 35,
    fn: fn8,
    arity: 1,
    argTypes: ['int'],
    functionName: "lemniscate",
    documentation: "Infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along curve"
  },
  
  '9': {
    color: '#D7BDE2',
    number: 36,
    fn: fn9,
    arity: 1,
    argTypes: ['int'],
    functionName: "xor-blend",
    documentation: "XORs prev with old_image at index j, creating glitchy digital artifacts"
  },
  
  '<': {
    color: '#E74C3C',
    number: 37,
    fn: fnLessThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-left",
    documentation: "Shifts prev 1/3 of the width to the left with wraparound"
  },
  
  '>': {
    color: '#3498DB',
    number: 38,
    fn: fnGreaterThan,
    arity: 0,
    argTypes: [],
    functionName: "rotate-90",
    documentation: "Rotates prev 90 degrees clockwise"
  },
  
  '^': {
    color: '#2ECC71',
    number: 39,
    fn: fnCaret,
    arity: 0,
    argTypes: [],
    functionName: "shift-up",
    documentation: "Shifts prev 1/3 of the height up with wraparound"
  },
  
  '!': {
    color: '#FF4500',
    number: 40,
    fn: fnExclaim,
    arity: 1,
    argTypes: ['int'],
    functionName: "hash-overlay",
    documentation: "Overlays deterministic hash pattern where brightness = ((x*(n+17)) ^ (y*31) ^ (x*y)) % 256 at 30% opacity"
  },
  
  '"': {
    color: '#9932CC',
    number: 41,
    fn: fnDoubleQuote,
    arity: 1,
    argTypes: ['int'],
    functionName: "band-transform",
    documentation: "Splits into n horizontal bands; odd bands hue-rotated 180°, even bands have saturation inverted"
  },
  
  '#': {
    color: '#228B22',
    number: 42,
    fn: fnHash,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-sort-tiles",
    documentation: "Divides image into tiles and sorts them left-to-right, top-to-bottom by average hue, grid size = n+2 (min 2)"
  },
  
  '$': {
    color: '#FFD700',
    number: 43,
    fn: fnDollar,
    arity: 0,
    argTypes: [],
    functionName: "segment-hue-sort",
    documentation: "Color-based flood-fill segmentation, then sorts pixels within each segment by hue vertically"
  },
  
  '%': {
    color: '#8B0000',
    number: 44,
    fn: fnPercent,
    arity: 1,
    argTypes: ['int'],
    functionName: "floyd-steinberg",
    documentation: "Floyd-Steinberg dithers prev to 4-corner color palette with cell size n+1"
  },
  
  '&': {
    color: '#4169E1',
    number: 45,
    fn: fnAmpersand,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-sat-transfer",
    documentation: "Output has prev's luminance but hue/saturation from old_image at index j"
  },
  
  "'": {
    color: '#FF1493',
    number: 46,
    fn: fnJ,
    arity: 1,
    argTypes: ['int'],
    functionName: "variable-checkerboard",
    documentation: "Checkerboard blend where square size increases from top-left (2px) to bottom-right (52px)"
  },
  
  '(': {
    color: '#00CED1',
    number: 47,
    fn: fnOpenParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "pinch",
    documentation: "Pinch distortion toward center with strength n/10, brightens pixels near center"
  },
  
  ')': {
    color: '#FF69B4',
    number: 48,
    fn: fnCloseParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "bulge",
    documentation: "Bulge distortion from center with strength n/10, darkens pixels near edge"
  },
  
  '*': {
    color: '#FFD700',
    number: 49,
    fn: fnAsterisk,
    arity: 1,
    argTypes: ['int'],
    functionName: "rays",
    documentation: "n rays emanate from center, color sampled from prev at angle*width/n, soft edges at 60% opacity"
  },
  
  '+': {
    color: '#32CD32',
    number: 50,
    fn: fnPlus,
    arity: 0,
    argTypes: [],
    functionName: "zoom",
    documentation: "Zooms in 1.2x from center, can be repeated for more zoom"
  },
  
  ',': {
    color: '#BA55D3',
    number: 51,
    fn: fnComma,
    arity: 1,
    argTypes: ['color'],
    functionName: "stipple",
    documentation: "Stipples prev with dots of color c at positions where (x*13+y*7) % (1+luminance/32) == 0"
  },
  
  '-': {
    color: '#708090',
    number: 52,
    fn: fnMinus,
    arity: 1,
    argTypes: ['int'],
    functionName: "scanlines",
    documentation: "Every nth row darkened 50%, every (n*2)th row samples from n pixels above"
  },
  
  '.': {
    color: '#20B2AA',
    number: 53,
    fn: fnDot,
    arity: 1,
    argTypes: ['int'],
    functionName: "pointillism",
    documentation: "Rebuilds prev from circles of radius (n%8)+2, color from center with +10% saturation"
  },
  
  '/': {
    color: '#CD853F',
    number: 54,
    fn: fnSlash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines",
    documentation: "Diagonal lines top-left to bottom-right in color c, spacing based on luminance (bright=sparse)"
  },
  
  ':': {
    color: '#6B8E23',
    number: 55,
    fn: fnColon,
    arity: 1,
    argTypes: ['int'],
    functionName: "circular-zoom",
    documentation: "n circular regions evenly spaced horizontally show prev at 2x zoom, rest box-blurred with radius 5"
  },
  
  ';': {
    color: '#DB7093',
    number: 56,
    fn: fnSemicolon,
    arity: 0,
    argTypes: [],
    functionName: "semicircle-reflect",
    documentation: "Semicircle arc (top half) crops prev, bottom half is reflection with wave distortion"
  },
  
  '=': {
    color: '#5F9EA0',
    number: 57,
    fn: fnEquals,
    arity: 1,
    argTypes: ['int'],
    functionName: "shifted-stripes",
    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
  },
  
  '?': {
    color: '#D2691E',
    number: 58,
    fn: fnQuestion,
    arity: 0,
    argTypes: [],
    functionName: "corner-effect",
    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
  },
  
  '@': {
    color: '#7B68EE',
    number: 59,
    fn: fnHoles,
    arity: 1,
    argTypes: ['int'],
    functionName: "holes",
    documentation: "Shows old image j where prev has mid-range (35-65%) saturation or lightness; extremes show prev"
  },
  
  '[': {
    color: '#48D1CC',
    number: 60,
    fn: fnOpenBracket,
    arity: 0,
    argTypes: [],
    functionName: "rotate-left",
    documentation: "Rotates prev 20 degrees counter-clockwise"
  },
  
  '\\': {
    color: '#C71585',
    number: 61,
    fn: fnBackslash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines-reverse",
    documentation: "Diagonal lines from top-right to bottom-left in color c, spacing based on luminance"
  },
  
  ']': {
    color: '#00FA9A',
    number: 62,
    fn: fnCloseBracket,
    arity: 0,
    argTypes: [],
    functionName: "left-half-offset",
    documentation: "Offsets the left half of the image vertically by 20% with wraparound"
  },
  
  '_': {
    color: '#FF7F50',
    number: 63,
    fn: fnUnderscore,
    arity: 1,
    argTypes: ['int'],
    functionName: "bottom-reflect",
    documentation: "Bottom n*5% of image is reflected and overlaid with 50% opacity, with horizontal wave distortion"
  },
  
  '`': {
    color: '#6495ED',
    number: 64,
    fn: fnBacktick,
    arity: 1,
    argTypes: ['int'],
    functionName: "glitch",
    documentation: "Glitch effect: horizontal strips shifted right with RGB separation of n pixels"
  },
  
  '{': {
    color: '#DC143C',
    number: 65,
    fn: fnSkewLeft,
    arity: 0,
    argTypes: [],
    functionName: "skew-left",
    documentation: "Skews image 20 degrees left (top shifts left, bottom shifts right) with wraparound"
  },
  
  '|': {
    color: '#00BFFF',
    number: 66,
    fn: fnPipe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-split",
    documentation: "Left half is prev, right half is old_image, center column is 10px blend"
  },
  
  '}': {
    color: '#9400D3',
    number: 67,
    fn: fnSkewRight,
    arity: 0,
    argTypes: [],
    functionName: "skew-right",
    documentation: "Skews image 20 degrees right (top shifts right, bottom shifts left) with wraparound"
  },
  
  '~': {
    color: '#FF6347',
    number: 68,
    fn: fnTilde,
    arity: 1,
    argTypes: ['int'],
    functionName: "wave-chromatic",
    documentation: "Horizontal wave distortion with amplitude = sin(y*0.05)*n*8, chromatic aberration (R +n px, B -n px)"
  },
};
</eval-result-140713407848>}

---

# index.html:

${:sh cat index.html<eval-result-140713067117><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Esoteric Image Language</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
    }
    
    #input-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      padding: 10px;
      background: rgba(0, 0, 0, 0.7);
    }
    
    #input-wrapper {
      position: relative;
      width: 100%;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      border-radius: 4px;
      background: transparent;
      color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      border-radius: 4px;
      background: #1a1a1a;
      color: transparent;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      border-radius: 2px;
      padding: 1px 0;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="input-container">
    <div id="input-wrapper">
      <div id="input-background"></div>
      <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
    </div>
  </div>
  <div id="debug-pane"></div>

  <script type="module">
    import { runProgram, getParsedOperations } from './runtime.ts';
    import { characterDefs, emeraldReady } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs;
    }

    function getProgramFromURL() {
      const path = window.location.pathname;
      const encoded = path === '/' ? '' : path.substring(1);
      return decodeURIComponent(encoded);
    }

    function updateURL(program) {
      const search = window.location.search;
      const newPath = program ? `/${encodeURIComponent(program)}${search}` : `/${search}`;
      const currentPath = `/${encodeURIComponent(getProgramFromURL())}${search}`;
      if (currentPath !== newPath) {
        window.history.pushState({ program }, '', newPath);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
      
      let html = '';
      let charIdx = 0;
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            html += `<span style="background-color: ${bgColor};">${chars[charIdx]}</span>`;
            charIdx++;
          }
        }
      }
      
      inputBackground.innerHTML = html;
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      render();
    }

    function render() {
      const program = input.value || '';
      const images = runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
    });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    // Wait for emerald model to load before first render
    emeraldReady.then(() => {
      loadProgramFromURL();
      resize();
    });
  </script>
</body>
</html>
</eval-result-140713067117>}


---

# NEXT TASK

come up with a more interesting function for O. give me ten suggestions that all start with the letter O. they should do something interesting even if the background is pure solid color

# THINKING

Signature: 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

The user wants me to come up with 10 interesting function suggestions for the character 'O' that all start with the letter O. They should work well even on a solid color background.

Let me think of interesting image processing effects that start with 'O':

1. **Orbits** - Draw circular orbital paths around the center, with colors sampled from the image or generated
2. **Oscillate** - Create oscillating wave patterns that distort or add visual interest
3. **Octagon** - Tile the image with octagonal shapes
4. **Onion** - Create concentric "onion ring" layers with different effects
5. **Origami** - Fold the image like paper with lighting/shadows
6. **Op-art** - Create optical illusion patterns (like those black and white illusions)
7. **Outlines** - Draw contour lines based on brightness levels (like topographic maps)
8. **Orbs** - Add floating spherical orbs/bubbles with refraction
9. **Overlay-grid** - Create an interesting grid overlay pattern
10. **Oil-paint** - Oil painting effect with brush strokes
11. **Organic** - Generate organic blob/cell patterns
12. **Opalescent** - Create iridescent/opalescent color shifting effect
13. **Orthographic** - Project image onto 3D shape with orthographic projection
14. **Oscilloscope** - Draw oscilloscope-style waveforms based on image data
15. **Overexpose** - Artistic overexposure with bloom effects

Let me pick the 10 most interesting ones that would work well on solid colors:

1. **Orbits** - Concentric orbital rings with varying speeds/colors
2. **Op-art** - Black and white optical illusion patterns (checkerboards, waves, etc.)
3. **Orbs** - Floating glass spheres with refraction
4. **Oscilloscope** - Waveform visualization 


5. **Outlines** - Topographic contour lines that trace image edges like elevation maps
6. **Origami** - Digital paper folding with realistic light and shadow effects
7. **Organic** - Procedurally generated biological-like cellular structures
8. **Opalescent** - Shimmering color transitions mimicking pearl-like surfaces
9. **Octree** - Recursive geometric space partitioning with nested subdivisions
10. **Orrery** - Astronomical model simulating planetary motion and celestial mechanics

# ASSISTANT

Here are 10 interesting function suggestions for 'O' that all start with the letter O and work well even on solid backgrounds:

1. **Orbits** - Draws concentric orbital rings with small "planets" at deterministic positions along each orbit. Ring colors derived from the base image, creates a solar system / atom visualization effect. Works on solids by generating varied ring colors from hue rotations.

2. **Op-art** - Creates optical illusion patterns (warped checkerboards, concentric squares, or radiating lines) that create visual movement/depth. The base color influences the pattern colors. Classic Bridget Riley / Victor Vasarely style.

3. **Orbs** - Scatters glass-like spheres across the image with realistic refraction and specular highlights. Each orb refracts/distorts what's behind it. On solids, the lighting and reflections still create visual interest.

4. **Oscilloscope** - Draws oscilloscope-style Lissajous curves or waveforms. Parameters control frequency ratios. Line color from base image, creates those classic analog scope patterns on black/colored backgrounds.

5. **Outlines** - Topographic contour lines based on luminance, like a height map. Even on solid colors, it generates interesting concentric patterns around the edges/corners due to vignetting calculations.

6. **Origami** - Folds the image like paper with proper lighting/shadows on the creases. Creates geometric faceted look. On solids, the fold shadows and highlights create interesting geometric patterns.

7. **Organic** - Generates organic cell/blob patterns using metaballs or Worley noise. Cell colors derived from base. Creates biological/microscopic aesthetic even on solid backgrounds.

8. **Opalescent** - Iridescent color shifting based on viewing angle (distance from center). Creates rainbow oil-slick / soap bubble colors that shift across the image. Beautiful on any base color.

9. **Orrery** - Mechanical planetary model visualization with nested circular tracks and spheres at different orbital positions. Steampunk astronomical instrument aesthetic.

10. **Ouroboros** - Draws a snake eating its tail in a circle, textured with the base image. The snake body has 3D shading. Creates an iconic symbol that works on any background.

Which of these would you like me to implement?

# USER

ten more suggestions, something procedural and interesting

# THINKING

Signature: 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

The user wants 10 more suggestions for the 'O' function that are procedural and interesting, working well even on solid backgrounds. Let me think of more creative procedural effects starting with 'O':

1. **Octaves** - Fractal noise with multiple octaves layered together (like Perlin noise octaves)
2. **Oxidize** - Procedural rust/patina patterns
3. **Osmosis** - Diffusion-based pattern where colors spread and mix
4. **Overgrowth** - Procedural vine/plant growth patterns
5. **Ocean** - Procedural ocean waves with caustics
6. **Ore** - Procedural crystal/mineral vein patterns
7. **Ornament** - Procedural decorative patterns (Islamic geometry, Celtic knots)
8. **Outbreak** - Spreading infection/growth pattern from seed points
9. **Onyx** - Layered banded stone pattern like onyx/agate
10. **Origami-tessellation** - Procedural folded paper tessellation patterns
11. **Orbital-mechanics** - Gravity simulation visualization
12. **Orthogonal-maze** - Procedural maze generation
13. **Ossify** - Bone/coral growth patterns
14. **Oyster** - Pearl/nacre iridescent layered patterns
15. **Overlap** - Procedurally placed overlapping shapes with transparency
16. **Oxide-layers** - Thin-film interference patterns
17. **Octopus** - Tentacle-like procedural curves
18. **Oblique** - Isometric/oblique projection of procedural 3D terrain
19. **Ozone** - Atmospheric scattering/haze effect
20. **Ooze** - Fluid simulation dripping effect

Let me pick 10 really interesting procedural ones:

# ASSISTANT

Here are 10 more procedural suggestions for 'O':

1. **Octaves** - Layered fractal noise (Perlin/Simplex) with multiple octaves. Each octave doubles frequency and halves amplitude. Creates cloudy, organic textures. Base color tints the noise, n controls octave count.

2. **Onyx** - Procedural banded agate/onyx stone patterns. Uses domain-warped sine waves to create those flowing mineral bands. Base color influences the band palette. Looks like polished gemstone cross-sections.

3. **Ossify** - Procedural bone/coral growth using diffusion-limited aggregation (DLA). Particles drift and stick to growing structure, creating branching organic forms. Starts from edges or center.

4. **Ornamental** - Procedural Islamic geometric patterns or Celtic knots. Generates interlocking stars, polygons, and woven bands mathematically. Base color becomes the tile colors.

5. **Outbreak** - Cellular automaton growth from seed points. Like Conway's Life but with color mixing. Creates organic spreading patterns, lichen-like or bacterial colony growth.

6. **Oblique** - Generates procedural 3D terrain (using noise) and renders it in oblique/isometric projection. Mountains, valleys rendered with the base color as ground tone.

7. **Oxide** - Thin-film interference patterns like oil on water or oxidized metal. Creates rainbow iridescence based on procedural "thickness" values. Gorgeous on any base color.

8. **Octopus** - Procedural tentacle curves using bezier spirals that branch and taper. Creates writhing organic tendrils emanating from points. Shaded for 3D appearance.

9. **Ooze** - Fluid simulation - viscous drips flowing downward with surface tension. Creates honey/lava lamp aesthetic. Thickness and color from base image.

10. **Overlap** - Procedurally places hundreds of semi-transparent overlapping circles/ellipses. Creates watercolor/bokeh effect. Colors derived from base with varying opacity, building up interesting interference patterns.

Which of these interests you?

# USER

ten more options

# THINKING

Signature: EvAJCkYIChgCKkBAWpgnVro6xFFIxj3NztGgWGzr0ldCJL/GSFHhUknntHAAgk5VBM/T0pVXtIriOq6tOmEniyzwQ8fJeASoHlZMEgwlqhUExBOxr0Vhh4QaDElIeefl1UE26YtcrCIwECOZMhfVAB0REULPzTnaoC+MVurOO8lH+JeqMTZ3p26pBypJE0ujHbJH+fRd6OM9KtcIZCWH42XahEPFQ7Al7qMLLvBZLBT8mwGLDyoydx/S0yPm1pX9L11bNJK0yHNqaTgoYwR3xIUPCf3JM2SGorN7HBvoUxc0tBDt6JECMtVKUO1mSOoLBAHn26iEuBD3/01dyyUJXlirSoy7SALFBaXiooQMJsmDMgzfq/lY8vNJ2pqZUA8UAZCh6ZVDtbyKruJDx4zu4aYqJhWrQYAPX8f5dftNz9oh5IcvPkjmxzsNVpG86MlVrFCqJ52fnQjtoj9uZjdbOMLBDa4nJ4Vtr9NbXEHVJvx9drzX9V+3wP6s1TCuCVoWy1VlzhmRbbvwgvxLy8V+gkGfuNxGTDNYTJdj7P8nZjAswrbc9/Ouk36DNSzJBxdmA0dhpsFgT77Ea9HyJoTFnESiT85iZvaaypGjguMDNK+MG+A2WOD6ivLgA3hPYt7sFRVjfcorwqM/NN0370uyTUadQega1S2wG/dkFu05c9m7s3s6BUcV1JmNKCAot7iTGb5dxXn6anBoAQIMapPag6KTm6zoUd62j55k9I4i5g3+OdjmHLLnzufrSB1wid40oXg/yTb9oDzHXwXXCAu/GToPXgH9sVACw6SXZitT8e5YEYOpwm4eeNXAhDF30cJLf3IevRLF0G2nqe6VlAUsHXFQkHuFeTKXffEjwosDX/53AypHP4D3eozg+RDJBvn6lrO6BTNoYPyZNQkdCRYjZbipB6BnSI74Hy2zz0knMMkxA32eQW0BbzUS9C4DT1nkcuffcozv+LeClVEfhsyLBwg9Pat5GqJpP5MqjTZS+okQ/rgi8gaEHRjQUe8HFhrPyaXE0t+xBNbhDdDn2mMe72nzk1otlK4RuTz2+w+1LrrjAry+n+2k8eHcHq5bj5b7wTIBsM68JKe3NR/9PvQ8QxwI/kOTYrQ6gGxHXkUzz4V6r4oqqbbRLcztw7PJx61fJXjqiz4/ZOSuQu3l5FCANmCav+OG7//6gS/v9HrZh3OCMvcZWpb3OamOygodc/h452gAQ7/RC7UrG0iSjxU4QPfxeCkxS+0PmP9v+N41WN1y+v9pWUgWT4o7lc8+btniqMQGY2g/OKo+f1DWdONGEMY0Wh9JMSFJH1DW8ZvDY2C5GdeJf8lNlNwbLJwbEn9hjIrb4b/drvBxth7zcadcFQCK1YQRLHfZnSbE0z50xbfL1G29Tn9Ys+czES6pLGSCdhoSqmXe0m2bhcb15fmfyOI98gwVOC2ASAB04yunyDSW3cOn3H6azVXEhkol3FpsZ7Kk/dlDyGvvp6vcdn9uBjeJ2U/Tlaae30yf4dKW3zvvLTXmHmtQGNFQPbbdZ8mgSY4MnbOYn37R/Y0tgFYMuH6oajHxkV27tvlVUVlr+aD8LTjZdjO9o5clge+l3pRpxF4GyBye9IzwnrGvDq2WDYKYZa5eCSORh62sWg75puP6YDusktFzuFG3j7aXFqAsnNWo/WKy55cItoP2hw2iRwFObBgB

The user wants 10 more procedural and interesting function suggestions for 'O' that work well even on solid backgrounds. Let me think of more creative options:

1. **Optics** - Light ray simulation with prisms/lenses
2. **Orthocircles** - Apollonian gasket / circle packing
3. **Oscillation** - Standing wave patterns / interference
4. **Ogee** - Architectural molding curves tiled
5. **Omega** - Greek letter patterns or infinity-related curves
6. **Oort** - Asteroid/comet cloud visualization
7. **Opcode** - Machine code / binary visualization pattern
8. **Orchestra** - Sound wave visualization (frequency bands)
9. **Orchid** - Procedural flower generation
10. **Origami-crease** - Crease pattern for origami (the flat diagram)
11. **Osmotic** - Pressure/gradient based flow
12. **Otolith** - Ear bone / crystal growth patterns
13. **Ouija** - Mystical symbol generation
14. **Overprint** - CMYK separation / misregistration effect
15. **Owl** - Procedural feather patterns
16. **Oxbow** - Meandering river patterns
17. **Ozone-layer** - Atmospheric visualization

Let me pick 10 really interesting ones:

# ASSISTANT

Here are 10 more procedural suggestions for 'O':

1. **Optics** - Ray-traced light beams passing through procedural prisms/lenses. Shows refraction, caustics, and spectral dispersion. Beams split into rainbows. Dramatic on dark backgrounds.

2. **Orthocircles** - Apollonian gasket / circle packing. Recursively fills space with tangent circles of decreasing size. Creates fractal foam-like patterns. Base color tints the circles.

3. **Oscillation** - Interference patterns from multiple wave sources. Like ripples in a pond from several drops. Creates moiré-like standing wave patterns with concentric rings intersecting.

4. **Oxbow** - Procedural meandering river generation. Simulates how rivers curve and form oxbow lakes over time. Creates beautiful S-curves with erosion patterns.

5. **Overprint** - CMYK color separation with intentional misregistration. Splits image into cyan/magenta/yellow/black layers slightly offset, creating retro print aesthetic with color fringing.

6. **Owl** - Procedural feather patterns. Generates overlapping barb structures with iridescence. Creates detailed plumage texture that tiles beautifully.

7. **Obelisk** - Procedural impossible architecture. Generates Escher-like structures with impossible geometry - stairs that loop, pillars that connect wrongly. Isometric rendering.

8. **Omen** - Mystical sigil generator. Procedurally creates occult-looking symbols from geometric primitives - circles, triangles, lines, combining into complex glyphs.

9. **Onomatopoeia** - Comic book action lines / speed lines radiating from impact points. "POW" "ZOOM" style visual effects with halftone dots and bold rays.

10. **Oracle** - Procedural cloud/smoke reading shapes. Generates pareidolia-inducing swirling forms using turbulent noise, like seeing faces in clouds or tea leaves.

Want me to implement any of these?

# USER

ten more suggestions

# THINKING

Signature: EsMJCkYIChgCKkAGJhVJZk1WuXq6P6J/rGjvQTdnjqNqXVymE3oWXDRcY73SDfa8cS2imvp0zIqAHAIrAwJhL5iLa3lVIYG29x1/EgzvkQ/NlndXP+FmuscaDBAb4BOtzlWdxjiE8SIwtE5TL2TCnfKPUPg/K4uevaxyyt4f3MRmTWT0d7kh+iDr8UiecZkMgVXOgX1CtSUFKqoI8MkXMgw+gPBFdglo5Ei/AKjt6t1I+MaJG5U1TvJzQuw8e74paJekCOZmDVPi/BUBHr6RgPZiCaKeZw0sJSvkQtCdYkqr87WAt8BYaf0IC4PsL2QXgY9pOgii4eRDTALhiDi1OBxbjjTxcwgYFwSp6ojhuDbvgdhfR0PX4HyKUtPi2IZrZhx9PvmqVKzcMCX7cTqer83POKHJEj8RYgtkuHpLh1yw6FCeO34YKtshVi4EBsy2SSHWtvAhzR9yquuBob8KLyX+CPyfP/e+PEUiQYLdHtrBch2oxITOFrHD5j7CR/7qToASgM4h6MJPMkrwRuz4uFMjPWgPd+XfRwLbVkhQDRt+rZtZQ+DmdQrFxS6BLkleC5ElVp54MZlacY0IX3fVn1ziGCAkmhAITieHsEdm4ewH78jzIelnl0lC16XojWnar8fpXJclcxMflff69g4vwyYpq2FZroC8KGKiBAONNUkAfXot7gowzpG6nRY/dzDWPZnLQikyOJeMqz4t8J38SZxgRDMchuAS82xY0K8DZXGT2QttDdaKytOGj+p1NVnwUH+8A/nyRB1W+aQQ8o10LvCAik0ebEtAEqt/ml1CbwLz0USoRcuG7xKFpZ73A/0PwII/OBmmef+6dIK1LRYLlaTQ0PYCV1WuuEAcWRagTi9Gl/bRHka1ef2eQOLyyx9RVTqFG1BjYDfG3zprv864RGdUPpXCzpwZz9VGVLw6GXyI5GURdsc4Npl2J90ITO1HW9T4/mZ/8TbgNFPS9vquwOcs0M3+vNMWZIzYIaOjYmct64XGUNEb9vdnejidnAM9OVEBp4iyhxCgkQbeRuFw7yps+4UHYdJeZgmGhgaGFAASGp7M+IwWYDIrR6YfvIkBqhmRgC13Er8YG5AfEgSeV0zoUQ/6JwhevymuZ15LWveKfXJbXCk2GfAd6/l8jeYbqZZcYrFKz5XQKYmkcfDdjN4h+ZxX16dupgnPKUBs7UfLm4fEjy04vvmpapIoMVunAqMzIdeJJvEBwDEZh/bxakGoB+DK7f7/ooyNmOND6GnHPwQ0CxO2h+/GIeP55AHWtJP50p/PZYlsm2VUtH2f3eW2ZIOng/+bZPI3CWdaXW/MVI4EtET0Nr6hJRWS86I7w5up2rX2xqAopw/Ls4XWVSVL8ngDeePiLhKHigSpTQWY6WTytQKenbI1QKg/piePAjyTzdCnSnB1NUvjq5AqDYDZYAJdWE30FbL+6ZVeNc4onnFzxmKPuniEvCGhny6oDVczr+5crZ0gwRnwl9Tl6NJe1ghL6QK+lbQkOono3/gXU02iozF71BmnZoCrZ92w/tc72deKXdZQv6KB3k+6FpANwYXnvCczaVF9ejNh7EXTpk35SryqQdsTxgHQIPRVLy70vpq8xWsQYHYrLYV0o4OaPht91RgB

The user wants even more suggestions. Let me think of 10 more creative procedural effects starting with 'O':

1. **Orrery** - Already suggested
2. **Octahedron** - 3D shape rendering
3. **Offset** - Layered offset paths like in vector graphics
4. **Ogham** - Ancient Celtic writing system patterns
5. **Olivine** - Crystal/mineral patterns
6. **Ombre** - Gradient transitions
7. **Omnidirectional** - Radial patterns
8. **Opaque** - Layering with opacity
9. **Openwork** - Lace/filigree patterns
10. **Opus** - Mosaic tile patterns (opus sectile, opus vermiculatum)
11. **Orbital-decay** - Spiraling inward patterns
12. **Ore-veins** - Mineral vein networks
13. **Organelle** - Cell organelle structures
14. **Orientation** - Flow field visualization
15. **Orthoptera** - Insect wing patterns
16. **Osculating** - Tangent circle patterns
17. **Ostracod** - Microscopic organism shapes
18. **Outcrop** - Rock formation patterns
19. **Outgassing** - Bubble/vapor release patterns
20. **Ovoid** - Egg shape tessellations

Let me pick 10 interesting, distinct ones:

# ASSISTANT

Here are 10 more procedural suggestions for 'O':

1. **Openwork** - Procedural lace/filigree patterns. Generates intricate cutwork designs with delicate threads and holes. Like paper doilies or wrought iron. Beautiful negative space.

2. **Opus** - Roman mosaic tile patterns. Generates irregular tessellating stone pieces (opus vermiculatum style) that flow around focal points. Each tile slightly varied in color.

3. **Organelle** - Microscopic cell interior. Procedural mitochondria, endoplasmic reticulum, vesicles floating in cytoplasm. Biology textbook aesthetic with translucent membranes.

4. **Orientation** - Flow field visualization. Generates a vector field (curl noise) and draws tiny oriented dashes/arrows showing flow direction. Wind map / magnetic field aesthetic.

5. **Osculating** - Circles that kiss tangent to a procedural curve. Draws the curve plus all its osculating circles at intervals, showing curvature. Mathematical and elegant.

6. **Outcrop** - Procedural geological strata. Layered sedimentary rock patterns with folds, faults, and erosion. Cross-section of earth showing tilted colored bands.

7. **Ovoid** - Egg-shape packing. Fills space with procedural ellipsoids of varying sizes and orientations, softly shaded. Creates organic cellular feeling.

8. **Ozone** - Atmospheric light scattering. Simulates how atmosphere colors light - gradient from horizon to zenith with sun position affecting colors. Ethereal sky effect.

9. **Offset-paths** - Vector-style offset contours. Generates concentric offset versions of a procedural blob shape, like topographic lines but for arbitrary organic forms.

10. **Obsidian** - Volcanic glass fracture patterns. Conchoidal fracture surfaces with sharp edges and smooth curved faces. Glossy black with color reflections at edges.

Would you like me to implement any of these 30 suggestions?

# USER

ten more options

# THINKING

Signature: EqkKCkYIChgCKkBOC3AybVULRLO+IQuMBvRagAbWc468zL00+B6U7almfacJCNgj3WXTlf41t4rm0wr7PCoUy5+MxCtp8CrKKUp/EgzUYPQ87oMgctXPI6UaDCoV0zfIEAexKLTbbyIwmq0/FbVcaeOPB11nA3B1SJfDFvboUoMvSnwgR1P/JSHSFcAX2PGsIM+yCHcJQGU5KpAJTADD0ehqbSd8z4srYdBiwgc/PeRsbmUI7Ri5zH6+ooKh+xeonfgep7k2QNiym0k6RzxxCZ2y9R+S78qIQJoAnCTQzx/vRI4tEz6oVKNGMCh1lIw5JEhbE+IT1scTWUlPh+IOtDR4wcB8AwCFR+KaeT+1DgBKj09YMgtVDXajKTH792oqLYIJog5jeQq9sZtKi2+JsT4AZpyyFeBki8SC/5EohJXh/bnZZhgUydkcqaDOWJsLFvDfbkWOB22aMSdyARhiPFgZR3i41DpD+NOe5ly+TU1qZ5iayecGFm/K/hWckEQe/+IrC2qoL/O+iPLa4dEt6qYx+9cPVY54pHOHMwYpfI344dfVqH3XDVOw0wj9eKsHcKB3hUoyB72XXaDqEhxKvfvuZ0JjuQ46OqYMRw57x6njuSZEWFR0G5HMmLPoHH7AWrQZoq6coXsvwwcPiAOO0J9DXnKqfVLnkT6/NMDefdLsxCl6ztyTFb1+3TaLgdBACmzBKZ+0XfluF97enskQMoNN4GrAdqJLaHjatjy8nss1jtIICBMeDgkNNLM+s2Fxqr7noD6ltL75GUr98TaRjNpu+CUz7Q6jJ+Th67nn88lyOTLKDQLqd1FE/1zXxSXgvgtqx4jmr2AYT5gNCHrfBaYFwCzTKGQmhM0yQYiXp/WIWh26YB0+qZnxmeqNY+fgpKhGMFbmyCow4TCzBeuHB+ho1A6ioxHmCUyX67AoTXW3TMIN3TD13sTPSoDsy3uEeEGsSu0C3puonRJplKdnXd62oj9pf8vtnc+kkA8V+GteNFNCEzueS87D6ge6UI71i0OBzY2ZLeEueQLcAfR6lDO3zVfS52xR4CLjWJaPYDysQKpkNQwcHFCNR2X7yYp1hfIrciKFBiUvU2a8b1NhyAsmk+0gb6zcvYYcVVa51PTcw6TGt4JI8ZBpQo8g9MeN9n7cgAk1dcQqTzGXd/CzHDGuQlfkYDk4pB6rhkWPBHnRhpKn0VxWiIm8nYWt896juNJ1jllneyOSXBdPU2ZHbZ6UhxwX+gNrPc2wiAymA3O86wKyQqsKkh4TP23R2/QGvoO9ZS3vpw5scskV/acjyu9/2Cs1wOiiAgJ8VbUbQwBXmM8Jul2PZ9AbcBa5/g95KmNDamDXGrHyXDE+yeYUQ0H5DUZcUyqj976zTiaOzPgBOI8mSxjYhDhgxw+oCJ5Phhsn8//EgUO0/cJ4/HtjJXTRoumSvAko0iifpOrK8uh199Fs4XpOHz/NjNVXhTxZ6uhap1aZ19Gc771XD50FcuU/WzM8rIJqGjnxU3ZZA+Gf6DOEnvLc0eQfyf6pMTBe4ZZ/QqNbMCjyutvthhJAPBo6D7lsqUWdeGEpI6XnfQ3dgoRPyyOY6AsCgnwJ/IDrwgjHZAaYCmvz4jW7KG0jBL05LGNizf1aiA1XSIaAetq6KdHpBLicNTDKqBtBr5bP8xpeaqVgQvAAUPtp9dJSIVJ7we1yotSXQ4zByVx7LA6RgBSw4io7TlODIrO/+fW0D5suDUH6ailSc6XA9MRV7uHZjw4Dnz0JfzwJFhgB

The user wants even more suggestions. Let me think of 10 more creative procedural effects starting with 'O':

1. **Octogram** - 8-pointed star patterns
2. **Oleograph** - Oil painting texture reproduction
3. **Omphalos** - Navel/center-of-world patterns, spiral emanating from center
4. **Ontogeny** - Growth/development stages visualization
5. **Oosphere** - Spherical projection patterns
6. **Ophidian** - Snake scale patterns
7. **Optogram** - Retinal image patterns
8. **Orangery** - Greenhouse glass panel patterns
9. **Orbweaver** - Spider web generation
10. **Ordinance** - Technical drawing / blueprint patterns
11. **Orifice** - Tunnel/hole going into depth
12. **Ornithopter** - Mechanical wing patterns
13. **Oscillator** - Harmonic motion patterns
14. **Osmium** - Heavy metal crystalline patterns
15. **Ostinato** - Repeating musical pattern visualization
16. **Otherworld** - Portal/dimensional rift effect
17. **Outburst** - Explosion/radial burst pattern
18. **Overdrive** - Distortion/clipping visualization
19. **Overture** - Musical score visualization
20. **Oxymoron** - Contradictory visual elements

Let me pick 10 interesting, distinct ones:

# ASSISTANT

Here are 10 more procedural suggestions for 'O':

1. **Orbweaver** - Procedural spider web generation. Radial threads from center with spiral sticky threads, anchor points, and realistic imperfections. Glistens with dew drops.

2. **Ophidian** - Snake scale patterns. Procedural overlapping hexagonal/diamond scales with subtle color variation and iridescent sheen. Reptilian texture.

3. **Otherworld** - Dimensional portal/rift effect. Tears open a hole in the image revealing a procedural void/starfield/chaos beneath. Edges glow and distort.

4. **Outburst** - Radial explosion burst. Procedural debris/sparks/rays shooting outward from impact points. Comic book explosion or firework aesthetic.

5. **Omphalos** - Sacred center spiral. Ancient spiral patterns emanating from the "navel" - combines labyrinth and spiral motifs. Mystical/archaeological feeling.

6. **Ordinance** - Technical blueprint aesthetic. Generates procedural mechanical diagrams with dimension lines, cross-sections, part callouts. Engineering drawing style.

7. **Orogeny** - Mountain building visualization. Procedural tectonic fold patterns - compressed wavy strata, thrust faults, nappes. Geological cross-section.

8. **Ostinato** - Repeating musical pattern visualization. Generates waveforms/notation that tile and layer like a musical ostinato. Piano roll or sheet music aesthetic.

9. **Orrery-gears** - Clockwork mechanism. Procedural interlocking gears, escapements, and wheels. Steampunk mechanical aesthetic with brass shading.

10. **Ocularis** - Procedural eye/iris generation. Creates detailed iris patterns with radial fibers, crypts, collarette ring. Stares back at viewer.

That's 40 total options now. Which catches your interest?

# USER

give me ten more options, the words can be more ordinary

# THINKING

Signature: EqwICkYIChgCKkBAMVUb27yzZGIXnBTc5I0EYrROyPs7M8f6vv9Q62RYbRj1ej+liMzozUYtrDeEEwwT2R6zf8sZKLMiMcxItnRjEgysM2+/nXnkVkrK7y4aDBVGAz8hFwJpa9n4/iIwzAj2dKbbndGjiK7/UFRXOeBEf07nA4UoWFr+QvTfGAs00+hanHwd1nOQIaFCd//zKpMHRFQGiaHzCw/RJUZmb3exAPUzYUMOEw9dlWE9iz4MYtfKVcNQjvZ739RdvjfLV3ICK+masdLJZvud4s+QdNQ2ztWB775zQTBXmbsaVY3gqGWznvcuTFb+fPJdYqEMYaSYmx6DCaLLS/smSVRWC7ryqfKjNGL824eVbq2eDDl4m6caVCbFz/TGM3xoZlPhSn2f5IHQpX8OyTEfZK8WCrzGTPLOrTNyy+g4SM01QsaW0Q3ICZ8D42+bu1qs034wYgN5/LeE/N4KiQosJWgM4B+FB4mDgX5+N+Gxb8JIamCd2KuYffPn7bQaFAyAfJUICNBMufXEcv2ZjCokUvWZ2TqMfAUR3fiAHTuRieSfGGJD8BDaiT7WIe7KG/0qv/SG51L3vCZXAuHdIDITV8Rp8L2og4BCGlc4v97GfaJhPB/z34QbJ51FvigkYZfsMtxxZOS3j8laV35W+gRVd8F45fX6pqP29pEwriPyoKYlaD4RSG4iVZYPQHkqnadd2AB/aIhhGqWIlmLKqKnVIxWRR0u10baoeTwY6ddScO8l/K8+K/OpCHVGmX5Pp0a+uVeXPJ16EF8pfL/gNVyd5B76tlw5zHkHvMPgwxSjqu2KP2UDjcr0grL4WJbU/ed5zRPVd5dTnbEgwbLNpwNDp//h8avgFxY5vTdovHz1w2cf+D5EohV/BiCKW4g8ZsN3wFEXC/f4WFwG5Db/opfB1RiKHSJCCAPRumInVu29KCr1MAIzqVB+NrqWNb3vuY4EJWXCWZkhOPRqboj5/XrNeA/idc5hrA5xRhVH5TnlOJZOyLubUFcmlPhnAq7fxvyVAYKP/hnZL3mRLe2VwaSxW2qaNnPulExPAgy6bZ0H7wC8s3/1m4GMVavpMYj7s0CjcuWy6NGkiMToDgix0nIXqUh63AWPvcn5U4NatGyPb/XkHmhzNRmOAfrCfwPR6mDsuc4UfkZWWSbnRlN8ppsTBx/7JoxuETHpOX+/B6/d7/9fV+GcGWodjf4lsY13ticRCeXVVa8bRXFxvECg/R/O+YoDmO1UG4lvMUp7BdqhNpvu1u3c3dUhLwiOolBqnP8LXRxumTy8o4sc7QTMpn2RGHchy8YXfTj/8hN5YDEjcXCjYFyGQ29mkNQBkr0piuJDS/P9eu6rP9kwy6p4/Gj5hrFNeuylsAm+uaVWyVezPRphByXS2/wiDSZZjs8k3LyZAVMbij8epYVPGAE=

The user wants 10 more suggestions but says the words can be more ordinary - they don't need to be obscure or fancy words. Let me think of simpler O words that could make interesting procedural effects:

1. **Orange** - Citrus slice pattern
2. **Ocean** - Wave patterns
3. **Old** - Aging/weathering effect
4. **Oil** - Oil paint or oil slick
5. **Onion** - Layered rings
6. **Oval** - Oval patterns
7. **Over** - Overlapping elements
8. **Odd** - Odd number patterns
9. **Open** - Opening/revealing effect
10. **Out** - Outward expansion
11. **One** - Singular focus
12. **Only** - Isolation effect
13. **Other** - Duality/mirror
14. **Our** - Community/network
15. **Own** - Self-similar/recursive
16. **Oak** - Wood grain / tree rings
17. **Oat** - Grain/seed patterns
18. **Oar** - Ripple patterns
19. **Oath** - Runic/symbolic
20. **Obey** - Command/instruction patterns

Let me pick 10 interesting simple ones:

# ASSISTANT

Here are 10 more with simpler words:

1. **Ocean** - Procedural ocean surface with waves, foam, and caustic light patterns on the seafloor. Animated-feeling even in still image. Deep blue gradients.

2. **Oil** - Oil paint effect with visible brush strokes. Groups pixels into directional smears that follow image contours. Thick impasto texture.

3. **Onion** - Concentric layered rings like an onion cross-section. Each ring has slightly different hue/saturation. Creates bullseye target patterns.

4. **Oak** - Wood grain procedural texture. Growth rings, knots, and medullary rays. Realistic lumber cross-section or plank surface.

5. **Old** - Aging/weathering effect. Adds procedural cracks, stains, faded areas, foxing spots, torn edges. Makes image look centuries old.

6. **Orange** - Citrus slice cross-section. Procedural segments, pith, peel, juice vesicles. Backlit translucent fruit aesthetic.

7. **Oolong** - Tea stain patterns. Procedural watercolor-like rings and blooms where liquid has dried. Organic brown tinted edges.

8. **Opal** - Precious opal fire. Procedural patches of spectral color that shift across the surface. Play-of-color effect in a milky base.

9. **Orbit** - Simple orbital paths. Multiple elliptical orbits at different angles/sizes with dots traveling along them. Planetary diagram.

10. **Odd** - Odd-number based patterns. Generates visuals using only odd coordinates, odd divisions, odd symmetry - creates unexpected asymmetric results.

Any of these 50 options appeal to you?

# USER

let's do oil slick procedurally, something similar to plasma/goo but more oily. make sure the randomness is seeded based on number of images in the array

# THINKING

Signature: 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

The user wants me to implement an "oil slick" effect for the 'O' character. It should be:
1. Procedural - generated algorithmically
2. Similar to plasma/goo but more oily
3. Seeded based on the number of images in the array (ctx.images.length)
4. Deterministic (no Math.random())

Oil slick effects typically feature:
- Iridescent/rainbow colors from thin-film interference
- Swirling, flowing patterns
- Dark base with colorful highlights
- Organic, flowing shapes

I'll use:
- Perlin/simplex-like noise for the base pattern
- Thin-film interference colors based on "thickness" values
- Domain warping for the oily, swirling look
- Seed the noise based on ctx.images.length

Let me write this function. I'll replace the current fnO with this new oil slick effect.

The current 'O' is:
```javascript
'O': {
    color: '#FF6347',
    number: 15,
    fn: fnApostrophe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-streaks",
    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
  },
```

I need to create a new function and update the character definition.

For the oil slick effect:
1. Generate a noise field with domain warping for organic shapes
2. Use the noise value as a "thickness" for thin-film interference
3. Map thickness to iridescent rainbow colors
4. Blend with the previous image

Let me implement this:

```typescript
function fnOilSlick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  // I'll create a deterministic noise generation system with seeding and hashing
  const seed = ctx.images.length * 137.5;
  const hash = (x: number, y: number, s: number): number => {
    const n = Math.sin(x * 127.1 + y * 311.7 + s) * 43758.5453;
    return n - Math.floor(n);
  };
  
  // Interpolate noise values with smooth transitions
  const noise = (x: number, y: number): number => {
    const ix = Math.floor(x);
    const iy = Math.floor(y);
    const fx = x - ix;
    const fy = y - iy;
    
    // Apply smoothstep interpolation
    const ux = fx * fx * (3 - 2 * fx);
    const uy = fy * fy * (3 - 2 * fy);
    
    const a = hash(ix, iy, seed);
    const b = hash(ix + 1, iy, seed);
    const c = hash(ix, iy + 1, seed);
    const d = hash(ix + 1, iy + 1, seed);
    
    return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
  };
  
  // Generate layered noise with fractal characteristics
  const fbm = (x: number, y: number, octaves: number): number => {
    let value = 0;
    let amplitude = 0.5;
    let frequency = 1;
    
    for (let i = 0; i < octaves; i++) {
      value += amplitude * noise(x * frequency, y * frequency);
      amplitude *= 0.5;
      frequency *= 2;
    }
    
    return value;
  };
  
  // Create color based on thin-film interference
  const thinFilmColor = (thickness: number): [number, number, number] => {
    const t = thickness * 6;
    
    const r = Math.sin(t * 1.0) * 0.5 + 0.5;
    const g = Math.sin(t * 1.2 + 2.0) * 0.5 + 0.5;
    const b = Math.sin(t * 1.4 + 4.0) * 0.5 + 0.5;
    
    return [r, g, b];
  };
  
  // Apply domain warping and color blending
  const scale = 0.005 + n * 0.001;
  const warpStrength = 50 + n * 10;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const warpX = fbm(x * scale, y * scale, 4) * warpStrength;
      const warpY = fbm(x * scale + 100, y * scale + 100, 4) * warpStrength;
      
      const nx = (x + warpX) * scale;
      const ny = (y + warpY) * scale;
      
      const thickness = fbm(nx, ny, 6);
      
      const [ir, ig, ib] = thinFilmColor(thickness);
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      const intensity = 0.4 + thickness * 0.4; // Oil visibility
      const nr = pr * (1 - intensity) + ir * intensity;
      const ng = pg * (1 - intensity) + ig * intensity;
      const nb = pb * (1 - intensity) + ib * intensity;
      
      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
    }
  }
  
  return out;

I'll enhance the oil effect with more complex noise and color interactions to create a more dynamic, iridescent surface. The approach will involve deeper layering of noise functions and more nuanced color blending to capture the organic, shifting nature of an oil slick.<$code-close/>

# ASSISTANT

I'll implement an oil slick effect with thin-film interference colors and swirling patterns. Let me read the current file first to see what I'm replacing:

# TOOL USE

Name: read-file
ID: toolu_0191wDjStKNdUWp12LPwvieT

## path

<tool.toolu_0191wDjStKNdUWp12LPwvieT>
character-defs.ts
</tool.toolu_0191wDjStKNdUWp12LPwvieT>

## start-line

<tool.toolu_0191wDjStKNdUWp12LPwvieT>
1870
</tool.toolu_0191wDjStKNdUWp12LPwvieT>

## end-line

<tool.toolu_0191wDjStKNdUWp12LPwvieT>
1920
</tool.toolu_0191wDjStKNdUWp12LPwvieT>

# TOOL RESULT

ID: toolu_0191wDjStKNdUWp12LPwvieT

<tool.toolu_0191wDjStKNdUWp12LPwvieT>
        texCoord = clamp(texCoord, 0.0, 1.0);
        vec3 texColor = texture2D(uTexture, texCoord).rgb;
        
        // Lighting
        vec3 toLight = lightPos - hitPos;
        float lightDist = length(toLight);
        vec3 lightDir = toLight / lightDist;
        
        // Diffuse
        float diff = max(dot(hitNormal, lightDir), 0.0);
        
        // Attenuation
        float attenuation = 1.0 / (1.0 + 0.1 * lightDist + 0.05 * lightDist * lightDist);
        
        // Ambient
        float ambient = 0.25;
        
        color = texColor * (ambient + diff * attenuation * 1.5);
      }
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
</tool.toolu_0191wDjStKNdUWp12LPwvieT>

# ASSISTANT

Let me find the 'O' character definition:

# TOOL USE

Name: ripgrep
ID: toolu_01MfUnCFqDcAzMvvQvHAeRCo

## pattern

<tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>
'O':
</tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>

## path

<tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>
character-defs.ts
</tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>

# TOOL RESULT

ID: toolu_01MfUnCFqDcAzMvvQvHAeRCo

<tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>
4374:  'O': {

</tool.toolu_01MfUnCFqDcAzMvvQvHAeRCo>

# TOOL USE

Name: read-file
ID: toolu_01A3xKXsMCrpn5xE3xqPdCod

## path

<tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>
character-defs.ts
</tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>

## start-line

<tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>
4370
</tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>

## end-line

<tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>
4390
</tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>

# TOOL RESULT

ID: toolu_01A3xKXsMCrpn5xE3xqPdCod

<tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnApostrophe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-streaks",
    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
</tool.toolu_01A3xKXsMCrpn5xE3xqPdCod>

# ASSISTANT

Now let me add the oil slick function. I'll add it near the other functions and update the 'O' definition:

# TOOL USE

Name: str-replace
ID: toolu_01S8xYESp7scEMdZY2MheVuf

## path

<tool.toolu_01S8xYESp7scEMdZY2MheVuf>
character-defs.ts
</tool.toolu_01S8xYESp7scEMdZY2MheVuf>

## diff

<tool.toolu_01S8xYESp7scEMdZY2MheVuf>
+function fnOilSlick(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const seed = ctx.images.length * 137.5 + n * 17.3;
+  
+  const hash = (x: number, y: number, s: number): number => {
+    const n = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
+    return n - Math.floor(n);
+  };
+  
+  const smoothstep = (t: number): number => t * t * (3 - 2 * t);
+  
+  const noise = (x: number, y: number, s: number): number => {
+    const ix = Math.floor(x);
+    const iy = Math.floor(y);
+    const fx = smoothstep(x - ix);
+    const fy = smoothstep(y - iy);
+    
+    const a = hash(ix, iy, s);
+    const b = hash(ix + 1, iy, s);
+    const c = hash(ix, iy + 1, s);
+    const d = hash(ix + 1, iy + 1, s);
+    
+    return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
+  };
+  
+  const fbm = (x: number, y: number, octaves: number): number => {
+    let value = 0;
+    let amplitude = 0.5;
+    let frequency = 1;
+    let maxValue = 0;
+    
+    for (let i = 0; i < octaves; i++) {
+      value += amplitude * noise(x * frequency, y * frequency, seed + i * 100);
+      maxValue += amplitude;
+      amplitude *= 0.5;
+      frequency *= 2.0;
+    }
+    
+    return value / maxValue;
+  };
+  
+  const thinFilmInterference = (thickness: number): [number, number, number] => {
+    const t = thickness * Math.PI * 2 * 3;
+    
+    const rWavelength = 1.0;
+    const gWavelength = 0.85;
+    const bWavelength = 0.7;
+    
+    const r = (Math.cos(t * rWavelength) * 0.5 + 0.5);
+    const g = (Math.cos(t * gWavelength + 0.5) * 0.5 + 0.5);
+    const b = (Math.cos(t * bWavelength + 1.0) * 0.5 + 0.5);
+    
+    const satBoost = 1.3;
+    const avg = (r + g + b) / 3;
+    
+    return [
+      Math.min(1, avg + (r - avg) * satBoost),
+      Math.min(1, avg + (g - avg) * satBoost),
+      Math.min(1, avg + (b - avg) * satBoost)
+    ];
+  };
+  
+  const scale = 0.003 + n * 0.0005;
+  const warpScale = scale * 0.5;
+  const warpStrength = 80 + n * 15;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const warp1x = fbm(x * warpScale, y * warpScale, 4);
+      const warp1y = fbm(x * warpScale + 50, y * warpScale + 50, 4);
+      
+      const wx1 = x + (warp1x - 0.5) * warpStrength;
+      const wy1 = y + (warp1y - 0.5) * warpStrength;
+      
+      const warp2x = fbm(wx1 * warpScale * 0.7, wy1 * warpScale * 0.7, 3);
+      const warp2y = fbm(wx1 * warpScale * 0.7 + 100, wy1 * warpScale * 0.7 + 100, 3);
+      
+      const wx2 = wx1 + (warp2x - 0.5) * warpStrength * 0.5;
+      const wy2 = wy1 + (warp2y - 0.5) * warpStrength * 0.5;
+      
+      const thickness = fbm(wx2 * scale, wy2 * scale, 5);
+      
+      const swirl = Math.sin(thickness * Math.PI * 4) * 0.5 + 0.5;
+      const finalThickness = thickness * 0.7 + swirl * 0.3;
+      
+      const [ir, ig, ib] = thinFilmInterference(finalThickness);
+      
+      const oilDensity = 0.3 + fbm(x * scale * 2, y * scale * 2, 3) * 0.5;
+      
+      const darkening = 0.85 + finalThickness * 0.15;
+      
+      const [pr, pg, pb] = getPixel(prev, x, y);
+      
+      const baseR = pr * darkening;
+      const baseG = pg * darkening;
+      const baseB = pb * darkening;
+      
+      const nr = baseR * (1 - oilDensity) + (ir * 255) * oilDensity;
+      const ng = baseG * (1 - oilDensity) + (ig * 255) * oilDensity;
+      const nb = baseB * (1 - oilDensity) + (ib * 255) * oilDensity;
+      
+      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
+    }
+  }
+  
+  return out;
+}
+
 function fnTilde(ctx: FnContext, n: number): Image {
\ No newline at end of file

</tool.toolu_01S8xYESp7scEMdZY2MheVuf>

## git-commit-message

<tool.toolu_01S8xYESp7scEMdZY2MheVuf>
Add fnOilSlick function for procedural oil slick effect
</tool.toolu_01S8xYESp7scEMdZY2MheVuf>

# TOOL RESULT

ID: toolu_01S8xYESp7scEMdZY2MheVuf

<tool.toolu_01S8xYESp7scEMdZY2MheVuf>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Add fnOilSlick function for procedural oil slick effect
</tool.toolu_01S8xYESp7scEMdZY2MheVuf>

# ASSISTANT

Now update the 'O' character definition to use the new function:

# TOOL USE

Name: str-replace
ID: toolu_01C4F1pBwkViXNTTgs1gpYYe

## path

<tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>
character-defs.ts
</tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>

## git-commit-message

<tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>
Update O character to use oil-slick effect
</tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>

## diff

<tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>
   'O': {
     color: '#FF6347',
     number: 15,
-    fn: fnApostrophe,
+    fn: fnOilSlick,
     arity: 1,
     argTypes: ['int'],
-    functionName: "vertical-streaks",
-    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
+    functionName: "oil-slick",
+    documentation: "Procedural oil slick with thin-film interference iridescence, domain-warped for organic swirling patterns; n controls scale"
   },
\ No newline at end of file

</tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>

# TOOL RESULT

ID: toolu_01C4F1pBwkViXNTTgs1gpYYe

<tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update O character to use oil-slick effect
</tool.toolu_01C4F1pBwkViXNTTgs1gpYYe>

# ASSISTANT

Let me verify it compiles by checking for any syntax errors:

# TOOL USE

Name: shell-command
ID: toolu_01P9JVMKBamnwwRUfeFL9yk4

## command

<tool.toolu_01P9JVMKBamnwwRUfeFL9yk4>
cd /Users/ajansson/projects/ascii-language && npx tsc --noEmit 2>&1 | head -30
</tool.toolu_01P9JVMKBamnwwRUfeFL9yk4>

# TOOL RESULT

ID: toolu_01P9JVMKBamnwwRUfeFL9yk4

<tool.toolu_01P9JVMKBamnwwRUfeFL9yk4>

</tool.toolu_01P9JVMKBamnwwRUfeFL9yk4>
# USER

that changes the colors too much, it should still be clear what the previous image is but if the prev is solid, it should show _something_. J does this really well

# THINKING

Signature: ErMDCkYIChgCKkDOfqWAVZWacqmip8vST6PD44G5S1mz2Xym5V7CDKyEFOJ4TtBhIw8HEv+7Kni9lija2/mfJjekzMTxK6eJjWQaEgyetPZH8f0SYrOT+qoaDJEjH6ZrU8lhC6k9HCIwSz1lTFp2dsv9PQtJueSvbMArfq93sC2g0yzRSotYHOELCDY1leqSdkF25SoztpmcKpoCkaalvEZBfw1ed0gWhBCICcoWk0vPtCj0s1MbPkT091LbCwu7YudeMt06OrH7QyZ0oPseMXlYu/OAQKL8dJFiBdpd3Dfu99tgi8exQ15DW6qt8hpxeXrmsyOwyQkp6mIINsS+Q9XRD08OEmJEdBG/gTnvBJk/+W5EbZ4qZSW9nRw54VazcfqPu6vHWLn1HOJQimIo+9xQBuxRBjQlwvm1DiXS+56tmB7YRQmSWEyLHfUInHkMOLNqBiC4lStimulDS/gGh3wMGlR01mHxEy6JFYCOM8bU0Aw4HR7G2FdFTfKJCsNVIgUnW8DFJpPV+THuQgd6foBUgURmUNyTlsz9vQI/Tfa9LdgqL/wlHhm0FjQLRlGA69f5JfJqGAE=

The user wants the oil slick effect to be more subtle - it should still show the previous image clearly, but if the previous image is a solid color, it should still show something interesting.

Let me look at how fnJ (Julia fractal) works to understand the approach:

# ASSISTANT

Let me look at how fnJ (Julia fractal) handles this:

# TOOL USE

Name: ripgrep
ID: toolu_01UFngJomFG4nqETmcm9ZSuC

## pattern

<tool.toolu_01UFngJomFG4nqETmcm9ZSuC>
function fnF\(
</tool.toolu_01UFngJomFG4nqETmcm9ZSuC>

## path

<tool.toolu_01UFngJomFG4nqETmcm9ZSuC>
character-defs.ts
</tool.toolu_01UFngJomFG4nqETmcm9ZSuC>

# TOOL RESULT

ID: toolu_01UFngJomFG4nqETmcm9ZSuC

<tool.toolu_01UFngJomFG4nqETmcm9ZSuC>
404:function fnF(ctx: FnContext, n: number): Image {

</tool.toolu_01UFngJomFG4nqETmcm9ZSuC>

# TOOL USE

Name: read-file
ID: toolu_018ipLbY7vjT16opx8n5n8m4

## path

<tool.toolu_018ipLbY7vjT16opx8n5n8m4>
character-defs.ts
</tool.toolu_018ipLbY7vjT16opx8n5n8m4>

## start-line

<tool.toolu_018ipLbY7vjT16opx8n5n8m4>
404
</tool.toolu_018ipLbY7vjT16opx8n5n8m4>

## end-line

<tool.toolu_018ipLbY7vjT16opx8n5n8m4>
470
</tool.toolu_018ipLbY7vjT16opx8n5n8m4>

# TOOL RESULT

ID: toolu_018ipLbY7vjT16opx8n5n8m4

<tool.toolu_018ipLbY7vjT16opx8n5n8m4>
function fnF(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const zoomPower = Math.max(1, n);
  const scale = Math.pow(0.7, zoomPower);
  const maxIterations = 10 + zoomPower * 5;
  
  const cReal = -0.7;
  const cImag = 0.27015;
  
  const centerReal = 0.15;
  const centerImag = 0.6;
  
  const aspect = ctx.height / ctx.width;
  
  for (let py = 0; py < ctx.height; py++) {
    for (let px = 0; px < ctx.width; px++) {
      let zReal = centerReal + ((px / ctx.width) - 0.5) * 3 * scale;
      let zImag = centerImag + ((py / ctx.height) - 0.5) * 3 * scale * aspect;
      
      let iteration = 0;
      let zReal2 = zReal * zReal;
      let zImag2 = zImag * zImag;
      
      while (iteration < maxIterations && zReal2 + zImag2 < 256) {
        zImag = 2 * zReal * zImag + cImag;
        zReal = zReal2 - zImag2 + cReal;
        zReal2 = zReal * zReal;
        zImag2 = zImag * zImag;
        iteration++;
      }
      
      if (iteration === maxIterations) {
        const [pr, pg, pb] = getPixel(prev, px, py);
        setPixel(out, px, py, pr, pg, pb);
      } else {
        const log_zn = Math.log(zReal2 + zImag2) / 2;
        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
        const smoothed = iteration + 1 - nu;
        
        const t = (smoothed % 20) / 20;
        const sampleX = Math.floor(t * ctx.width);
        const sampleY = py;
        
        const [pr, pg, pb] = getPixel(prev, sampleX, sampleY);
        const brightness = 0.85 + 0.3 * t;
        setPixel(out, px, py, 
          Math.min(255, Math.round(pr * brightness)),
          Math.min(255, Math.round(pg * brightness)),
          Math.min(255, Math.round(pb * brightness)));
      }
    }
  }
  
  return out;
}

function fnG(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const histogram = new Array(256).fill(0);
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
    out.data[i] = gray;
    out.data[i + 1] = gray;
</tool.toolu_018ipLbY7vjT16opx8n5n8m4>

# ASSISTANT

I see - the Julia fractal shows the prev image clearly (inside the set), but uses brightness variations and sampling from different x positions to create interest even on solid colors. Let me revise the oil slick to be more subtle - it should primarily show the prev image but with a thin iridescent sheen on top, and the sheen pattern itself provides visual interest on solids:

# TOOL USE

Name: str-replace
ID: toolu_01TG1XstDh58oDwPTBjmKWzV

## path

<tool.toolu_01TG1XstDh58oDwPTBjmKWzV>
character-defs.ts
</tool.toolu_01TG1XstDh58oDwPTBjmKWzV>

## git-commit-message

<tool.toolu_01TG1XstDh58oDwPTBjmKWzV>
Make oil-slick effect more subtle - preserves prev image better while still showing pattern on solids
</tool.toolu_01TG1XstDh58oDwPTBjmKWzV>

## diff

<tool.toolu_01TG1XstDh58oDwPTBjmKWzV>
 function fnOilSlick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const seed = ctx.images.length * 137.5 + n * 17.3;
   
   const hash = (x: number, y: number, s: number): number => {
-    const n = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
-    return n - Math.floor(n);
+    const val = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
+    return val - Math.floor(val);
   };
   
   const smoothstep = (t: number): number => t * t * (3 - 2 * t);
   
   const noise = (x: number, y: number, s: number): number => {
     const ix = Math.floor(x);
     const iy = Math.floor(y);
     const fx = smoothstep(x - ix);
     const fy = smoothstep(y - iy);
     
     const a = hash(ix, iy, s);
     const b = hash(ix + 1, iy, s);
     const c = hash(ix, iy + 1, s);
     const d = hash(ix + 1, iy + 1, s);
     
     return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
   };
   
   const fbm = (x: number, y: number, octaves: number): number => {
     let value = 0;
     let amplitude = 0.5;
     let frequency = 1;
     let maxValue = 0;
     
     for (let i = 0; i < octaves; i++) {
       value += amplitude * noise(x * frequency, y * frequency, seed + i * 100);
       maxValue += amplitude;
       amplitude *= 0.5;
       frequency *= 2.0;
     }
     
     return value / maxValue;
   };
   
   const thinFilmInterference = (thickness: number): [number, number, number] => {
-    const t = thickness * Math.PI * 2 * 3;
+    const t = thickness * Math.PI * 2 * 4;
     
-    const rWavelength = 1.0;
-    const gWavelength = 0.85;
-    const bWavelength = 0.7;
+    const r = (Math.cos(t) * 0.5 + 0.5);
+    const g = (Math.cos(t + Math.PI * 2 / 3) * 0.5 + 0.5);
+    const b = (Math.cos(t + Math.PI * 4 / 3) * 0.5 + 0.5);
     
-    const r = (Math.cos(t * rWavelength) * 0.5 + 0.5);
-    const g = (Math.cos(t * gWavelength + 0.5) * 0.5 + 0.5);
-    const b = (Math.cos(t * bWavelength + 1.0) * 0.5 + 0.5);
-    
-    const satBoost = 1.3;
-    const avg = (r + g + b) / 3;
-    
-    return [
-      Math.min(1, avg + (r - avg) * satBoost),
-      Math.min(1, avg + (g - avg) * satBoost),
-      Math.min(1, avg + (b - avg) * satBoost)
-    ];
+    return [r, g, b];
   };
   
-  const scale = 0.003 + n * 0.0005;
-  const warpScale = scale * 0.5;
-  const warpStrength = 80 + n * 15;
+  const scale = 0.004 + n * 0.001;
+  const warpScale = scale * 0.4;
+  const warpStrength = 60 + n * 20;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
       const warp1x = fbm(x * warpScale, y * warpScale, 4);
       const warp1y = fbm(x * warpScale + 50, y * warpScale + 50, 4);
       
       const wx1 = x + (warp1x - 0.5) * warpStrength;
       const wy1 = y + (warp1y - 0.5) * warpStrength;
       
-      const warp2x = fbm(wx1 * warpScale * 0.7, wy1 * warpScale * 0.7, 3);
-      const warp2y = fbm(wx1 * warpScale * 0.7 + 100, wy1 * warpScale * 0.7 + 100, 3);
+      const warp2x = fbm(wx1 * warpScale * 0.6, wy1 * warpScale * 0.6, 3);
+      const warp2y = fbm(wx1 * warpScale * 0.6 + 100, wy1 * warpScale * 0.6 + 100, 3);
       
-      const wx2 = wx1 + (warp2x - 0.5) * warpStrength * 0.5;
-      const wy2 = wy1 + (warp2y - 0.5) * warpStrength * 0.5;
+      const wx2 = wx1 + (warp2x - 0.5) * warpStrength * 0.4;
+      const wy2 = wy1 + (warp2y - 0.5) * warpStrength * 0.4;
       
       const thickness = fbm(wx2 * scale, wy2 * scale, 5);
       
-      const swirl = Math.sin(thickness * Math.PI * 4) * 0.5 + 0.5;
-      const finalThickness = thickness * 0.7 + swirl * 0.3;
+      const [ir, ig, ib] = thinFilmInterference(thickness);
       
-      const [ir, ig, ib] = thinFilmInterference(finalThickness);
-      
-      const oilDensity = 0.3 + fbm(x * scale * 2, y * scale * 2, 3) * 0.5;
-      
-      const darkening = 0.85 + finalThickness * 0.15;
-      
       const [pr, pg, pb] = getPixel(prev, x, y);
       
-      const baseR = pr * darkening;
-      const baseG = pg * darkening;
-      const baseB = pb * darkening;
+      const sheenStrength = 0.15 + thickness * 0.1;
       
-      const nr = baseR * (1 - oilDensity) + (ir * 255) * oilDensity;
-      const ng = baseG * (1 - oilDensity) + (ig * 255) * oilDensity;
-      const nb = baseB * (1 - oilDensity) + (ib * 255) * oilDensity;
+      const brightnessVar = 0.92 + thickness * 0.16;
       
-      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
+      const nr = pr * brightnessVar + (ir * 255 - pr) * sheenStrength;
+      const ng = pg * brightnessVar + (ig * 255 - pg) * sheenStrength;
+      const nb = pb * brightnessVar + (ib * 255 - pb) * sheenStrength;
+      
+      setPixel(out, x, y, 
+        Math.max(0, Math.min(255, Math.round(nr))),
+        Math.max(0, Math.min(255, Math.round(ng))),
+        Math.max(0, Math.min(255, Math.round(nb)))
+      );
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01TG1XstDh58oDwPTBjmKWzV>

# TOOL RESULT

ID: toolu_01TG1XstDh58oDwPTBjmKWzV

<tool.toolu_01TG1XstDh58oDwPTBjmKWzV>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Make oil-slick effect more subtle - preserves prev image better while still showing pattern on solids
</tool.toolu_01TG1XstDh58oDwPTBjmKWzV>

# TOOL USE

Name: shell-command
ID: toolu_01HrxgcdWQrVb4gAiLeV2bAM

## command

<tool.toolu_01HrxgcdWQrVb4gAiLeV2bAM>
cd /Users/ajansson/projects/ascii-language && npx tsc --noEmit 2>&1 | head -30
</tool.toolu_01HrxgcdWQrVb4gAiLeV2bAM>

# TOOL RESULT

ID: toolu_01HrxgcdWQrVb4gAiLeV2bAM

<tool.toolu_01HrxgcdWQrVb4gAiLeV2bAM>

</tool.toolu_01HrxgcdWQrVb4gAiLeV2bAM>
# USER

stop trying to compile stuff!

and don't do the weird blend you're currently doing with the original image. the whole original image should feel like oil

# THINKING

Signature: ErkGCkYIChgCKkDRxeMie4DK+E04OGh2Xe8ImfIQQgQfKcLEW4jhRzLmM2mEVFiwl8HBYZ0swjZitE7vPFS54lQo7DYhrMBnWaqeEgwJWY2kNR6AMcK54PcaDF2L2wsOMa7am6cG8yIwW+0TvN7Sv4MV0HZUkWtxQBR/s3UQLq68SEKHvsfuQkQs7EMUsnRbSBBLh9jiCHEqKqAFTYSHqlrIkeoM4r9zzpvHa6IImUlRnb+/7DSYMUIFPgM/j3q6tL/YU09sRVWWA3Xqjmj6qv/kUv3jEay/5wDFcbaK8uqEkS6NV1yeWCX2lshm18571cWLMPz8JHYJQfLmQFgeIMai4zPZYryeilTwCf4fXt39UJf6iPTrEDKsGQ0rh7x2d11HDhl3AGDFni4S9UPok6pAXTGyO45EpJNAmwVT0YMAAs4zo15Wi4Xy9SMD/S3sw9aSQUj8mF3qjWOV2fQs2Ks9Es1u9ePREMCCm4e8T+JZuYFZN+dXzFTRDy/xnAoVRpU4MeSEL15bYZFac5u3nwShi9+SNfOiGEuVGW/kPq7ESNctCnFAXuehdjJ6kKEcyWrMyCudOxXL1VlEFGD+vYdP2WSQ/qa1/E9USXZRuDwvLAm5yr8qkF1kOpARYWMYqnTKVQeLoGEayKTh8VpONbj7e4BhrFFJbYohc5yPxxmBgOpEKN4Xkx8jJH/5XfmLIWZf6eEUIqbBCUC9GoDq848PBISCcMx/hecJF9PDf6AYXwMXZK4Klbr6jVSZTuy8Vt8nFjEt5FPlfREpKklXI3165hXPL47PwyzSvzXiPkoGPFp6li0EHt4KXieBgGFBiNU9x0oc7722i0lD0lWHvFpIekquYxo85oj236YFo8YVldhuFIxgdAKWI8WQ+29FEzOgEQvfeQ3400a0c93jKZvffelC22CXU5KrArVaFv+bnvZ6D0VmSs0RDFxySYHQjV050jtVZ2KeblstkpKgOWClCm6/hy3xU+N1AlliDkAljwTTv/anC+2RuYb1sXDNPSkvozka4157flRu6LoHf5Pbh9Vim1FgOk/SN1CdX4MwSNxIDFnekzGv7gz00ONY8m4jJOidVLqOUJP0GAE=

The user wants me to stop running tsc and to change the oil slick effect. They want the whole image to feel like oil - not a blend where part is original and part is oil. So I should apply the oil effect uniformly across the entire image, making it look like the image is being viewed through/on an oily surface.

Let me revise the approach:
- The entire image should have the oil slick iridescent effect
- The effect should be more like warping/distorting the colors based on the oil pattern
- Use the procedural noise to determine "thickness" which affects the color shift
- The original image should still be recognizable but with an oily sheen everywhere

# TOOL USE

Name: str-replace
ID: toolu_018XuP9DNKLsmWtPLzPasoEW

## path

<tool.toolu_018XuP9DNKLsmWtPLzPasoEW>
character-defs.ts
</tool.toolu_018XuP9DNKLsmWtPLzPasoEW>

## git-commit-message

<tool.toolu_018XuP9DNKLsmWtPLzPasoEW>
Revise oil-slick to apply uniformly - whole image feels oily with thin-film color shifts
</tool.toolu_018XuP9DNKLsmWtPLzPasoEW>

## diff

<tool.toolu_018XuP9DNKLsmWtPLzPasoEW>
 function fnOilSlick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const seed = ctx.images.length * 137.5 + n * 17.3;
   
   const hash = (x: number, y: number, s: number): number => {
     const val = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
     return val - Math.floor(val);
   };
   
   const smoothstep = (t: number): number => t * t * (3 - 2 * t);
   
   const noise = (x: number, y: number, s: number): number => {
     const ix = Math.floor(x);
     const iy = Math.floor(y);
     const fx = smoothstep(x - ix);
     const fy = smoothstep(y - iy);
     
     const a = hash(ix, iy, s);
     const b = hash(ix + 1, iy, s);
     const c = hash(ix, iy + 1, s);
     const d = hash(ix + 1, iy + 1, s);
     
     return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
   };
   
   const fbm = (x: number, y: number, octaves: number): number => {
     let value = 0;
     let amplitude = 0.5;
     let frequency = 1;
     let maxValue = 0;
     
     for (let i = 0; i < octaves; i++) {
       value += amplitude * noise(x * frequency, y * frequency, seed + i * 100);
       maxValue += amplitude;
       amplitude *= 0.5;
       frequency *= 2.0;
     }
     
     return value / maxValue;
   };
   
-  const thinFilmInterference = (thickness: number): [number, number, number] => {
-    const t = thickness * Math.PI * 2 * 4;
-    
-    const r = (Math.cos(t) * 0.5 + 0.5);
-    const g = (Math.cos(t + Math.PI * 2 / 3) * 0.5 + 0.5);
-    const b = (Math.cos(t + Math.PI * 4 / 3) * 0.5 + 0.5);
-    
-    return [r, g, b];
-  };
-  
   const scale = 0.004 + n * 0.001;
   const warpScale = scale * 0.4;
   const warpStrength = 60 + n * 20;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
       const warp1x = fbm(x * warpScale, y * warpScale, 4);
       const warp1y = fbm(x * warpScale + 50, y * warpScale + 50, 4);
       
       const wx1 = x + (warp1x - 0.5) * warpStrength;
       const wy1 = y + (warp1y - 0.5) * warpStrength;
       
       const warp2x = fbm(wx1 * warpScale * 0.6, wy1 * warpScale * 0.6, 3);
       const warp2y = fbm(wx1 * warpScale * 0.6 + 100, wy1 * warpScale * 0.6 + 100, 3);
       
       const wx2 = wx1 + (warp2x - 0.5) * warpStrength * 0.4;
       const wy2 = wy1 + (warp2y - 0.5) * warpStrength * 0.4;
       
       const thickness = fbm(wx2 * scale, wy2 * scale, 5);
       
-      const [ir, ig, ib] = thinFilmInterference(thickness);
+      const hueShift = thickness * 360 * 2;
       
       const [pr, pg, pb] = getPixel(prev, x, y);
+      const [h, s, l] = rgbToHsl(pr, pg, pb);
+      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, Math.min(1, s + 0.2), l);
       
-      const sheenStrength = 0.15 + thickness * 0.1;
-      
-      const brightnessVar = 0.92 + thickness * 0.16;
-      
-      const nr = pr * brightnessVar + (ir * 255 - pr) * sheenStrength;
-      const ng = pg * brightnessVar + (ig * 255 - pg) * sheenStrength;
-      const nb = pb * brightnessVar + (ib * 255 - pb) * sheenStrength;
-      
-      setPixel(out, x, y, 
-        Math.max(0, Math.min(255, Math.round(nr))),
-        Math.max(0, Math.min(255, Math.round(ng))),
-        Math.max(0, Math.min(255, Math.round(nb)))
-      );
+      setPixel(out, x, y, nr, ng, nb);
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_018XuP9DNKLsmWtPLzPasoEW>

# TOOL RESULT

ID: toolu_018XuP9DNKLsmWtPLzPasoEW

<tool.toolu_018XuP9DNKLsmWtPLzPasoEW>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Revise oil-slick to apply uniformly - whole image feels oily with thin-film color shifts
</tool.toolu_018XuP9DNKLsmWtPLzPasoEW>

# ASSISTANT

Now the oil slick effect applies a hue shift across the entire image based on the procedural "thickness" field. The swirling domain-warped noise creates organic oily patterns, and the hue rotates through the spectrum based on thickness (like thin-film interference). On a solid color, you'll see the rainbow iridescent swirls. On a complex image, the whole thing gets that oily color-shifting treatment uniformly.

# USER

you're still blending with the original image. i don't want that! i want the entire original image to be smudged out with the oil

# THINKING

Signature: EsAECkYIChgCKkD6N+64e8Efj7r5p685IOSprtem8PudgQSFv5Gp1sbTYodDc8zaGMkMpBd5YLOkICNVte3JucSVKHLcM5vAMrGpEgzkkSO3yQ1j74L+3ZEaDPz0yYC34m7IuLPqhCIwTW9N0HOy5MIs1JCoX7BDy16uCCq8SPXeMXHcuF9dBSzz+DJOjrDTI3Udem9Wq6jfKqcDWD5sVVCJQQK+GWBfu0FQv+myArQGowuleVIgERXPNJEaAqbHEUnlM88IS7DBtGa6qBRu1RVYVCz+ng7kPmk1nvBJwKcZqnLO+XGfsV31vMtROicVLzPBxFJMznsCxNcKpawQJ8VIL1bmiNg0yXDUWj/uZPtO9zTqLujVm0uKbs/9s1a82u04c+v1nd6x6Hrh5RGc3QTwz9zrGFyS8SpfHX398sV1thFnbhBsGz2IVjRG/rUvBVxg7tQ66+ZzhRHrCfsccEstdWT1e1SkwNcaVDAOaRYDcWL3reggTkAaBi1+wMKOEcM7khOAYAj+W786PiyemF77+biUTjuKn+dBz86RDHvcSjtc6zohZxLEqO5S7LBp1My9wSft3ioLpfFoFQPbDMm3zzTM30SmWpgzFk/zEyZh6XzcH3V8H/RaSfk2+gJv6J1bYpuuvpkUiwYEbuH5zzMMHTRHUNOSCEGapWVrJHRKvoaF+9w2uuRJ1ZVp/014ZRA11quPHC/EKuV399++C7c19QQngcsvNKADsGkvnBv2YsXKgO8pCjDF9hUa3p+JSMToGAE=

The user wants the oil slick effect to actually distort/smudge the original image, not just color shift it. They want the image to look like it's being viewed through oil, with the pixels being displaced/smeared by the oily patterns.

So I should use the noise field to displace the sampling coordinates, creating a smearing/distortion effect. The warping should move pixels around based on the oil pattern.

# TOOL USE

Name: str-replace
ID: toolu_01VD1yA8o41mhP4LojJUXAL2

## path

<tool.toolu_01VD1yA8o41mhP4LojJUXAL2>
character-defs.ts
</tool.toolu_01VD1yA8o41mhP4LojJUXAL2>

## git-commit-message

<tool.toolu_01VD1yA8o41mhP4LojJUXAL2>
Oil-slick now smudges/distorts the image using noise-based displacement
</tool.toolu_01VD1yA8o41mhP4LojJUXAL2>

## diff

<tool.toolu_01VD1yA8o41mhP4LojJUXAL2>
 function fnOilSlick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const seed = ctx.images.length * 137.5 + n * 17.3;
   
   const hash = (x: number, y: number, s: number): number => {
     const val = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
     return val - Math.floor(val);
   };
   
   const smoothstep = (t: number): number => t * t * (3 - 2 * t);
   
   const noise = (x: number, y: number, s: number): number => {
     const ix = Math.floor(x);
     const iy = Math.floor(y);
     const fx = smoothstep(x - ix);
     const fy = smoothstep(y - iy);
     
     const a = hash(ix, iy, s);
     const b = hash(ix + 1, iy, s);
     const c = hash(ix, iy + 1, s);
     const d = hash(ix + 1, iy + 1, s);
     
     return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
   };
   
   const fbm = (x: number, y: number, octaves: number): number => {
     let value = 0;
     let amplitude = 0.5;
     let frequency = 1;
     let maxValue = 0;
     
     for (let i = 0; i < octaves; i++) {
       value += amplitude * noise(x * frequency, y * frequency, seed + i * 100);
       maxValue += amplitude;
       amplitude *= 0.5;
       frequency *= 2.0;
     }
     
     return value / maxValue;
   };
   
-  const scale = 0.004 + n * 0.001;
-  const warpScale = scale * 0.4;
-  const warpStrength = 60 + n * 20;
+  const scale = 0.006 + n * 0.002;
+  const smudgeStrength = 40 + n * 15;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
-      const warp1x = fbm(x * warpScale, y * warpScale, 4);
-      const warp1y = fbm(x * warpScale + 50, y * warpScale + 50, 4);
+      const dx = (fbm(x * scale, y * scale, 5) - 0.5) * smudgeStrength;
+      const dy = (fbm(x * scale + 100, y * scale + 100, 5) - 0.5) * smudgeStrength;
       
-      const wx1 = x + (warp1x - 0.5) * warpStrength;
-      const wy1 = y + (warp1y - 0.5) * warpStrength;
+      const sx = x + dx;
+      const sy = y + dy;
       
-      const warp2x = fbm(wx1 * warpScale * 0.6, wy1 * warpScale * 0.6, 3);
-      const warp2y = fbm(wx1 * warpScale * 0.6 + 100, wy1 * warpScale * 0.6 + 100, 3);
-      
-      const wx2 = wx1 + (warp2x - 0.5) * warpStrength * 0.4;
-      const wy2 = wy1 + (warp2y - 0.5) * warpStrength * 0.4;
-      
-      const thickness = fbm(wx2 * scale, wy2 * scale, 5);
-      
-      const hueShift = thickness * 360 * 2;
-      
-      const [pr, pg, pb] = getPixel(prev, x, y);
-      const [h, s, l] = rgbToHsl(pr, pg, pb);
-      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, Math.min(1, s + 0.2), l);
-      
-      setPixel(out, x, y, nr, ng, nb);
+      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
+      setPixel(out, x, y, r, g, b);
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01VD1yA8o41mhP4LojJUXAL2>

# TOOL RESULT

ID: toolu_01VD1yA8o41mhP4LojJUXAL2

<tool.toolu_01VD1yA8o41mhP4LojJUXAL2>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Oil-slick now smudges/distorts the image using noise-based displacement
</tool.toolu_01VD1yA8o41mhP4LojJUXAL2>

# ASSISTANT

Now the oil slick effect uses noise-based displacement to smudge/warp the entire image. Each pixel samples from a displaced location based on the procedural noise field, creating organic oily distortion patterns across the whole image.

# USER

it doesn't look very oily, make it smudge out more, and make the smudging smoother and less jagged. also add some shades and fake reflective light so it actually looks like oil

# THINKING

Signature: EpIFCkYIChgCKkC02LUzzkfufDgUu+cUGEm7RCVSWJfQsyRN2EfnXH9VHmv8Sc9BY1kp2L2pc8UobeY7C8HVNHNk6n8VwfpS3tIvEgyi+cxR4jCqCN6AcEYaDOTHdCHsKNzLuDu9xSIwF4OFuBIokQb2VQzryk551qCq5HAUBkG/clyLzL4JvishC6fe1PaPofpni98+oJkIKvkDzgAE6FZ6BRth6M+PzxpnSF/O/lfcW4Rse6uggMSKdvxGISttpqkYeWdcpS93BNFSLSIDjLyhNvuWv9cpmFljqBFv/zwtbZ3YQbFwUu9MtisGM6wkVgqpmUa74uoSNZm5XBvYAsu9xZKvXaOASkhoekVebuQTQJPx1nwrwoFaN9R3qkTAzCD5mvDmgNOIfUR+WcRC7rZg9io2XiABlbIv2fQUXYdW8GV+6yAD5P9Mk++uiVXcoR+lsQKnuMSacsXCFCqSfvEsHfBtMnwYexaf4gDaAIzsB2L/hYwvY7H9PCs2WNC2aUcqe7gOT6bcTlnefhjzdH/OJ5i3FgmLrPdDrsAQ9ctHj6dZLqX92gcXwKrslhhT5A4PIrunBhgch5PSPklsxTn4C2zEFDnB12gQlQ2jB+JIVPwJjXEeO11n2tAjy1yOskfEddMV2//wOyBjXH7AG3FpUHc3tHbfzG4Xruz31mxDMLArmur5ErkuZ4VdQ07YuDj1YVIPGLYsSso5svFs2ai8mEaaZr5o3yd5FNGq94AAYOSHAXsCK4G/kpbffesLBmI7x3hWUvOr2zn92zuYxGb5PbQ0tmUIGFKYrx3ePLj3PuJx59/9nHHRx4VtUdIacpik9yTVUvomo5Sus02O9SE4yljqBBlYedHDTaplUKve2Y91TBgB

The user wants:
1. More smudging/distortion
2. Smoother smudging (less jagged) - probably need bilinear interpolation when sampling
3. Add shading and fake reflective highlights to make it look like actual oil

Let me revise the function to:
1. Use bilinear interpolation for smoother sampling
2. Increase the smudge strength
3. Add specular highlights based on the noise gradient (where the "surface" is angled toward a light)
4. Add some darkening/shading based on the noise to simulate depth

# TOOL USE

Name: str-replace
ID: toolu_01HXB51wj62Y6tYFRJbD1HmM

## path

<tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>
character-defs.ts
</tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>

## git-commit-message

<tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>
Oil-slick: more smudging, bilinear sampling, add shading and specular highlights
</tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>

## diff

<tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>
 function fnOilSlick(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const seed = ctx.images.length * 137.5 + n * 17.3;
   
   const hash = (x: number, y: number, s: number): number => {
     const val = Math.sin(x * 127.1 + y * 311.7 + s * 74.3) * 43758.5453;
     return val - Math.floor(val);
   };
   
   const smoothstep = (t: number): number => t * t * (3 - 2 * t);
   
   const noise = (x: number, y: number, s: number): number => {
     const ix = Math.floor(x);
     const iy = Math.floor(y);
     const fx = smoothstep(x - ix);
     const fy = smoothstep(y - iy);
     
     const a = hash(ix, iy, s);
     const b = hash(ix + 1, iy, s);
     const c = hash(ix, iy + 1, s);
     const d = hash(ix + 1, iy + 1, s);
     
     return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
   };
   
   const fbm = (x: number, y: number, octaves: number): number => {
     let value = 0;
     let amplitude = 0.5;
     let frequency = 1;
     let maxValue = 0;
     
     for (let i = 0; i < octaves; i++) {
       value += amplitude * noise(x * frequency, y * frequency, seed + i * 100);
       maxValue += amplitude;
       amplitude *= 0.5;
       frequency *= 2.0;
     }
     
     return value / maxValue;
   };
   
-  const scale = 0.006 + n * 0.002;
-  const smudgeStrength = 40 + n * 15;
+  const sampleBilinear = (img: Image, fx: number, fy: number): [number, number, number] => {
+    const x0 = Math.floor(fx);
+    const y0 = Math.floor(fy);
+    const x1 = x0 + 1;
+    const y1 = y0 + 1;
+    const tx = fx - x0;
+    const ty = fy - y0;
+    
+    const [r00, g00, b00] = getPixel(img, x0, y0);
+    const [r10, g10, b10] = getPixel(img, x1, y0);
+    const [r01, g01, b01] = getPixel(img, x0, y1);
+    const [r11, g11, b11] = getPixel(img, x1, y1);
+    
+    const r = r00 * (1 - tx) * (1 - ty) + r10 * tx * (1 - ty) + r01 * (1 - tx) * ty + r11 * tx * ty;
+    const g = g00 * (1 - tx) * (1 - ty) + g10 * tx * (1 - ty) + g01 * (1 - tx) * ty + g11 * tx * ty;
+    const b = b00 * (1 - tx) * (1 - ty) + b10 * tx * (1 - ty) + b01 * (1 - tx) * ty + b11 * tx * ty;
+    
+    return [r, g, b];
+  };
   
+  const scale = 0.003 + n * 0.001;
+  const smudgeStrength = 80 + n * 25;
+  
+  const lightDir = [0.4, -0.3, 0.8];
+  const lightLen = Math.sqrt(lightDir[0] ** 2 + lightDir[1] ** 2 + lightDir[2] ** 2);
+  lightDir[0] /= lightLen;
+  lightDir[1] /= lightLen;
+  lightDir[2] /= lightLen;
+  
+  const eps = 0.5;
+  
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
-      const dx = (fbm(x * scale, y * scale, 5) - 0.5) * smudgeStrength;
-      const dy = (fbm(x * scale + 100, y * scale + 100, 5) - 0.5) * smudgeStrength;
+      const nx = x * scale;
+      const ny = y * scale;
       
+      const height = fbm(nx, ny, 6);
+      const heightX = fbm(nx + eps * scale, ny, 6);
+      const heightY = fbm(nx, ny + eps * scale, 6);
+      
+      const gradX = (heightX - height) / eps;
+      const gradY = (heightY - height) / eps;
+      
+      const normalX = -gradX * 8;
+      const normalY = -gradY * 8;
+      const normalZ = 1;
+      const nLen = Math.sqrt(normalX ** 2 + normalY ** 2 + normalZ ** 2);
+      
+      const nnx = normalX / nLen;
+      const nny = normalY / nLen;
+      const nnz = normalZ / nLen;
+      
+      const diffuse = Math.max(0, nnx * lightDir[0] + nny * lightDir[1] + nnz * lightDir[2]);
+      
+      const reflectX = 2 * (nnx * lightDir[0] + nny * lightDir[1] + nnz * lightDir[2]) * nnx - lightDir[0];
+      const reflectY = 2 * (nnx * lightDir[0] + nny * lightDir[1] + nnz * lightDir[2]) * nny - lightDir[1];
+      const reflectZ = 2 * (nnx * lightDir[0] + nny * lightDir[1] + nnz * lightDir[2]) * nnz - lightDir[2];
+      const specular = Math.pow(Math.max(0, reflectZ), 32);
+      
+      const dx = gradX * smudgeStrength;
+      const dy = gradY * smudgeStrength;
+      
       const sx = x + dx;
       const sy = y + dy;
       
-      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
-      setPixel(out, x, y, r, g, b);
+      const [r, g, b] = sampleBilinear(prev, sx, sy);
+      
+      const lighting = 0.7 + diffuse * 0.3;
+      const spec = specular * 180;
+      
+      const nr = Math.min(255, r * lighting + spec);
+      const ng = Math.min(255, g * lighting + spec);
+      const nb = Math.min(255, b * lighting + spec);
+      
+      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>

# TOOL RESULT

ID: toolu_01HXB51wj62Y6tYFRJbD1HmM

<tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>

</tool.toolu_01HXB51wj62Y6tYFRJbD1HmM>

# SYSTEM

You are Greger, and expert coding agent.

${greger-prompt-code-style<eval-result-124944350241>
# Code style

## Don't be overly defensive

I don't trust the code you write, so I want you to fail early and loudly.

**Don't** add fallbacks, guards, or try/catch blocks against errors unless I specifically ask you to. I don't trust the code you write so I'd rather fail hard early and detect your errors than softly receive a fallback and not detect your errors.

## Imports go at the top

Don't sprinkle the code with imports unless in very special circumstances or if I explicltly ask you to.

## No unnecessary comments

You have a tendency to comment every line. I'm an expert programmer and I prefer reading code to prose. Most of the time I can read the code faster than the comment to understand what's going on. Only add comments in cases where the code is unintuitive or particularly hard to follow (e.g. custom parsers).

## Read full files

Important: The first time you read a source code file, read the _entire_ file (_not_ piecemeal with start-line and end-line) so you get a real holistic understanding of the logic.

## IMPORTANT: NO SUMMARY DOCUMENTS!!!

IMPORTANT: DON'T write summary documents (e.g. SUMMARY.md, FINAL_REPORT.md) unless the user explicitly asks you to. If you feel the need to explain something, just do it in the chat. The ONLY exception to this rule is if the user explicitly asks you to write up a markdown file on disk.
</eval-result-124944350241>}

# IMPORTANT

Don't try to run the server or build things, I'm running it myself in the background

# USER

I want to create an esoteric programming language for generating images, where _every_ combination of uppercase ascii characters (excluding "invisible characters" like space, return) create an image.

Every character have an associated color, integer, and function.

Some functions have arity 0, some are unary, some are binary (some are maybe ternary?). Arguments to functions may be colors or integers. When arity > 0, the default argument are defined in the function, and color values usually default to the color of the character. Each function outputs a 2D RGB image.

A program is a list of characters that outputs a list of images (where the number of images <= number of characters, since some characters may be function arguments)

Functions have access to the entire history of output images up to the point in the program where they're defined. By convention, each function does some transformation on the previous image.

The first character is always used by its color, creating a single color image. Subsequent characters are parsed until the end of the program string. The default arguments are only used if the last function in the program string is missing inputs.

Note that

These are all valid programs: FJID)WIJF, FH)Y*#, I0ASDFJ0IDFSJOJOSF280EFY2HFUDSOH)DFSHFD, 8DFS632&@DSFJFDJSINCSJNIJSHOF, etc.

Implement this as a table in typescript in the following form:

```
// character-defs.ts
const characterDefs = {
  'A': {
    color: '#78A10F',
    number: 7,
    function: (images, a, c) => ..., // a and c are the arguments here. `images` is passed to as the first argument to every function. width and height are implicit from the previous image. images are inputs to every function. images is a list of 3D tensors, and the function returns a 3D tensor
    arity: 2,
    functionName: "short-name",
    documentation: "one sentence about what the function does"
  }
}
```

I have already made index.html, runtime.ts, and parts of character-defs.ts. You just need to implement the rest of character-defs.ts.

All functions need to be completely deterministic! You must not use the random function anywhere!

Assign a random color to each character, and a number that starts at 1 at `A`, incrementing by one to `Z`, followed by `0` through `9`, followed by symbols.

---

# runtime.ts:

${:sh cat runtime.ts<eval-result-115036704761>import { characterDefs, createSolidImage, createPlaceholderImage, getOldImage, Image, FnContext, CharDef, UPLOAD_CHAR } from './character-defs.js';

interface UploadedImageRef {
  type: 'uploaded';
  index: number;
}

interface ParsedSolidColor {
  type: 'solid';
  identifier: string;
  color: string;
}

interface ParsedUploadedImage {
  type: 'uploaded-image';
  identifier: string;
  uploadIndex: number;
}

interface ParsedFunction {
  type: 'function';
  identifier: string;
  fnDef: CharDef;
  args: (number | string | UploadedImageRef)[];
}

type ParsedOp = ParsedSolidColor | ParsedUploadedImage | ParsedFunction;

class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
  }

  clear(): void {
    this.cache.clear();
  }
}

interface UploadedImageSource {
  blob: Blob;
}

const uploadedSources: UploadedImageSource[] = [];
const uploadedImagesCache: Image[] = [];
let uploadedCacheWidth = 0;
let uploadedCacheHeight = 0;

export function clearUploadedImages(): void {
  uploadedSources.length = 0;
  uploadedImagesCache.length = 0;
  uploadedCacheWidth = 0;
  uploadedCacheHeight = 0;
}

export function addUploadedBlob(blob: Blob): number {
  const index = uploadedSources.length;
  uploadedSources.push({ blob });
  imageCache.clear();
  return index;
}

export function setUploadedBlob(index: number, blob: Blob): void {
  while (uploadedSources.length <= index) {
    uploadedSources.push({ blob: new Blob() });
  }
  uploadedSources[index] = { blob };
  uploadedImagesCache[index] = null as any;
  imageCache.clear();
}

export function getUploadedImageCount(): number {
  return uploadedSources.length;
}

function loadBlobToImage(blob: Blob, width: number, height: number): Promise<Image> {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext('2d')!;
      tempCtx.drawImage(img, 0, 0, width, height);
      const imageData = tempCtx.getImageData(0, 0, width, height);
      URL.revokeObjectURL(img.src);
      resolve({
        width,
        height,
        data: new Uint8ClampedArray(imageData.data)
      });
    };
    img.onerror = () => {
      URL.revokeObjectURL(img.src);
      resolve(createPlaceholderImage(width, height));
    };
    img.src = URL.createObjectURL(blob);
  });
}

export async function preloadUploadedImages(width: number, height: number): Promise<void> {
  if (uploadedCacheWidth === width && uploadedCacheHeight === height) {
    let allCached = true;
    for (let i = 0; i < uploadedSources.length; i++) {
      if (!uploadedImagesCache[i]) {
        allCached = false;
        break;
      }
    }
    if (allCached) return;
  }
  
  if (uploadedCacheWidth !== width || uploadedCacheHeight !== height) {
    uploadedImagesCache.length = 0;
    uploadedCacheWidth = width;
    uploadedCacheHeight = height;
  }
  
  const promises = uploadedSources.map(async (source, index) => {
    if (!uploadedImagesCache[index]) {
      uploadedImagesCache[index] = await loadBlobToImage(source.blob, width, height);
    }
  });
  await Promise.all(promises);
}

export function getUploadedImage(index: number, width: number, height: number): Image {
  if (index >= uploadedSources.length) {
    return createPlaceholderImage(width, height);
  }
  
  if (uploadedImagesCache[index] && uploadedCacheWidth === width && uploadedCacheHeight === height) {
    return uploadedImagesCache[index];
  }
  
  return createPlaceholderImage(width, height);
}

export function getUploadCount(program: string): number {
  const chars = [...program];
  return chars.filter(c => c === UPLOAD_CHAR).length;
}

function isUploadChar(char: string): boolean {
  return char === UPLOAD_CHAR;
}

interface ParseResult {
  ops: ParsedOp[];
  invalidUploadIndices: Set<number>;
}

function parseProgram(program: string): ParseResult {
  console.log(`\n=== PARSING: "${program}" ===`);
  const chars = [...program].filter(c => {
    const code = c.codePointAt(0)!;
    return (code > 32 && code < 127) || c === UPLOAD_CHAR;
  });
  console.log(`Filtered chars: "${chars.join('')}"`);
  
  if (chars.length === 0) {
    console.log('Empty program, returning []');
    return { ops: [], invalidUploadIndices: new Set() };
  }

  const ops: ParsedOp[] = [];
  const invalidUploadIndices = new Set<number>();
  let uploadIndexCounter = 0;
  
  const firstChar = chars[0];
  
  if (isUploadChar(firstChar)) {
    console.log(`[0] First char is upload -> uploaded image ${uploadIndexCounter}`);
    ops.push({
      type: 'uploaded-image',
      identifier: firstChar,
      uploadIndex: uploadIndexCounter++
    });
  } else {
    const firstDef = characterDefs[firstChar];
    const firstColor = firstDef ? firstDef.color : '#000000';
    
    console.log(`[0] First char '${firstChar}' -> solid color ${firstColor}`);
    ops.push({
      type: 'solid',
      identifier: firstChar,
      color: firstColor
    });
  }

  let i = 1;
  while (i < chars.length) {
    const char = chars[i];
    
    if (isUploadChar(char)) {
      console.log(`[${i}] '${char}' is upload char in function position -> INVALID, skipping`);
      invalidUploadIndices.add(uploadIndexCounter++);
      i++;
      continue;
    }
    
    const def = characterDefs[char];
    
    if (!def) {
      console.log(`[${i}] '${char}' undefined, skipping`);
      i++;
      continue;
    }

    const args: (number | string | UploadedImageRef)[] = [];
    let argsConsumed = 0;

    console.log(`[${i}] '${char}' -> ${def.functionName}, arity ${def.arity}`);

    for (let argIdx = 0; argIdx < def.arity; argIdx++) {
      const argType = def.argTypes[argIdx];
      let nextCharIdx = i + 1 + argsConsumed;
      
      // Skip any upload chars in non-index positions
      while (nextCharIdx < chars.length && isUploadChar(chars[nextCharIdx]) && argType !== 'index') {
        console.log(`  arg[${argIdx}] (${argType}): upload char invalid here -> SKIPPING`);
        invalidUploadIndices.add(uploadIndexCounter++);
        argsConsumed++;
        nextCharIdx = i + 1 + argsConsumed;
      }
      
      if (nextCharIdx < chars.length) {
        const argChar = chars[nextCharIdx];
        
        if (isUploadChar(argChar)) {
          // argType must be 'index' here (others were skipped above)
          args.push({ type: 'uploaded', index: uploadIndexCounter++ });
          console.log(`  arg[${argIdx}] (${argType}): upload char -> uploaded image`);
          argsConsumed++;
        } else {
          const argDef = characterDefs[argChar];
          
          if (argDef) {
            if (argType === 'int' || argType === 'index') {
              args.push(argDef.number);
              console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.number}`);
            } else {
              args.push(argDef.color);
              console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.color}`);
            }
            argsConsumed++;
          } else {
            if (argType === 'int' || argType === 'index') {
              args.push(def.number);
              console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.number}`);
            } else {
              args.push(def.color);
              console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.color}`);
            }
          }
        }
      } else {
        if (argType === 'int' || argType === 'index') {
          args.push(def.number);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.number}`);
        } else {
          args.push(def.color);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.color}`);
        }
      }
    }

    const endIndex = i + 1 + argsConsumed;
    const identifier = chars.slice(0, endIndex).join('');
    
    console.log(`  identifier: "${identifier}"`);
    
    ops.push({
      type: 'function',
      identifier,
      fnDef: def,
      args
    });
    
    i += 1 + argsConsumed;
  }

  console.log(`Parsed into ${ops.length} operations, ${invalidUploadIndices.size} invalid uploads`);
  return { ops, invalidUploadIndices };
}

const imageCache = new LRUCache<string, Image>(100);
let lastWidth = 0;
let lastHeight = 0;
let lastUploadCount = 0;

export function runProgram(program: string, width: number, height: number): Image[] {
  console.log(`\n=== EXECUTION: ${width}x${height} ===`);
  
  const currentUploadCount = uploadedSources.length;
  
  if (width !== lastWidth || height !== lastHeight || currentUploadCount !== lastUploadCount) {
    console.log(`Dimensions or uploads changed, clearing cache`);
    imageCache.clear();
    lastWidth = width;
    lastHeight = height;
    lastUploadCount = currentUploadCount;
  }

  const { ops } = parseProgram(program);
  
  if (ops.length === 0) {
    console.log('No operations, returning black image');
    return [createSolidImage(width, height, '#000000')];
  }

  const images: Image[] = [createSolidImage(width, height, '#000000')];
  let cacheHits = 0;
  let cacheMisses = 0;
  
  for (let opIdx = 0; opIdx < ops.length; opIdx++) {
    const op = ops[opIdx];
    console.log(`\n[Op ${opIdx}] identifier="${op.identifier}"`);
    
    const cached = imageCache.get(op.identifier);
    if (cached) {
      console.log(`  âœ“ CACHE HIT`);
      images.push(cached);
      cacheHits++;
      continue;
    }

    console.log(`  âœ— CACHE MISS`);
    cacheMisses++;

    let result: Image;
    
    if (op.type === 'solid') {
      console.log(`  Creating solid image: ${op.color}`);
      result = createSolidImage(width, height, op.color);
    } else if (op.type === 'uploaded-image') {
      console.log(`  Using uploaded image ${op.uploadIndex}`);
      result = getUploadedImage(op.uploadIndex, width, height);
    } else {
      console.log(`  Executing function: ${op.fnDef.functionName} with args:`, op.args);
      const ctx: FnContext = {
        width,
        height,
        images: [...images],
        currentIndex: images.length,
      };
      
      const resolvedArgs = op.args.map((arg, idx) => {
        const argType = op.fnDef.argTypes[idx];
        if (argType === 'index') {
          if (typeof arg === 'object' && arg.type === 'uploaded') {
            return getUploadedImage(arg.index, width, height);
          } else if (typeof arg === 'number') {
            return getOldImage(ctx, arg);
          }
        }
        return arg;
      });
      
      result = op.fnDef.fn(ctx, ...resolvedArgs);
    }
    
    images.push(result);
    imageCache.set(op.identifier, result);
    console.log(`  âœ“ Cached result for "${op.identifier}"`);
  }

  console.log(`\n=== EXECUTION COMPLETE ===`);
  console.log(`Cache hits: ${cacheHits}, Cache misses: ${cacheMisses}`);
  console.log(`Total images: ${images.length}`);
  return images;
}

export function getFinalImage(program: string, width: number, height: number): Image {
  const images = runProgram(program, width, height);
  return images[images.length - 1];
}

export function getParsedOperations(program: string): ParsedOp[] {
  return parseProgram(program).ops;
}

export function getInvalidUploadIndices(program: string): Set<number> {
  return parseProgram(program).invalidUploadIndices;
}

export function getExpectedNextType(program: string): 'function' | 'int' | 'color' | 'index' | 'initial' {
  if (!program || program.length === 0) {
    return 'initial';
  }
  
  const { ops } = parseProgram(program);
  if (ops.length === 0) {
    return 'initial';
  }
  
  const lastOp = ops[ops.length - 1];
  
  if (lastOp.type === 'solid' || lastOp.type === 'uploaded-image') {
    return 'function';
  }
  
  if (lastOp.type === 'function') {
    const def = lastOp.fnDef;
    const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
    const currentOpChars = [...lastOp.identifier.substring(prevIdentifier.length)];
    const argsProvided = currentOpChars.length - 1;
    
    if (argsProvided < def.arity) {
      return def.argTypes[argsProvided] as 'int' | 'color' | 'index';
    }
    
    return 'function';
  }
  
  return 'function';
}

export function getExpectedTypeAtPosition(program: string, cursorPosition: number): 'function' | 'int' | 'color' | 'index' | 'initial' {
  const beforeCursor = program.substring(0, cursorPosition);
  return getExpectedNextType(beforeCursor);
}
</eval-result-115036704761>}

---

# character-defs.ts:

${:sh cat character-defs.ts<eval-result-115036785372>import * as THREE from 'three';
import FFT from 'fft.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

export interface Image {
  width: number;
  height: number;
  data: Uint8ClampedArray;
}

export interface FnContext {
  width: number;
  height: number;
  images: Image[];
  currentIndex: number;
}

export interface CharDef {
  color: string;
  number: number;
  fn: (ctx: FnContext, ...args: any[]) => Image;
  arity: number;
  argTypes: ('int' | 'color' | 'index')[];
  functionName: string;
  documentation: string;
}

export const UPLOAD_CHAR = 'ðŸ–¼';

export function createPlaceholderImage(width: number, height: number): Image {
  const data = new Uint8ClampedArray(width * height * 4);
  const checkSize = 16;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const isLight = (Math.floor(x / checkSize) + Math.floor(y / checkSize)) % 2 === 0;
      const gray = isLight ? 128 : 96;
      data[i] = gray;
      data[i + 1] = gray;
      data[i + 2] = gray;
      data[i + 3] = 255;
    }
  }
  return { width, height, data };
}

let glCanvas: HTMLCanvasElement | null = null;
let gl: WebGLRenderingContext | null = null;
let glTexture: WebGLTexture | null = null;
let glFramebuffer: WebGLFramebuffer | null = null;

function initWebGL(width: number, height: number): WebGLRenderingContext {
  if (!glCanvas || glCanvas.width !== width || glCanvas.height !== height) {
    glCanvas = document.createElement('canvas');
    glCanvas.width = width;
    glCanvas.height = height;
    gl = glCanvas.getContext('webgl', { 
      premultipliedAlpha: false,
      preserveDrawingBuffer: true 
    });
    if (!gl) throw new Error('WebGL not supported');
    
    glTexture = gl.createTexture();
    glFramebuffer = gl.createFramebuffer();
  }
  return gl!;
}

function createShaderProgram(gl: WebGLRenderingContext, vertSource: string, fragSource: string): WebGLProgram {
  const vertShader = gl.createShader(gl.VERTEX_SHADER)!;
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);
  
  const fragShader = gl.createShader(gl.FRAGMENT_SHADER)!;
  gl.shaderSource(fragShader, fragSource);
  gl.compileShader(fragShader);
  
  const program = gl.createProgram()!;
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  
  return program;
}

export function createSolidImage(width: number, height: number, color: string): Image {
  const [r, g, b] = hexToRgb(color);
  const data = new Uint8ClampedArray(width * height * 4);
  for (let i = 0; i < width * height; i++) {
    data[i * 4] = r;
    data[i * 4 + 1] = g;
    data[i * 4 + 2] = b;
    data[i * 4 + 3] = 255;
  }
  return { width, height, data };
}

function hexToRgb(hex: string): [number, number, number] {
  const h = hex.replace('#', '');
  return [
    parseInt(h.substring(0, 2), 16),
    parseInt(h.substring(2, 4), 16),
    parseInt(h.substring(4, 6), 16),
  ];
}

function cloneImage(img: Image): Image {
  return {
    width: img.width,
    height: img.height,
    data: new Uint8ClampedArray(img.data),
  };
}

function getPrevImage(ctx: FnContext): Image {
  if (ctx.images.length === 0) {
    return createSolidImage(ctx.width, ctx.height, '#000000');
  }
  return ctx.images[ctx.images.length - 1];
}

export function getOldImage(ctx: FnContext, j: number): Image {
  if (ctx.images.length === 0) return createSolidImage(ctx.width, ctx.height, '#000000');
  if (ctx.images.length === 1) return ctx.images[0];
  const idx = Math.abs(j) % ctx.images.length;
  return ctx.images[idx];
}

function getPixel(img: Image, x: number, y: number): [number, number, number, number] {
  const cx = Math.max(0, Math.min(img.width - 1, Math.floor(x)));
  const cy = Math.max(0, Math.min(img.height - 1, Math.floor(y)));
  const i = (cy * img.width + cx) * 4;
  return [img.data[i], img.data[i + 1], img.data[i + 2], img.data[i + 3]];
}

function setPixel(img: Image, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {
  if (x < 0 || x >= img.width || y < 0 || y >= img.height) return;
  const i = (y * img.width + x) * 4;
  img.data[i] = r;
  img.data[i + 1] = g;
  img.data[i + 2] = b;
  img.data[i + 3] = a;
}

function rgbToHsl(r: number, g: number, b: number): [number, number, number] {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0, s = 0;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
  }
  
  return [h * 360, s, l];
}

function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  h = h / 360;
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function fnA(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    vec3 renderSphere(vec2 uv, vec2 center, float radius, sampler2D tex) {
      vec2 p = (uv - center) / radius;
      float d = length(p);
      
      if (d > 1.0) return vec3(-1.0);
      
      float z = sqrt(1.0 - d * d);
      vec3 normal = normalize(vec3(p.x, -p.y, z));
      vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.0));
      
      float diffuse = max(dot(normal, lightDir), 0.0);
      float ambient = 0.3;
      float lighting = ambient + diffuse * 0.7;
      
      vec2 texCoord = vec2(
        atan(normal.x, normal.z) / (2.0 * 3.14159) + 0.5,
        acos(normal.y) / 3.14159
      );
      
      vec3 color = texture2D(tex, texCoord).rgb;
      return color * lighting;
    }
    
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;
      vec3 bg = texture2D(texture, vec2(1.0 - uv.x, 1.0 - uv.y)).rgb;
      
      vec2 topRight = vec2(0.75, 0.75);
      vec2 bottomLeft = vec2(0.25, 0.25);
      float radius = 0.15;
      
      vec3 sphere1 = renderSphere(uv, topRight, radius, texture);
      vec3 sphere2 = renderSphere(uv, bottomLeft, radius, texture);
      
      vec3 color = bg;
      if (sphere1.x >= 0.0) color = sphere1;
      if (sphere2.x >= 0.0) color = sphere2;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  const textureLoc = gl.getUniformLocation(program, 'texture');
  const resolutionLoc = gl.getUniformLocation(program, 'resolution');
  
  gl.uniform1i(textureLoc, 0);
  gl.uniform2f(resolutionLoc, ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnB(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const seeds: [number, number][] = [];
  for (let i = 0; i < 36; i++) {
    seeds.push([
      (i * 47) % ctx.width,
      (i * 89) % ctx.height
    ]);
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let minDist = Infinity;
      let closestIdx = 0;
      
      for (let i = 0; i < seeds.length; i++) {
        const dx = x - seeds[i][0];
        const dy = y - seeds[i][1];
        const dist = dx * dx + dy * dy;
        if (dist < minDist) {
          minDist = dist;
          closestIdx = i;
        }
      }
      
      const src = closestIdx % 2 === 0 ? prev : old;
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnC(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const rings = Math.max(2, Math.min(n, 50));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxRadius = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const ringIdx = Math.floor((dist / maxRadius) * rings);
      const [r, g, b] = getPixel(prev, x, y);
      
      if (ringIdx % 2 === 0) {
        setPixel(out, x, y, r, g, b);
      } else {
        const hueShift = (360 / rings) * ringIdx;
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fn5(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const cellSize = Math.max(20, n * 4);
  const cols = Math.max(2, Math.floor(ctx.width / cellSize));
  const rows = Math.max(2, Math.floor(ctx.height / cellSize));
  const totalTriangles = cols * rows * 2;
  
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x0 = Math.floor((col / cols) * ctx.width);
      const y0 = Math.floor((row / rows) * ctx.height);
      const x1 = Math.floor(((col + 1) / cols) * ctx.width);
      const y1 = Math.floor(((row + 1) / rows) * ctx.height);
      const cellW = x1 - x0;
      const cellH = y1 - y0;
      
      const triIndex1 = (row * cols + col) * 2;
      const triIndex2 = triIndex1 + 1;
      
      const hueShift1 = (triIndex1 * 137.5) % 360;
      const hueShift2 = (triIndex2 * 137.5) % 360;
      const lightMod1 = (triIndex1 % 2 === 0) ? 0.15 : -0.15;
      const lightMod2 = (triIndex2 % 2 === 0) ? 0.15 : -0.05;
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const localX = (x - x0) / cellW;
          const localY = (y - y0) / cellH;
          
          const [r, g, b] = getPixel(prev, x, y);
          const [h, s, l] = rgbToHsl(r, g, b);
          const isUpperTriangle = localX + localY < 1;
          
          const hueShift = isUpperTriangle ? hueShift1 : hueShift2;
          const lightMod = isUpperTriangle ? lightMod1 : lightMod2;
          const newL = Math.max(0, Math.min(1, l + lightMod));
          
          const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, Math.min(1, s * 1.3), newL);
          setPixel(out, x, y, nr, ng, nb);
        }
      }
    }
  }
  
  return out;
}

function fnF(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const zoomPower = Math.max(1, n);
  const scale = Math.pow(0.7, zoomPower);
  const maxIterations = 10 + zoomPower * 5;
  
  const cReal = -0.7;
  const cImag = 0.27015;
  
  const centerReal = 0.15;
  const centerImag = 0.6;
  
  const aspect = ctx.height / ctx.width;
  
  for (let py = 0; py < ctx.height; py++) {
    for (let px = 0; px < ctx.width; px++) {
      let zReal = centerReal + ((px / ctx.width) - 0.5) * 3 * scale;
      let zImag = centerImag + ((py / ctx.height) - 0.5) * 3 * scale * aspect;
      
      let iteration = 0;
      let zReal2 = zReal * zReal;
      let zImag2 = zImag * zImag;
      
      while (iteration < maxIterations && zReal2 + zImag2 < 256) {
        zImag = 2 * zReal * zImag + cImag;
        zReal = zReal2 - zImag2 + cReal;
        zReal2 = zReal * zReal;
        zImag2 = zImag * zImag;
        iteration++;
      }
      
      if (iteration === maxIterations) {
        const [pr, pg, pb] = getPixel(prev, px, py);
        setPixel(out, px, py, pr, pg, pb);
      } else {
        const log_zn = Math.log(zReal2 + zImag2) / 2;
        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
        const smoothed = iteration + 1 - nu;
        
        const t = (smoothed % 20) / 20;
        const sampleX = Math.floor(t * ctx.width);
        const sampleY = py;
        
        const [pr, pg, pb] = getPixel(prev, sampleX, sampleY);
        const brightness = 0.85 + 0.3 * t;
        setPixel(out, px, py, 
          Math.min(255, Math.round(pr * brightness)),
          Math.min(255, Math.round(pg * brightness)),
          Math.min(255, Math.round(pb * brightness)));
      }
    }
  }
  
  return out;
}

function fnG(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const histogram = new Array(256).fill(0);
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
    out.data[i] = gray;
    out.data[i + 1] = gray;
    out.data[i + 2] = gray;
    histogram[gray]++;
  }
  
  const numColors = Math.max(2, Math.min(n, 16));
  const colors: [number, number, number][] = [];
  
  for (let i = 0; i < numColors; i++) {
    const hue = (i / numColors) * 360;
    colors.push(hslToRgb(hue, 0.7, 0.5));
  }
  
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = out.data[i];
    const colorIndex = Math.floor((gray / 256) * numColors);
    const clampedIndex = Math.min(colorIndex, numColors - 1);
    
    out.data[i] = colors[clampedIndex][0];
    out.data[i + 1] = colors[clampedIndex][1];
    out.data[i + 2] = colors[clampedIndex][2];
  }
  
  return out;
}

function fnH(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / cx;
      const ny = (y - cy) / cy;
      
      const hourglassWidth = Math.abs(ny);
      const inHourglass = Math.abs(nx) < hourglassWidth;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      const distFromCenter = Math.sqrt(nx * nx + ny * ny);
      const angle = Math.atan2(ny, nx);
      
      if (inHourglass) {
        const gr = Math.floor((1 - Math.abs(ny)) * 255);
        const gg = Math.floor((Math.abs(nx) / Math.max(0.01, hourglassWidth)) * 255);
        const gb = Math.floor(distFromCenter * 180);
        
        const nr = 255 - (pr & gr);
        const ng = 255 - (pg & gg);
        const nb = 255 - (pb & gb);
        
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const gr = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 255);
        const gg = Math.floor((1 - distFromCenter) * 200 + 55);
        const gb = Math.floor(((nx + 1) / 2) * 255);
        
        const nr = (pr + gr) % 256;
        const ng = Math.abs(pg - gg);
        const nb = pb ^ gb;
        
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnI(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = 255 - out.data[i];
    out.data[i + 1] = 255 - out.data[i + 1];
    out.data[i + 2] = 255 - out.data[i + 2];
  }
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  for (let y = 1; y < ctx.height - 1; y++) {
    for (let x = 1; x < ctx.width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const px = getPixel(prev, x + kx, y + ky);
          const gray = px[0] * 0.299 + px[1] * 0.587 + px[2] * 0.114;
          const kernelIdx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kernelIdx];
          gy += gray * sobelY[kernelIdx];
        }
      }
      
      const magnitude = Math.sqrt(gx * gx + gy * gy);
      
      if (magnitude > 50) {
        setPixel(out, x, y, 255, 255, 255);
      }
    }
  }
  
  return out;
}

function fnJ(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = x / ctx.width;
      const ny = y / ctx.height;
      
      const squareSize = Math.max(2, Math.floor(2 + (nx + ny) * 50));
      
      const gridX = Math.floor(x / squareSize);
      const gridY = Math.floor(y / squareSize);
      
      const useOld = (gridX + gridY) % 2 === 0;
      const src = useOld ? old : prev;
      
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnK(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const segments = Math.max(1, Math.min(n + 2, 18));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const angleStep = (Math.PI * 2) / segments;
  const zoom = 1.1;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = (x - cx) * zoom;
      const dy = (y - cy) * zoom;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const segmentAngle = angle % angleStep;
      const mirroredAngle = segmentAngle > angleStep / 2 ? angleStep - segmentAngle : segmentAngle;
      
      const r = Math.sqrt(dx * dx + dy * dy);
      const sx = cx + r * Math.cos(mirroredAngle);
      const sy = cy + r * Math.sin(mirroredAngle);
      
      const [pr, pg, pb] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, pr, pg, pb);
    }
  }
  
  return out;
}

function fnL(ctx: FnContext, old: Image, rot: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const rotation = rot * 0.3;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uModelView;
    uniform mat3 uNormalMatrix;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vPosition = (uModelView * vec4(aPosition, 1.0)).xyz;
      vNormal = uNormalMatrix * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * vec4(vPosition, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightPos;
    uniform vec3 uLightPos2;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTexCoord;
    
    void main() {
      vec3 normal = normalize(vNormal);
      vec3 viewDir = normalize(-vPosition);
      
      // Light 1 - main light
      vec3 lightDir1 = normalize(uLightPos - vPosition);
      vec3 halfDir1 = normalize(lightDir1 + viewDir);
      float diff1 = max(dot(normal, lightDir1), 0.0);
      float spec1 = pow(max(dot(normal, halfDir1), 0.0), 32.0);
      
      // Light 2 - fill light
      vec3 lightDir2 = normalize(uLightPos2 - vPosition);
      vec3 halfDir2 = normalize(lightDir2 + viewDir);
      float diff2 = max(dot(normal, lightDir2), 0.0);
      float spec2 = pow(max(dot(normal, halfDir2), 0.0), 32.0);
      
      float ambient = 0.35;
      float diffuse = diff1 * 0.6 + diff2 * 0.35;
      float specular = (spec1 * 0.8 + spec2 * 0.4);
      
      vec2 tiledCoord = fract(vTexCoord);
      vec3 texColor = texture2D(uTexture, tiledCoord).rgb;
      vec3 color = texColor * (ambient + diffuse) + vec3(1.0) * specular;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const bgVertShader = `
    attribute vec2 aPosition;
    varying vec2 vUV;
    void main() {
      vUV = aPosition * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 0.999, 1.0);
    }
  `;
  
  const bgFragShader = `
    precision highp float;
    uniform sampler2D uBgTexture;
    varying vec2 vUV;
    void main() {
      gl_FragColor = texture2D(uBgTexture, vec2(vUV.x, 1.0 - vUV.y));
    }
  `;
  
  const tubeProgram = createShaderProgram(gl, vertexShader, fragmentShader);
  const bgProgram = createShaderProgram(gl, bgVertShader, bgFragShader);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const positions: number[] = [];
  const normals: number[] = [];
  const texCoords: number[] = [];
  
  const a = 3, b = 2, c = 1;
  const tubeRadius = 0.08;
  const segments = 400;
  const radialSegments = 12;
  
  const cross = (a: number[], b: number[]): number[] => [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
  const normalize = (v: number[]): number[] => {
    const len = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
    if (len < 0.0001) return [1, 0, 0];
    return [v[0]/len, v[1]/len, v[2]/len];
  };
  const dot = (a: number[], b: number[]): number => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  
  const getPoint = (t: number): number[] => [
    Math.sin(a * t) * 0.7,
    Math.sin(b * t) * 0.7,
    Math.sin(c * t) * 0.5
  ];
  
  const getTangent = (t: number): number[] => {
    const eps = 0.0001;
    const p1 = getPoint(t - eps);
    const p2 = getPoint(t + eps);
    return normalize([p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]]);
  };
  
  const frames: {point: number[], normal: number[], binormal: number[]}[] = [];
  
  let prevNormal = [1, 0, 0];
  const firstTan = getTangent(0);
  if (Math.abs(dot(prevNormal, firstTan)) > 0.9) {
    prevNormal = [0, 1, 0];
  }
  prevNormal = normalize(cross(cross(firstTan, prevNormal), firstTan));
  
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const point = getPoint(t);
    const tangent = getTangent(t);
    
    let normal = normalize(cross(cross(tangent, prevNormal), tangent));
    const binormal = normalize(cross(tangent, normal));
    
    frames.push({ point, normal, binormal });
    prevNormal = normal;
  }
  
  const firstFrame = frames[0];
  const lastFrame = frames[segments];
  const twistAngle = Math.atan2(
    dot(lastFrame.normal, firstFrame.binormal),
    dot(lastFrame.normal, firstFrame.normal)
  );
  
  for (let i = 0; i <= segments; i++) {
    const correction = -twistAngle * (i / segments);
    const cos_c = Math.cos(correction), sin_c = Math.sin(correction);
    const f = frames[i];
    const newNormal = [
      f.normal[0] * cos_c + f.binormal[0] * sin_c,
      f.normal[1] * cos_c + f.binormal[1] * sin_c,
      f.normal[2] * cos_c + f.binormal[2] * sin_c
    ];
    const newBinormal = [
      -f.normal[0] * sin_c + f.binormal[0] * cos_c,
      -f.normal[1] * sin_c + f.binormal[1] * cos_c,
      -f.normal[2] * sin_c + f.binormal[2] * cos_c
    ];
    f.normal = newNormal;
    f.binormal = newBinormal;
  }
  
  for (let i = 0; i < segments; i++) {
    const f0 = frames[i];
    const f1 = frames[i + 1];
    
    for (let r = 0; r < radialSegments; r++) {
      const angle0 = (r / radialSegments) * Math.PI * 2;
      const angle1 = ((r + 1) / radialSegments) * Math.PI * 2;
      
      const cos0 = Math.cos(angle0), sin0 = Math.sin(angle0);
      const cos1 = Math.cos(angle1), sin1 = Math.sin(angle1);
      
      const v00 = [
        f0.point[0] + (f0.normal[0] * cos0 + f0.binormal[0] * sin0) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos0 + f0.binormal[1] * sin0) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos0 + f0.binormal[2] * sin0) * tubeRadius
      ];
      const v01 = [
        f0.point[0] + (f0.normal[0] * cos1 + f0.binormal[0] * sin1) * tubeRadius,
        f0.point[1] + (f0.normal[1] * cos1 + f0.binormal[1] * sin1) * tubeRadius,
        f0.point[2] + (f0.normal[2] * cos1 + f0.binormal[2] * sin1) * tubeRadius
      ];
      const v10 = [
        f1.point[0] + (f1.normal[0] * cos0 + f1.binormal[0] * sin0) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos0 + f1.binormal[1] * sin0) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos0 + f1.binormal[2] * sin0) * tubeRadius
      ];
      const v11 = [
        f1.point[0] + (f1.normal[0] * cos1 + f1.binormal[0] * sin1) * tubeRadius,
        f1.point[1] + (f1.normal[1] * cos1 + f1.binormal[1] * sin1) * tubeRadius,
        f1.point[2] + (f1.normal[2] * cos1 + f1.binormal[2] * sin1) * tubeRadius
      ];
      
      const n00 = [f0.normal[0] * cos0 + f0.binormal[0] * sin0, f0.normal[1] * cos0 + f0.binormal[1] * sin0, f0.normal[2] * cos0 + f0.binormal[2] * sin0];
      const n01 = [f0.normal[0] * cos1 + f0.binormal[0] * sin1, f0.normal[1] * cos1 + f0.binormal[1] * sin1, f0.normal[2] * cos1 + f0.binormal[2] * sin1];
      const n10 = [f1.normal[0] * cos0 + f1.binormal[0] * sin0, f1.normal[1] * cos0 + f1.binormal[1] * sin0, f1.normal[2] * cos0 + f1.binormal[2] * sin0];
      const n11 = [f1.normal[0] * cos1 + f1.binormal[0] * sin1, f1.normal[1] * cos1 + f1.binormal[1] * sin1, f1.normal[2] * cos1 + f1.binormal[2] * sin1];
      
      const u0 = i / segments * 3;
      const u1 = (i + 1) / segments * 3;
      const v0 = r / radialSegments;
      const v1 = (r + 1) / radialSegments;
      
      positions.push(...v00, ...v10, ...v11, ...v00, ...v11, ...v01);
      normals.push(...n00, ...n10, ...n11, ...n00, ...n11, ...n01);
      texCoords.push(u0, v0, u1, v0, u1, v1, u0, v0, u1, v1, u0, v1);
    }
  }
  
  gl.enable(gl.DEPTH_TEST);
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  gl.useProgram(bgProgram);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(bgProgram, 'uBgTexture'), 0);
  
  const bgVerts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const bgBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, bgVerts, gl.STATIC_DRAW);
  const bgPosLoc = gl.getAttribLocation(bgProgram, 'aPosition');
  gl.enableVertexAttribArray(bgPosLoc);
  gl.vertexAttribPointer(bgPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.disableVertexAttribArray(bgPosLoc);
  
  gl.useProgram(tubeProgram);
  
  const posLoc = gl.getAttribLocation(tubeProgram, 'aPosition');
  const normLoc = gl.getAttribLocation(tubeProgram, 'aNormal');
  const texLoc = gl.getAttribLocation(tubeProgram, 'aTexCoord');
  
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  
  const normBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  
  const texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 3.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const projection = new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) / (near - far), -1,
    0, 0, (2 * far * near) / (near - far), 0
  ]);
  
  const angleY = -55 * Math.PI / 180 + rotation;
  const angleX = 0.3;
  const cy = Math.cos(angleY), sy = Math.sin(angleY);
  const cx = Math.cos(angleX), sx = Math.sin(angleX);
  const modelView = new Float32Array([
    cy, sy * sx, sy * cx, 0,
    0, cx, -sx, 0,
    -sy, cy * sx, cy * cx, 0,
    0, 0, -2.2, 1
  ]);
  
  const normalMatrix = new Float32Array([
    cy, sy * sx, sy * cx,
    0, cx, -sx,
    -sy, cy * sx, cy * cx
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uProjection'), false, projection);
  gl.uniformMatrix4fv(gl.getUniformLocation(tubeProgram, 'uModelView'), false, modelView);
  gl.uniformMatrix3fv(gl.getUniformLocation(tubeProgram, 'uNormalMatrix'), false, normalMatrix);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos'), 3.0, 3.0, 3.0);
  gl.uniform3f(gl.getUniformLocation(tubeProgram, 'uLightPos2'), -2.0, 1.0, 2.0);
  
  gl.activeTexture(gl.TEXTURE1);
  const tubeTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tubeTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.uniform1i(gl.getUniformLocation(tubeProgram, 'uTexture'), 1);
  
  gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disable(gl.DEPTH_TEST);
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE0);
  gl.deleteTexture(tubeTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(oldTexture);
  gl.deleteBuffer(bgBuffer);
  gl.deleteBuffer(posBuffer);
  gl.deleteBuffer(normBuffer);
  gl.deleteBuffer(texBuffer);
  gl.deleteProgram(tubeProgram);
  gl.deleteProgram(bgProgram);
  gl.useProgram(null);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnM(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hash = (i: number) => {
    const x = Math.sin(i * 127.1 + n * 311.7) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const scale = 12 + hash(0) * 30;
  const freqRatio = 1.02 + hash(1) * 0.1;
  const amp1 = 15 + hash(2) * 80;
  const amp2 = 15 + hash(3) * 80;
  const freq1 = 0.006 + hash(4) * 0.025;
  const angle1 = hash(5) * Math.PI;
  const angle2 = angle1 + (hash(6) - 0.5) * 0.3;
  const phase = hash(7) * Math.PI * 2;
  const hueShift = Math.floor(hash(8) * 360);
  const harmonic1 = 0.3 + hash(9) * 0.7;
  const harmonic2 = hash(10) * 0.5;
  const scaleRatio = 0.95 + hash(11) * 0.1;
  const crossAmp = hash(12) * 40;
  const crossFreq = 0.01 + hash(13) * 0.02;
  
  const cos_a1 = Math.cos(angle1), sin_a1 = Math.sin(angle1);
  const cos_a2 = Math.cos(angle2), sin_a2 = Math.sin(angle2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const rx1 = x * cos_a1 + y * sin_a1;
      const ry1 = -x * sin_a1 + y * cos_a1;
      const rx2 = x * cos_a2 + y * sin_a2;
      const ry2 = -x * sin_a2 + y * cos_a2;
      
      const wobble1 = Math.sin(rx1 * freq1) * amp1 
                    + Math.sin(rx1 * freq1 * 2.1) * amp1 * harmonic1
                    + Math.sin(ry1 * crossFreq) * crossAmp;
      const wobble2 = Math.sin(rx2 * freq1 * freqRatio + phase) * amp2
                    + Math.sin(rx2 * freq1 * freqRatio * 2.3 + phase) * amp2 * harmonic2
                    + Math.sin(ry2 * crossFreq * 1.1) * crossAmp;
      
      const wave1 = ry1 + wobble1;
      const wave2 = ry2 + wobble2;
      
      const line1 = Math.floor(wave1 / scale) % 2;
      const line2 = Math.floor(wave2 / (scale * scaleRatio)) % 2;
      
      const moire = line1 !== line2;
      
      const [r, g, b] = getPixel(prev, x, y);
      
      if (moire) {
        setPixel(out, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnN(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const scale = Math.min(ctx.width, ctx.height);
  const numLights = 15;
  
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const lights: { x: number; y: number; r: number; g: number; b: number; size: number }[] = [];
  for (let i = 0; i < numLights; i++) {
    const px = hash(i * 127.1) * ctx.width;
    const py = hash(i * 311.7) * ctx.height;
    const colorAngle = hash(i * 74.3) * Math.PI * 2;
    const size = 0.03 + hash(i * 191.3) * 0.04;
    lights.push({
      x: px, y: py,
      r: Math.cos(colorAngle) * 0.5 + 0.5,
      g: Math.cos(colorAngle + Math.PI * 2 / 3) * 0.5 + 0.5,
      b: Math.cos(colorAngle + Math.PI * 4 / 3) * 0.5 + 0.5,
      size
    });
  }
  
  const glowRadius = 8;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / (255 * 3);
      
      let tr = (pr / 255) * 0.3;
      let tg = (pg / 255) * 0.3;
      let tb = (pb / 255) * 0.3;
      
      if (brightness > 0.3) {
        let glowSum = 0;
        let glowR = 0, glowG = 0, glowB = 0;
        for (let dy = -glowRadius; dy <= glowRadius; dy += 2) {
          for (let dx = -glowRadius; dx <= glowRadius; dx += 2) {
            const sx = Math.max(0, Math.min(ctx.width - 1, x + dx));
            const sy = Math.max(0, Math.min(ctx.height - 1, y + dy));
            const [sr, sg, sb] = getPixel(prev, sx, sy);
            const sBright = (sr + sg + sb) / (255 * 3);
            if (sBright > 0.3) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              const weight = Math.max(0, 1 - dist / glowRadius);
              glowR += (sr / 255) * weight * sBright;
              glowG += (sg / 255) * weight * sBright;
              glowB += (sb / 255) * weight * sBright;
              glowSum += weight;
            }
          }
        }
        if (glowSum > 0) {
          tr += (glowR / glowSum) * brightness * 1.5;
          tg += (glowG / glowSum) * brightness * 1.5;
          tb += (glowB / glowSum) * brightness * 1.5;
        }
      }
      
      for (const light of lights) {
        const dx = (x - light.x) / scale;
        const dy = (y - light.y) / scale;
        const distSq = dx * dx + dy * dy;
        const glow = (light.size * light.size) / Math.max(0.0001, distSq);
        const cappedGlow = Math.min(1, glow);
        tr += cappedGlow * light.r;
        tg += cappedGlow * light.g;
        tb += cappedGlow * light.b;
      }
      
      setPixel(out, x, y,
        Math.min(255, Math.floor(tr * 255)),
        Math.min(255, Math.floor(tg * 255)),
        Math.min(255, Math.floor(tb * 255))
      );
    }
  }
  
  return out;
}

function fnO(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  
  const multiplier = 1.5 + n * 0.8;
  
  const nextPow2 = (v: number) => {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return v + 1;
  };
  
  const fftW = nextPow2(ctx.width);
  const fftH = nextPow2(ctx.height);
  
  const fftRow = new FFT(fftW);
  const fftCol = new FFT(fftH);
  
  const processChannel = (channel: Float32Array, mult: number, phaseShift: number): Float32Array => {
    const data = new Float64Array(fftW * fftH * 2);
    
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        data[(y * fftW + x) * 2] = channel[y * ctx.width + x];
      }
    }
    
    const rowIn = fftRow.createComplexArray();
    const rowOut = fftRow.createComplexArray();
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.transform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
        data[(y * fftW + x) * 2 + 1] = rowOut[x * 2 + 1];
      }
    }
    
    const colIn = fftCol.createComplexArray();
    const colOut = fftCol.createComplexArray();
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.transform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    const cx = fftW / 2;
    const cy = fftH / 2;
    const maxFreqDist = Math.sqrt(cx * cx + cy * cy);
    const wrapLimit = 255 * fftW * fftH / 4;
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        const i = (y * fftW + x) * 2;
        const re = data[i];
        const im = data[i + 1];
        const mag = Math.sqrt(re * re + im * im);
        let phase = Math.atan2(im, re);
        
        const dx = (x < cx ? x : x - fftW);
        const dy = (y < cy ? y : y - fftH);
        const freqDist = Math.sqrt(dx * dx + dy * dy) / maxFreqDist;
        
        let newMag = mag * mult;
        while (newMag > wrapLimit) {
          newMag = Math.abs(newMag - wrapLimit * 2);
        }
        
        phase += phaseShift * freqDist;
        
        data[i] = newMag * Math.cos(phase);
        data[i + 1] = newMag * Math.sin(phase);
      }
    }
    
    for (let x = 0; x < fftW; x++) {
      for (let y = 0; y < fftH; y++) {
        colIn[y * 2] = data[(y * fftW + x) * 2];
        colIn[y * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftCol.inverseTransform(colOut, colIn);
      for (let y = 0; y < fftH; y++) {
        data[(y * fftW + x) * 2] = colOut[y * 2];
        data[(y * fftW + x) * 2 + 1] = colOut[y * 2 + 1];
      }
    }
    
    for (let y = 0; y < fftH; y++) {
      for (let x = 0; x < fftW; x++) {
        rowIn[x * 2] = data[(y * fftW + x) * 2];
        rowIn[x * 2 + 1] = data[(y * fftW + x) * 2 + 1];
      }
      fftRow.inverseTransform(rowOut, rowIn);
      for (let x = 0; x < fftW; x++) {
        data[(y * fftW + x) * 2] = rowOut[x * 2];
      }
    }
    
    const result = new Float32Array(ctx.width * ctx.height);
    for (let y = 0; y < ctx.height; y++) {
      for (let x = 0; x < ctx.width; x++) {
        result[y * ctx.width + x] = data[(y * fftW + x) * 2];
      }
    }
    
    return result;
  };
  
  const rIn = new Float32Array(ctx.width * ctx.height);
  const gIn = new Float32Array(ctx.width * ctx.height);
  const bIn = new Float32Array(ctx.width * ctx.height);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = y * ctx.width + x;
      rIn[idx] = r;
      gIn[idx] = g;
      bIn[idx] = b;
    }
  }
  
  const rOut = processChannel(rIn, multiplier, 0);
  const gOut = processChannel(gIn, multiplier * 1.1, Math.PI * 0.1);
  const bOut = processChannel(bIn, multiplier * 0.9, -Math.PI * 0.1);
  
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const idx = y * ctx.width + x;
      let r = rOut[idx];
      let g = gOut[idx];
      let b = bOut[idx];
      
      r = ((r % 256) + 256) % 256;
      g = ((g % 256) + 256) % 256;
      b = ((b % 256) + 256) % 256;
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnP(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(2, Math.min(n + 1, 50));
  
  for (let by = 0; by < ctx.height; by += cellSize) {
    for (let bx = 0; bx < ctx.width; bx += cellSize) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      let maxSat = 0;
      let mostSatR = 0, mostSatG = 0, mostSatB = 0;
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
          
          const [h, s, l] = rgbToHsl(r, g, b);
          if (s > maxSat) {
            maxSat = s;
            mostSatR = r;
            mostSatG = g;
            mostSatB = b;
          }
        }
      }
      
      const avgR = Math.round(sumR / count);
      const avgG = Math.round(sumG / count);
      const avgB = Math.round(sumB / count);
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const localX = x - bx;
          const localY = y - by;
          const isTopLeft = localX + localY < cellSize;
          
          if (isTopLeft) {
            setPixel(out, x, y, avgR, avgG, avgB);
          } else {
            setPixel(out, x, y, mostSatR, mostSatG, mostSatB);
          }
        }
      }
    }
  }
  
  return out;
}

let emeraldScene: THREE.Scene | null = null;
let emeraldRenderer: THREE.WebGLRenderer | null = null;
let emeraldCamera: THREE.PerspectiveCamera | null = null;
let emeraldModel: THREE.Group | null = null;
let emeraldModelLoaded = false;
let emeraldLoadPromise: Promise<void> | null = null;
let emeraldComposer: EffectComposer | null = null;

function initEmeraldScene(width: number, height: number) {
  if (!emeraldRenderer || emeraldRenderer.domElement.width !== width || emeraldRenderer.domElement.height !== height) {
    if (emeraldRenderer) {
      emeraldRenderer.dispose();
    }
    
    emeraldRenderer = new THREE.WebGLRenderer({ 
      alpha: true, 
      antialias: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance',
    });
    emeraldRenderer.setSize(width, height);
    emeraldRenderer.setPixelRatio(1);
    emeraldRenderer.setClearColor(0x000000, 0);
    emeraldRenderer.toneMapping = THREE.NoToneMapping;
    emeraldRenderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // Setup bloom for sparkle effect
    emeraldComposer = new EffectComposer(emeraldRenderer);
  }
  
  if (!emeraldScene) {
    emeraldScene = new THREE.Scene();
  }
  
  if (!emeraldCamera) {
    emeraldCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    emeraldCamera.position.set(0, 2, 5);
    emeraldCamera.lookAt(0, 0, 0);
  } else {
    emeraldCamera.aspect = width / height;
    emeraldCamera.updateProjectionMatrix();
  }
}

function loadEmeraldModel(): Promise<void> {
  if (emeraldLoadPromise) {
    return emeraldLoadPromise;
  }
  
  emeraldLoadPromise = new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    loader.load(
      './emerald.glb',
      (gltf) => {
        emeraldModel = gltf.scene;
        
        const box = new THREE.Box3().setFromObject(emeraldModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2.0 / maxDim;
        
        emeraldModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
        emeraldModel.scale.setScalar(scale);
        
        emeraldModelLoaded = true;
        resolve();
      },
      undefined,
      (error) => {
        console.error('Error loading emerald model:', error);
        reject(error);
      }
    );
  });
  
  return emeraldLoadPromise;
}

// Start loading immediately when module loads
export const emeraldReady = loadEmeraldModel();

function fnE(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  
  if (!emeraldModelLoaded || !emeraldModel) {
    throw new Error('Emerald model not loaded - await emeraldReady before rendering');
  }
  
  initEmeraldScene(ctx.width, ctx.height);
  
  while (emeraldScene!.children.length > 0) {
    emeraldScene!.remove(emeraldScene!.children[0]);
  }
  
  // Create background texture - preserve original colors
  const bgTexture = new THREE.DataTexture(
    prev.data,
    prev.width,
    prev.height,
    THREE.RGBAFormat
  );
  bgTexture.colorSpace = THREE.SRGBColorSpace;
  bgTexture.needsUpdate = true;
  bgTexture.flipY = true;
  emeraldScene!.background = bgTexture;

  // Create environment map for reflections
  const pmremGenerator = new THREE.PMREMGenerator(emeraldRenderer!);
  pmremGenerator.compileEquirectangularShader();
  const envRT = pmremGenerator.fromEquirectangular(bgTexture);
  emeraldScene!.environment = envRT.texture;

  // Low ambient for more contrast
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
  emeraldScene!.add(ambientLight);
  
  // Strong key light for highlights
  const keyLight = new THREE.DirectionalLight(0xffffff, 5.0);
  keyLight.position.set(5, 8, 10);
  emeraldScene!.add(keyLight);
  
  // Weak fill light - keeps shadows darker
  const fillLight = new THREE.DirectionalLight(0xeeffee, 0.8);
  fillLight.position.set(-5, 3, 8);
  emeraldScene!.add(fillLight);
  
  // Rim lights for edge highlights from multiple angles
  const rimLight = new THREE.DirectionalLight(0xffffff, 2.5);
  rimLight.position.set(0, -2, 8);
  emeraldScene!.add(rimLight);
  
  const rimLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight2.position.set(-6, 0, -2);
  emeraldScene!.add(rimLight2);
  
  const rimLight3 = new THREE.DirectionalLight(0xffffff, 2.0);
  rimLight3.position.set(6, 0, -2);
  emeraldScene!.add(rimLight3);
  
  // Seeded random for deterministic light positions based on image count
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  // Dramatic point lights - fewer but more intense for contrast
  const numLights = 8;
  for (let i = 0; i < numLights; i++) {
    const angle = hash(i * 127.1) * Math.PI * 2;
    const elevation = hash(i * 311.7) * Math.PI * 0.5 + 0.3;
    const distance = 3 + hash(i * 74.3) * 5;
    
    const px = Math.cos(angle) * Math.cos(elevation) * distance;
    const py = Math.sin(elevation) * distance + 2;
    const pz = Math.sin(angle) * Math.cos(elevation) * distance + 4;
    
    const intensity = 15.0 + hash(i * 191.3) * 25.0;
    const light = new THREE.PointLight(0xffffff, intensity, 30);
    light.decay = 2;
    light.position.set(px, py, pz);
    emeraldScene!.add(light);
  }

  // Glass emerald material - pronounced edges with sheen
  const emeraldMaterial = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(0.3, 0.95, 0.5),
    metalness: 0.0,
    roughness: 0.0,
    transmission: 0.92,
    thickness: 0.4,
    ior: 1.3,
    envMapIntensity: 0.25,
    clearcoat: 1.0,
    clearcoatRoughness: 0.0,
    transparent: true,
    side: THREE.DoubleSide,
    flatShading: true,
    attenuationColor: new THREE.Color(0.0, 0.75, 0.25),
    attenuationDistance: 0.4,
    specularIntensity: 1.5,
    specularColor: new THREE.Color(1, 1, 1),
    reflectivity: 0.3,
    sheen: 0.5,
    sheenRoughness: 0.2,
    sheenColor: new THREE.Color(0.8, 1.0, 0.9),
  });
  
  // Corner positions extracted from the emerald geometry
  // Girdle corners (8 points around y â‰ˆ 0.07)
  const girdleCorners = [
    [0.0, 0.064, -0.323],    // front
    [0.227, 0.069, -0.226],  // front-right
    [0.322, 0.063, 0.0],     // right
    [0.224, 0.072, 0.228],   // back-right
    [0.0, 0.064, 0.322],     // back
    [-0.227, 0.07, 0.226],   // back-left
    [-0.322, 0.07, 0.0],     // left (inferred)
    [-0.225, 0.069, -0.227], // front-left
  ];
  
  // Crown corners (upper facet intersections around y â‰ˆ 0.176)
  const crownCorners = [
    [-0.169, 0.176, -0.092],
    [-0.089, 0.176, 0.174],
    [0.169, 0.176, -0.092],  // mirrored
    [0.089, 0.176, 0.174],   // mirrored
    [0.0, 0.176, -0.18],     // front center
    [0.0, 0.176, 0.18],      // back center
    [-0.15, 0.176, 0.0],     // left center
    [0.15, 0.176, 0.0],      // right center
  ];
  
  // Create subtle sparkle sprite texture
  const sparkleCanvas = document.createElement('canvas');
  sparkleCanvas.width = 64;
  sparkleCanvas.height = 64;
  const sctx = sparkleCanvas.getContext('2d')!;
  const cx = 32, cy = 32;
  
  // Soft subtle glow
  const gradient = sctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.3)');
  gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.08)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  sctx.fillStyle = gradient;
  sctx.fillRect(0, 0, 64, 64);
  
  // Very subtle cross rays
  sctx.globalCompositeOperation = 'lighter';
  const rayGradient = sctx.createLinearGradient(0, cy, 64, cy);
  rayGradient.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradient.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradient.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradient.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradient;
  sctx.fillRect(0, cy-1, 64, 2);
  
  const rayGradientV = sctx.createLinearGradient(cx, 0, cx, 64);
  rayGradientV.addColorStop(0, 'rgba(255,255,255,0)');
  rayGradientV.addColorStop(0.35, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(0.5, 'rgba(255,255,255,0.2)');
  rayGradientV.addColorStop(0.65, 'rgba(255,255,255,0.08)');
  rayGradientV.addColorStop(1, 'rgba(255,255,255,0)');
  sctx.fillStyle = rayGradientV;
  sctx.fillRect(cx-1, 0, 2, 64);
  
  const sparkleTexture = new THREE.CanvasTexture(sparkleCanvas);
  
  const createSparkleMaterial = () => new THREE.SpriteMaterial({
    map: sparkleTexture,
    color: 0xffffff,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    depthWrite: false,
  });

  const addEmerald = (x: number, y: number, scale: number, logGeometry: boolean = false) => {
    const gem = emeraldModel!.clone();
    
    gem.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        const geom = child.geometry.clone();
        geom.computeVertexNormals();
        child.geometry = geom;
        child.material = emeraldMaterial;
        child.renderOrder = 1;
        
        // Log geometry info for the first emerald
        if (logGeometry) {
          const positions = geom.attributes.position;
          const normals = geom.attributes.normal;
          
          console.log('=== EMERALD GEOMETRY ===');
          console.log('Vertex count:', positions.count);
          console.log('Triangle count:', positions.count / 3);
          
          // Find unique vertices and their positions
          const uniqueVerts = new Map<string, {pos: number[], count: number, indices: number[]}>();
          
          for (let i = 0; i < positions.count; i++) {
            const px = positions.getX(i).toFixed(3);
            const py = positions.getY(i).toFixed(3);
            const pz = positions.getZ(i).toFixed(3);
            const key = `${px},${py},${pz}`;
            
            if (!uniqueVerts.has(key)) {
              uniqueVerts.set(key, {pos: [parseFloat(px), parseFloat(py), parseFloat(pz)], count: 0, indices: []});
            }
            uniqueVerts.get(key)!.count++;
            uniqueVerts.get(key)!.indices.push(i);
          }
          
          console.log('Unique vertex positions:', uniqueVerts.size);
          
          // Sort by how many triangles share this vertex (corners have more)
          const sorted = [...uniqueVerts.entries()].sort((a, b) => b[1].count - a[1].count);
          
          console.log('\nTop 20 most-shared vertices (likely corners):');
          sorted.slice(0, 20).forEach(([key, data], i) => {
            console.log(`  ${i+1}. [${data.pos.join(', ')}] shared by ${data.count} triangles`);
          });
          
          // Also log bounding box
          geom.computeBoundingBox();
          const bb = geom.boundingBox!;
          console.log('\nBounding box:');
          console.log('  min:', bb.min.x.toFixed(3), bb.min.y.toFixed(3), bb.min.z.toFixed(3));
          console.log('  max:', bb.max.x.toFixed(3), bb.max.y.toFixed(3), bb.max.z.toFixed(3));
        }
      }
    });
    
    gem.scale.setScalar(scale * 3.0);
    gem.position.set(x, y, 0);
    emeraldScene!.add(gem);
    
    // Add sparkle sprites at corner positions
    const allCorners = [...girdleCorners, ...crownCorners];
    const scaleFactor = scale * 3.0;
    
    allCorners.forEach((corner, i) => {
      // Only show sparkles on front-facing corners (positive z)
      if (corner[2] > 0) {
        const sprite = new THREE.Sprite(createSparkleMaterial());
        const sparkleSize = 0.03 + (i % 3) * 0.01;
        sprite.scale.set(sparkleSize * scaleFactor, sparkleSize * scaleFactor, 1);
        // Position at the corner, pushed forward a bit to be visible
        sprite.position.set(
          x + corner[0] * scaleFactor,
          y + corner[1] * scaleFactor,
          corner[2] * scaleFactor + 0.02
        );
        sprite.renderOrder = 10;
        emeraldScene!.add(sprite);
      }
    });
  };
  
  addEmerald(0, 0, 1.0, false);  // Main emerald
  addEmerald(-2.5, 0, 0.5);
  addEmerald(2.5, 0, 0.5);
  addEmerald(-1.5, 1.2, 0.35);
  addEmerald(1.5, 1.2, 0.35);
  addEmerald(-1.5, -1.2, 0.35);
  addEmerald(1.5, -1.2, 0.35);
  
  // Setup bloom passes
  emeraldComposer!.passes = [];
  const renderPass = new RenderPass(emeraldScene!, emeraldCamera!);
  emeraldComposer!.addPass(renderPass);
  
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(ctx.width, ctx.height),
    0.3,
    0.15,
    0.97
  );
  emeraldComposer!.addPass(bloomPass);
  
  // Render multiple times - transmission needs multiple passes to converge
  for (let i = 0; i < 6; i++) {
    emeraldComposer!.render();
  }
  
  const glContext = emeraldRenderer!.getContext();
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  glContext.readPixels(0, 0, ctx.width, ctx.height, glContext.RGBA, glContext.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  // Clean up
  bgTexture.dispose();
  envRT.texture.dispose();
  pmremGenerator.dispose();
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnR(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    #define PI 3.14159265359
    
    // Ray-plane intersection
    float intersectPlane(vec3 ro, vec3 rd, vec3 planeNormal, float planeD) {
      float denom = dot(rd, planeNormal);
      if (abs(denom) < 0.0001) return -1.0;
      return -(dot(ro, planeNormal) + planeD) / denom;
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Camera setup - looking into the room
      vec3 ro = vec3(0.0, 0.0, 2.5); // camera position
      vec2 screenPos = (uv - 0.5) * 2.0;
      screenPos.x *= aspect;
      vec3 rd = normalize(vec3(screenPos * 0.8, -1.0)); // ray direction
      
      // Room dimensions
      float roomSize = 2.0;
      float roomDepth = 3.0;
      
      // Light position (center of room)
      vec3 lightPos = vec3(0.0, 0.0, -roomDepth * 0.4);
      
      // Find closest intersection
      float tMin = 1000.0;
      vec3 hitNormal = vec3(0.0);
      vec2 texCoord = vec2(0.0);
      
      // Back wall (z = -roomDepth)
      float t = intersectPlane(ro, rd, vec3(0.0, 0.0, 1.0), roomDepth);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (abs(hit.x) < roomSize && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 0.0, 1.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Left wall (x = -roomSize)
      t = intersectPlane(ro, rd, vec3(1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(1.0, 0.0, 0.0);
          texCoord = vec2((hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Right wall (x = roomSize)
      t = intersectPlane(ro, rd, vec3(-1.0, 0.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.y) < roomSize) {
          tMin = t;
          hitNormal = vec3(-1.0, 0.0, 0.0);
          texCoord = vec2((hit.z + roomDepth) / (ro.z + roomDepth), hit.y / roomSize * 0.5 + 0.5);
        }
      }
      
      // Floor (y = -roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, 1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, 1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, 1.0 - (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      // Ceiling (y = roomSize)
      t = intersectPlane(ro, rd, vec3(0.0, -1.0, 0.0), roomSize);
      if (t > 0.0 && t < tMin) {
        vec3 hit = ro + rd * t;
        if (hit.z > -roomDepth && hit.z < ro.z && abs(hit.x) < roomSize) {
          tMin = t;
          hitNormal = vec3(0.0, -1.0, 0.0);
          texCoord = vec2(hit.x / roomSize * 0.5 + 0.5, (hit.z + roomDepth) / (ro.z + roomDepth));
        }
      }
      
      vec3 color = vec3(0.0);
      
      if (tMin < 1000.0) {
        vec3 hitPos = ro + rd * tMin;
        
        // Sample texture
        texCoord = clamp(texCoord, 0.0, 1.0);
        vec3 texColor = texture2D(uTexture, texCoord).rgb;
        
        // Lighting
        vec3 toLight = lightPos - hitPos;
        float lightDist = length(toLight);
        vec3 lightDir = toLight / lightDist;
        
        // Diffuse
        float diff = max(dot(hitNormal, lightDir), 0.0);
        
        // Attenuation
        float attenuation = 1.0 / (1.0 + 0.1 * lightDist + 0.05 * lightDist * lightDist);
        
        // Ambient
        float ambient = 0.25;
        
        color = texColor * (ambient + diff * attenuation * 1.5);
      }
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnS(ctx: FnContext, old: Image, size: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const popcount = (n: number): number => {
    let count = 0;
    while (n) {
      count += n & 1;
      n >>= 1;
    }
    return count;
  };
  
  const resolution = Math.pow(2, Math.floor((size - 1) / 10) + 2);
  
  const v0x = ctx.width / 2, v0y = 0;
  const v1x = 0, v1y = ctx.height;
  const v2x = ctx.width, v2y = ctx.height;
  
  const denom = (v1y - v2y) * (v0x - v2x) + (v2x - v1x) * (v0y - v2y);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const baryA = ((v1y - v2y) * (x - v2x) + (v2x - v1x) * (y - v2y)) / denom;
      const baryB = ((v2y - v0y) * (x - v2x) + (v0x - v2x) * (y - v2y)) / denom;
      const baryC = 1 - baryA - baryB;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (baryA < 0 || baryB < 0 || baryC < 0) {
        setPixel(out, x, y, pr, pg, pb);
        continue;
      }
      
      const ai = Math.floor(baryA * resolution);
      const bi = Math.floor(baryB * resolution);
      const ci = Math.floor(baryC * resolution);
      
      const overlap = (ai & bi) | (bi & ci) | (ai & ci);
      const level = popcount(overlap) % 6;
      
      const [or, og, ob] = getPixel(old, x, y);
      
      let r: number, g: number, b: number;
      
      switch (level) {
        case 0: {
          r = or; g = og; b = ob;
          break;
        }
        case 1: {
          r = 255 - pr; g = 255 - pg; b = 255 - pb;
          break;
        }
        case 2: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 120) % 360, s, l);
          break;
        }
        case 3: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 240) % 360, s, l);
          break;
        }
        case 4: {
          const gray = Math.round(pr * 0.299 + pg * 0.587 + pb * 0.114);
          const contrast = gray < 128 ? gray * 0.5 : 128 + (gray - 128) * 1.5;
          r = g = b = Math.max(0, Math.min(255, Math.round(contrast)));
          break;
        }
        case 5: {
          const [h, s, l] = rgbToHsl(pr, pg, pb);
          [r, g, b] = hslToRgb((h + 60) % 360, Math.min(1, s * 1.5), l);
          break;
        }
        default:
          r = pr; g = pg; b = pb;
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewLeft(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (1 - 2 * y / ctx.height);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnSkewRight(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (2 * y / ctx.height - 1);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnT(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numCubes = Math.max(1, n + 1);
  const seed = ctx.images.length * 137.5 + n * 17.0;
  const hash = (i: number) => {
    const x = Math.sin(i + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  interface CubeData {
    cx: number; cy: number; hw: number; hh: number; depth: number;
  }
  const cubesData: CubeData[] = [];
  for (let i = 0; i < numCubes; i++) {
    cubesData.push({
      cx: hash(i * 127.1),
      cy: hash(i * 311.7),
      hw: 0.03 + hash(i * 74.3) * 0.08,
      hh: 0.025 + hash(i * 183.9) * 0.06,
      depth: 0.1 + hash(i * 271.3) * 0.2
    });
  }
  
  const lightDirX = -0.3;
  const lightDirY = -0.4;
  
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec4 worldPos = uModel * vec4(aPosition, 1.0);
      vWorldPos = worldPos.xyz;
      vNormal = mat3(uModel) * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * uView * worldPos;
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightDir;
    uniform float uIsBackground;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec3 color = texture2D(uTexture, vTexCoord).rgb;
      
      if (uIsBackground > 0.5) {
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(uLightDir);
        
        float ambient = 0.5;
        float diffuse = max(dot(normal, lightDir), 0.0) * 0.5;
        float lighting = ambient + diffuse;
        
        gl_FragColor = vec4(color * lighting, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  function createBox(cx: number, cy: number, hw: number, hh: number, depth: number): { vertices: number[], normals: number[], texCoords: number[] } {
    const x0 = cx - hw, x1 = cx + hw;
    const y0 = cy - hh, y1 = cy + hh;
    const z0 = 0, z1 = depth;
    
    const u0 = cx - hw, u1 = cx + hw;
    const v0 = cy - hh, v1 = cy + hh;
    
    const vertices: number[] = [];
    const normals: number[] = [];
    const texCoords: number[] = [];
    
    // Top face - textured with image at this position
    vertices.push(x0,y0,z1, x1,y0,z1, x1,y1,z1, x0,y0,z1, x1,y1,z1, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(0,0,1);
    texCoords.push(u0,v0, u1,v0, u1,v1, u0,v0, u1,v1, u0,v1);
    
    // Right face (+x)
    vertices.push(x1,y0,z0, x1,y0,z1, x1,y1,z1, x1,y0,z0, x1,y1,z1, x1,y1,z0);
    for(let i=0;i<6;i++) normals.push(1,0,0);
    texCoords.push(u1,v0, u1,v0, u1,v1, u1,v0, u1,v1, u1,v1);
    
    // Left face (-x)
    vertices.push(x0,y0,z1, x0,y0,z0, x0,y1,z0, x0,y0,z1, x0,y1,z0, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(-1,0,0);
    texCoords.push(u0,v0, u0,v0, u0,v1, u0,v0, u0,v1, u0,v1);
    
    // Front face (+y)
    vertices.push(x0,y1,z1, x1,y1,z1, x1,y1,z0, x0,y1,z1, x1,y1,z0, x0,y1,z0);
    for(let i=0;i<6;i++) normals.push(0,1,0);
    texCoords.push(u0,v1, u1,v1, u1,v1, u0,v1, u1,v1, u0,v1);
    
    // Back face (-y)
    vertices.push(x0,y0,z0, x1,y0,z0, x1,y0,z1, x0,y0,z0, x1,y0,z1, x0,y0,z1);
    for(let i=0;i<6;i++) normals.push(0,-1,0);
    texCoords.push(u0,v0, u1,v0, u1,v0, u0,v0, u1,v0, u0,v0);
    
    return { vertices, normals, texCoords };
  }
  
  const allVertices: number[] = [];
  const allNormals: number[] = [];
  const allTexCoords: number[] = [];
  
  for (const c of cubesData) {
    const box = createBox(c.cx, c.cy, c.hw, c.hh, c.depth);
    allVertices.push(...box.vertices);
    allNormals.push(...box.normals);
    allTexCoords.push(...box.texCoords);
  }
  
  gl.useProgram(program);
  gl.disable(gl.DEPTH_TEST);
  
  const bgVertices = new Float32Array([0,0,0, 1,0,0, 1,1,0, 0,0,0, 1,1,0, 0,1,0]);
  const bgNormals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]);
  const bgTexCoords = new Float32Array([0,0, 1,0, 1,1, 0,0, 1,1, 0,1]);
  
  const posLoc = gl.getAttribLocation(program, 'aPosition');
  const normLoc = gl.getAttribLocation(program, 'aNormal');
  const texLoc = gl.getAttribLocation(program, 'aTexCoord');
  
  const identity = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  const ortho = new Float32Array([2,0,0,0, 0,2,0,0, 0,0,-1,0, -1,-1,0,1]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, ortho);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, identity);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uModel'), false, identity);
  gl.uniform3f(gl.getUniformLocation(program, 'uLightDir'), lightDirX, lightDirY, 1.0);
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 1.0);
  
  const bgPosBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgPosBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgNormBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgNormBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgNormals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgTexBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgTexCoords, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 2.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const perspective = new Float32Array([
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)/(near-far), -1,
    0, 0, (2*far*near)/(near-far), 0
  ]);
  
  const camZ = 0.5 / Math.tan(fov / 2);
  const view = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -0.5, -0.5, -camZ, 1
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, perspective);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, view);
  gl.uniform1f(gl.getUniformLocation(program, 'uIsBackground'), 0.0);
  
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const normBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const texBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allTexCoords), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, allVertices.length / 3);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = (y * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.disable(gl.DEPTH_TEST);
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(bgPosBuf);
  gl.deleteBuffer(bgNormBuf);
  gl.deleteBuffer(bgTexBuf);
  gl.deleteBuffer(posBuf);
  gl.deleteBuffer(normBuf);
  gl.deleteBuffer(texBuf);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnU(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const w = ctx.width;
  const h = ctx.height;
  
  const hueAmount = 90 + (n % 12) * 15;
  const satAmount = 0.5 + (n % 8) * 0.1;
  const lightAmount = 0.06 + (n % 8) * 0.01;
  
  const baseAngle = n * 0.5;
  const angleH = baseAngle;
  const angleS = baseAngle + Math.PI * 2 / 3;
  const angleL = baseAngle + Math.PI * 4 / 3;
  
  const dirHX = Math.cos(angleH);
  const dirHY = Math.sin(angleH);
  const dirSX = Math.cos(angleS);
  const dirSY = Math.sin(angleS);
  const dirLX = Math.cos(angleL);
  const dirLY = Math.sin(angleL);
  
  const cx = w / 2;
  const cy = h / 2;
  const maxDist = Math.sqrt(cx * cx + cy * cy);
  
  const out = createSolidImage(w, h, '#000000');
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const [origR, origG, origB] = getPixel(prev, x, y);
      let [oh, os, ol] = rgbToHsl(origR, origG, origB);
      
      const rx = x - cx;
      const ry = y - cy;
      
      const tH = (rx * dirHX + ry * dirHY) / maxDist;
      const tS = (rx * dirSX + ry * dirSY) / maxDist;
      const tL = (rx * dirLX + ry * dirLY) / maxDist;
      
      const hueShift = tH * hueAmount;
      let nh = (oh + hueShift + 360) % 360;
      
      const satMod = 1 + Math.abs(tS) * satAmount;
      let ns = Math.min(1, os * satMod);
      
      const midtoneFactor = 1 - Math.pow(Math.abs(ol - 0.5) * 2, 2);
      const lightShift = tL * lightAmount * midtoneFactor;
      let nl = Math.max(0.05, Math.min(0.95, ol + lightShift));
      
      const [r, g, b] = hslToRgb(nh, ns, nl);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnV(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [tr, tg, tb] = hexToRgb(c);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy) * 0.7;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const vignette = Math.max(0, 1 - Math.pow(dist / maxR, 2));
      const darken = vignette;
      const tint = 1 - vignette;
      
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * darken + tr * tint * 0.5);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * darken + tg * tint * 0.5);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * darken + tb * tint * 0.5);
    }
  }
  
  return out;
}

function fnW(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const maxRotation = (n * 20) * (Math.PI / 180);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const falloff = (1 - normDist) * (1 - normDist);
      const rotation = maxRotation * falloff;
      
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const sx = cx + dx * cos - dy * sin;
      const sy = cy + dx * sin + dy * cos;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnX(ctx: FnContext, k: number, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const shapes = [
    'â˜…', 'â—', 'â– ', 'â–²', 'â—†', 'â™¥', 'âœ¦', 'â¬¡', 'âœš', 'â—', 'â˜½', 'âš¡', 'âˆž', 'â˜€', 'âœ¿', 'â¬¢',
    'â—¯', 'â–³', 'â–¡', 'â—‡', 'â™¦', 'â™£', 'â™ ', 'â¬Ÿ', 'â¬ ', 'â–½', 'â—', 'â–·', 'âŠ•', 'âŠ—', 'âŠ›', 'âŠš',
    'â–£', 'â–¤', 'â–¥', 'â–¦', 'â–§', 'â–¨', 'â–©', 'â¬£', 'â¬¤', 'â—‰', 'â—Ž', 'â—ˆ', 'â—Š', 'â—‹', 'â—Œ', 'â—',
    'â—¢', 'â—£', 'â—¤', 'â—¥', 'â™¯', 'â™®', 'â™©', 'â™ª', 'âœ¶', 'âœ´', 'âœ³', 'âœ²', 'âœ±', 'âœ°', 'âœ¯', 'âœ®'
  ];
  
  const shapeIdx = Math.abs(k) % 64;
  const symbol = shapes[shapeIdx];
  
  const size = Math.min(ctx.width, ctx.height) * 0.9;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = 'black';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  tempCtx.fillStyle = 'white';
  tempCtx.font = `${size}px serif`;
  tempCtx.textAlign = 'center';
  tempCtx.textBaseline = 'alphabetic';
  
  const metrics = tempCtx.measureText(symbol);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const yOffset = metrics.actualBoundingBoxAscent - actualHeight / 2;
  
  tempCtx.fillText(symbol, ctx.width / 2, ctx.height / 2 + yOffset);
  
  const maskData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  
  let avgR = 0, avgG = 0, avgB = 0;
  for (let i = 0; i < prev.data.length; i += 4) {
    avgR += prev.data[i];
    avgG += prev.data[i + 1];
    avgB += prev.data[i + 2];
  }
  const numPixels = prev.data.length / 4;
  avgR = Math.round(avgR / numPixels);
  avgG = Math.round(avgG / numPixels);
  avgB = Math.round(avgB / numPixels);
  
  for (let y = 0; y < ctx.height; y++) {
    const t = y / ctx.height;
    
    const gr = cr * (1 - t) + avgR * t;
    const gg = cg * (1 - t) + avgG * t;
    const gb = cb * (1 - t) + avgB * t;
    
    for (let x = 0; x < ctx.width; x++) {
      const maskIdx = (y * ctx.width + x) * 4;
      if (maskData.data[maskIdx] > 128) {
        const [pr, pg, pb] = getPixel(prev, x, y);
        const nr = Math.round(gr * 0.9 + pr * 0.1);
        const ng = Math.round(gg * 0.9 + pg * 0.1);
        const nb = Math.round(gb * 0.9 + pb * 0.1);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnY(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const sections = Math.max(2, Math.min(n, 36));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const sectionIdx = Math.floor(angle / (Math.PI * 2) * sections);
      const hueShift = (sectionIdx / sections) * 360;
      
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnZ(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const blurAmount = n * 4;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const sharpRadius = 0.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      if (normDist < sharpRadius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const blurStrength = Math.min(1, (normDist - sharpRadius) / (1 - sharpRadius));
        const samples = Math.max(1, Math.floor(blurStrength * blurAmount / 2));
        
        let sumR = 0, sumG = 0, sumB = 0;
        for (let i = 0; i <= samples; i++) {
          const t = i / samples;
          const sx = cx + dx * (1 - t * blurStrength * 0.5);
          const sy = cy + dy * (1 - t * blurStrength * 0.5);
          const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
          sumR += r;
          sumG += g;
          sumB += b;
        }
        
        setPixel(out, x, y, 
          Math.round(sumR / (samples + 1)),
          Math.round(sumG / (samples + 1)),
          Math.round(sumB / (samples + 1))
        );
      }
    }
  }
  
  return out;
}

function fnQ(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const temp = createSolidImage(hw, hh, '#000000');
  
  for (let y = 0; y < hh; y++) {
    for (let x = 0; x < hw; x++) {
      const sx = (x / hw) * prev.width;
      const sy = (y / hh) * prev.height;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      if (x / hw + y / hh > 1) {
        setPixel(temp, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(temp, x, y, r, g, b);
      }
    }
  }
  
  for (let qy = 0; qy < 2; qy++) {
    for (let qx = 0; qx < 2; qx++) {
      for (let y = 0; y < hh; y++) {
        for (let x = 0; x < hw; x++) {
          const outX = qx * hw + x;
          const outY = qy * hh + y;
          if (outX < ctx.width && outY < ctx.height) {
            const srcX = qx === 1 ? hw - 1 - x : x;
            const srcY = qy === 1 ? hh - 1 - y : y;
            const [r, g, b] = getPixel(temp, srcX, srcY);
            setPixel(out, outX, outY, r, g, b);
          }
        }
      }
    }
  }
  
  return out;
}

function fn0(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const nr = pr < 128 ? (2 * pr * or) / 255 : 255 - (2 * (255 - pr) * (255 - or)) / 255;
      const ng = pg < 128 ? (2 * pg * og) / 255 : 255 - (2 * (255 - pg) * (255 - og)) / 255;
      const nb = pb < 128 ? (2 * pb * ob) / 255 : 255 - (2 * (255 - pb) * (255 - ob)) / 255;
      
      setPixel(out, x, y, Math.round(nr), Math.round(ng), Math.round(nb));
    }
  }
  
  return out;
}

function fn1(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const barStart = Math.floor(ctx.width / 3);
  const barEnd = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (x >= barStart && x < barEnd) {
        let sr = 0, sg = 0, sb = 0;
        const kernel = [
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0]
        ];
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = kernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        sr = Math.max(0, Math.min(255, sr));
        sg = Math.max(0, Math.min(255, sg));
        sb = Math.max(0, Math.min(255, sb));
        
        const contrast = 1.3;
        sr = Math.max(0, Math.min(255, ((sr / 255 - 0.5) * contrast + 0.5) * 255));
        sg = Math.max(0, Math.min(255, ((sg / 255 - 0.5) * contrast + 0.5) * 255));
        sb = Math.max(0, Math.min(255, ((sb / 255 - 0.5) * contrast + 0.5) * 255));
        
        setPixel(out, x, y, Math.round(sr), Math.round(sg), Math.round(sb));
      } else {
        const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
        setPixel(out, x, y, gray, gray, gray);
      }
    }
  }
  
  return out;
}

function fn2(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const len = ctx.images.length;
  const img3 = len >= 3 ? ctx.images[len - 3] : (len >= 1 ? ctx.images[0] : prev);
  const img2 = len >= 2 ? ctx.images[len - 2] : prev;
  const img1 = prev;
  
  const third1 = Math.floor(ctx.width / 3);
  const third2 = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let src: Image;
      if (x < third1) {
        src = img3;
      } else if (x < third2) {
        src = img2;
      } else {
        src = img1;
      }
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn3(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripWidth = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < stripWidth; x++) {
      const srcX = Math.floor((y / ctx.height) * stripWidth);
      const srcY = Math.floor(((stripWidth - 1 - x) / stripWidth) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth; x < stripWidth * 2; x++) {
      const srcX = Math.floor(((x - stripWidth) / stripWidth) * stripWidth + stripWidth);
      const srcY = y;
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth * 2; x < ctx.width; x++) {
      const localX = x - stripWidth * 2;
      const srcX = Math.floor(((ctx.height - 1 - y) / ctx.height) * (ctx.width - stripWidth * 2) + stripWidth * 2);
      const srcY = Math.floor((localX / (ctx.width - stripWidth * 2)) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn4(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const rotatePoint = (x: number, y: number, cx: number, cy: number, angle: number): [number, number] => {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
  };
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const qx = x < hw ? 0 : 1;
      const qy = y < hh ? 0 : 1;
      const quadrant = qy * 2 + qx;
      const angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2];
      const angle = angles[quadrant];
      
      const localCx = qx === 0 ? hw / 2 : hw + hw / 2;
      const localCy = qy === 0 ? hh / 2 : hh + hh / 2;
      
      const [srcX, srcY] = rotatePoint(x, y, localCx, localCy, -angle);
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnD(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const n = 7;
  const numDrips = Math.max(1, n * 3);
  const dripStrength = Math.max(0.5, Math.min(n * 0.2 + 0.8, 2.0));
  const seed = ctx.images.length * 137.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uStrength;
    uniform int uNumDrips;
    uniform float uSeed;
    varying vec2 vUV;
    
    #define MAX_DRIPS 100
    #define MAX_STEPS 64
    #define WALL_Z 0.0
    #define EPS 0.001
    
    float hash(float n) {
      return fract(sin(n) * 43758.5453123);
    }
    
    // Smooth min for organic blending
    float smin(float a, float b, float k) {
      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
      return mix(b, a, h) - k * h * (1.0 - h);
    }
    
    // Simple sphere SDF
    float sdSphere(vec3 p, vec3 center, float r) {
      return length(p - center) - r;
    }
    
    // Scene SDF - randomly distributed clusters of 4 metaballs each
    float sceneSDF(vec3 p, int numClusters, float strength) {
      float d = 1000.0;
      
      for (int i = 0; i < MAX_DRIPS; i++) {
        if (i >= numClusters) break;
        
        float fi = float(i);
        
        // Random cluster center position across full screen (seeded by image count)
        float clusterX = (hash(fi * 127.1 + uSeed) * 2.0 - 1.0) * 1.5;
        float clusterY = (hash(fi * 311.7 + uSeed) * 2.0 - 1.0) * 1.2;
        
        // Cluster size
        float clusterSize = 0.15 + hash(fi * 74.3 + uSeed) * 0.15;
        
        // 4 balls per cluster (fixed to avoid dynamic loop issues)
        for (int j = 0; j < 4; j++) {
          float fj = float(j);
          float localSeed = fi * 100.0 + fj + uSeed;
          
          // Random offset from cluster center
          float offX = (hash(localSeed * 123.4) - 0.5) * clusterSize;
          float offY = (hash(localSeed * 234.5) - 0.5) * clusterSize * 1.5; // More vertical spread
          
          float x = clusterX + offX;
          float y = clusterY + offY;
          
          // Varying ball sizes within cluster
          float r = (0.06 + hash(localSeed * 345.6) * 0.08) * strength * 0.6;
          
          float z = 0.05 + r * 0.3;
          
          vec3 center = vec3(x, y, z);
          float sphere = sdSphere(p, center, r);
          
          // Smooth blend to merge balls in cluster
          d = smin(d, sphere, 0.12);
        }
      }
      
      return d;
    }
    
    // Calculate normal via gradient
    vec3 calcNormal(vec3 p, int numDrips, float strength) {
      vec2 e = vec2(0.001, 0.0);
      return normalize(vec3(
        sceneSDF(p + e.xyy, numDrips, strength) - sceneSDF(p - e.xyy, numDrips, strength),
        sceneSDF(p + e.yxy, numDrips, strength) - sceneSDF(p - e.yxy, numDrips, strength),
        sceneSDF(p + e.yyx, numDrips, strength) - sceneSDF(p - e.yyx, numDrips, strength)
      ));
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Ray origin and direction (orthographic-ish camera)
      vec3 ro = vec3((uv.x * 2.0 - 1.0) * aspect, uv.y * 2.0 - 1.0, 2.0);
      vec3 rd = vec3(0.0, 0.0, -1.0);
      
      // Raymarch to find metaball surface
      float t = 0.0;
      float d = 0.0;
      bool hit = false;
      vec3 p;
      
      for (int i = 0; i < MAX_STEPS; i++) {
        p = ro + rd * t;
        d = sceneSDF(p, uNumDrips, uStrength);
        
        if (d < EPS) {
          hit = true;
          break;
        }
        if (t > 4.0) break;
        
        t += d * 0.8;
      }
      
      // Sample wall texture
      vec4 wallColor = texture2D(uTexture, uv);
      
      if (hit) {
        vec3 normal = calcNormal(p, uNumDrips, uStrength);
        
        // Light from top (Y is flipped in screen coords)
        vec3 lightDir = normalize(vec3(0.0, -1.0, 0.6));
        vec3 viewDir = -rd;
        
        // Fresnel - edges reflect more
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
        
        // Specular highlight - bright and sharp
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 120.0);
        
        // Refraction - water has IOR ~1.33, so ratio is 1.0/1.33 â‰ˆ 0.75
        vec3 refracted = refract(rd, normal, 0.75);
        vec2 refractUV = uv + refracted.xy * 0.06;
        refractUV = clamp(refractUV, 0.0, 1.0);
        vec4 refractColor = texture2D(uTexture, refractUV);
        
        // Clear water droplet - mostly shows refracted background
        vec3 dropletColor = refractColor.rgb;
        
        // Slight caustic brightening where light focuses
        float caustic = max(dot(normal, lightDir), 0.0);
        dropletColor *= 1.0 + caustic * 0.15;
        
        // Add crisp specular highlight
        dropletColor += vec3(1.0) * spec * 1.5;
        
        // Subtle rim highlight from fresnel
        dropletColor += vec3(1.0) * fresnel * 0.2;
        
        // Very subtle shadow directly under droplet on wall
        vec2 shadowUV = uv + vec2(0.01, 0.02);
        float shadowMask = smoothstep(0.05, 0.0, d) * 0.15;
        vec3 wallWithShadow = wallColor.rgb * (1.0 - shadowMask);
        
        // Droplet is almost fully transparent, just refracts
        gl_FragColor = vec4(dropletColor, 1.0);
      } else {
        gl_FragColor = wallColor;
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uStrength'), dripStrength);
  gl.uniform1i(gl.getUniformLocation(program, 'uNumDrips'), numDrips);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fn6(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const levels = 4;
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = Math.floor(out.data[i] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 1] = Math.floor(out.data[i + 1] / 256 * levels) * (255 / (levels - 1));
    out.data[i + 2] = Math.floor(out.data[i + 2] / 256 * levels) * (255 / (levels - 1));
  }
  
  return out;
}

function fn7(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r] = getPixel(prev, x - 4, y);
      const [, g] = getPixel(prev, x, y);
      const [, , b] = getPixel(prev, x + 4, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn8(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.1, n / 5);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height) / 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / scale;
      const ny = (y - cy) / scale;
      
      const r2 = nx * nx + ny * ny;
      const denom = r2 + 1;
      
      const lemnX = nx * (r2 - 1) / denom;
      const lemnY = ny * (r2 + 1) / denom;
      
      const sx = cx + (nx + (lemnX - nx) * strength * 0.3) * scale;
      const sy = cy + (ny + (lemnY - ny) * strength * 0.3) * scale;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn9(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r1, g1, b1] = getPixel(prev, x, y);
      const [r2, g2, b2] = getPixel(old, x, y);
      
      setPixel(out, x, y, r1 ^ r2, g1 ^ g2, b1 ^ b2);
    }
  }
  
  return out;
}

function fnLessThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 8);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = (x + shift) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnGreaterThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = y * prev.width / ctx.height;
      const sy = (ctx.width - 1 - x) * prev.height / ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnCaret(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.height / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcY = (y + shift) % ctx.height;
      const [r, g, b] = getPixel(prev, x, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnExclaim(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const hash = (x: number, y: number, seed: number) => {
    const v = Math.sin(x * 127.1 + y * 311.7 + seed * 113.3) * 43758.5453;
    return v - Math.floor(v);
  };
  
  const n = 60;
  const baseLen = 8 + n * 5;
  const chaos = 0.5 + n * 0.15;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      
      if (s < 0.03 && l < 0.03) continue;
      if (l > 0.97) continue;
      
      const hueAngle = (h / 360) * Math.PI * 2;
      
      const turbulence = (hash(x, y, 1) - 0.5) * Math.PI * chaos;
      const swirl = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 0.5;
      
      const angle = hueAngle + turbulence + swirl;
      
      const lenNoise = 0.3 + hash(x, y, 2) * 0.7;
      const len = baseLen * s * (0.2 + l * 0.8) * lenNoise;
      
      if (len < 2) continue;
      
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      
      for (let i = 1; i <= len; i++) {
        const wobble = Math.sin(i * 0.5) * hash(x, y, 3) * 2;
        const px = Math.floor(x + dx * i + dy * wobble);
        const py = Math.floor(y + dy * i - dx * wobble);
        
        if (px >= 0 && px < ctx.width && py >= 0 && py < ctx.height) {
          const fade = 1 - (i / len);
          const brightness = fade * fade;
          const idx = (py * ctx.width + px) * 4;
          
          out.data[idx] = Math.min(255, Math.floor(out.data[idx] * (1 - brightness * 0.8) + r * brightness * 0.8));
          out.data[idx + 1] = Math.min(255, Math.floor(out.data[idx + 1] * (1 - brightness * 0.8) + g * brightness * 0.8));
          out.data[idx + 2] = Math.min(255, Math.floor(out.data[idx + 2] * (1 - brightness * 0.8) + b * brightness * 0.8));
        }
      }
    }
  }
  
  return out;
}

function fnDoubleQuote(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const bands = Math.max(2, n);
  const bandHeight = ctx.height / bands;
  
  for (let y = 0; y < ctx.height; y++) {
    const bandIdx = Math.floor(y / bandHeight);
    const isOdd = bandIdx % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (isOdd) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnHash(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const gridSize = Math.max(2, n + 2);
  
  const getCellBounds = (gx: number, gy: number): [number, number, number, number] => {
    const x0 = Math.floor(gx * ctx.width / gridSize);
    const x1 = Math.floor((gx + 1) * ctx.width / gridSize);
    const y0 = Math.floor(gy * ctx.height / gridSize);
    const y1 = Math.floor((gy + 1) * ctx.height / gridSize);
    return [x0, y0, x1, y1];
  };
  
  const cells: { gx: number; gy: number; hue: number }[] = [];
  
  for (let gy = 0; gy < gridSize; gy++) {
    for (let gx = 0; gx < gridSize; gx++) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      const [x0, y0, x1, y1] = getCellBounds(gx, gy);
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
        }
      }
      
      const avgR = count > 0 ? sumR / count : 0;
      const avgG = count > 0 ? sumG / count : 0;
      const avgB = count > 0 ? sumB / count : 0;
      const [hue] = rgbToHsl(avgR, avgG, avgB);
      
      cells.push({ gx, gy, hue });
    }
  }
  
  const sortedIndices = cells.map((_, i) => i).sort((a, b) => cells[a].hue - cells[b].hue);
  
  for (let i = 0; i < sortedIndices.length; i++) {
    const srcIdx = sortedIndices[i];
    const srcCell = cells[srcIdx];
    const [sx0, sy0, sx1, sy1] = getCellBounds(srcCell.gx, srcCell.gy);
    const srcW = sx1 - sx0;
    const srcH = sy1 - sy0;
    
    const targetGX = i % gridSize;
    const targetGY = Math.floor(i / gridSize);
    const [tx0, ty0, tx1, ty1] = getCellBounds(targetGX, targetGY);
    const targetW = tx1 - tx0;
    const targetH = ty1 - ty0;
    
    for (let ty = ty0; ty < ty1; ty++) {
      for (let tx = tx0; tx < tx1; tx++) {
        const srcX = sx0 + Math.floor((tx - tx0) * srcW / targetW);
        const srcY = sy0 + Math.floor((ty - ty0) * srcH / targetH);
        const [r, g, b] = getPixel(prev, srcX, srcY);
        setPixel(out, tx, ty, r, g, b);
      }
    }
  }
  
  return out;
}

function fnDollar(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const w = ctx.width;
  const h = ctx.height;
  
  const threshold = 12;
  
  const labels = new Int32Array(w * h);
  labels.fill(-1);
  
  const colorDist = (x1: number, y1: number, x2: number, y2: number): number => {
    const [r1, g1, b1] = getPixel(prev, x1, y1);
    const [r2, g2, b2] = getPixel(prev, x2, y2);
    return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
  };
  
  let currentLabel = 0;
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const idx = y * w + x;
      if (labels[idx] !== -1) continue;
      
      const queue: [number, number][] = [[x, y]];
      labels[idx] = currentLabel;
      
      while (queue.length > 0) {
        const [cx, cy] = queue.shift()!;
        
        const neighbors = [
          [cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]
        ];
        
        for (const [nx, ny] of neighbors) {
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
          const nidx = ny * w + nx;
          if (labels[nidx] !== -1) continue;
          
          if (colorDist(cx, cy, nx, ny) < threshold) {
            labels[nidx] = currentLabel;
            queue.push([nx, ny]);
          }
        }
      }
      
      currentLabel++;
    }
  }
  
  const segments = new Map<number, { x: number; y: number; r: number; g: number; b: number; hue: number }[]>();
  
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const label = labels[y * w + x];
      const [r, g, b] = getPixel(prev, x, y);
      const [hue] = rgbToHsl(r, g, b);
      
      if (!segments.has(label)) {
        segments.set(label, []);
      }
      segments.get(label)!.push({ x, y, r, g, b, hue });
    }
  }
  
  for (const [, pixels] of segments) {
    pixels.sort((a, b) => a.hue - b.hue);
    
    const positions = pixels.map(p => ({ x: p.x, y: p.y }));
    positions.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    
    for (let i = 0; i < pixels.length; i++) {
      const color = pixels[i];
      const pos = positions[i];
      setPixel(out, pos.x, pos.y, color.r, color.g, color.b);
    }
  }
  
  return out;
}

function fnPercent(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const horizontal = n % 2 === 0;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = horizontal ? ctx.width - 1 - x : x;
      const srcY = horizontal ? y : ctx.height - 1 - y;
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnAmpersand(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const bayer8x8 = [
    [ 0, 32,  8, 40,  2, 34, 10, 42],
    [48, 16, 56, 24, 50, 18, 58, 26],
    [12, 44,  4, 36, 14, 46,  6, 38],
    [60, 28, 52, 20, 62, 30, 54, 22],
    [ 3, 35, 11, 43,  1, 33,  9, 41],
    [51, 19, 59, 27, 49, 17, 57, 25],
    [15, 47,  7, 39, 13, 45,  5, 37],
    [63, 31, 55, 23, 61, 29, 53, 21]
  ];
  
  const levels = 5;
  const spread = 85;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      const tr = (bayer8x8[(y + 3) % 8][(x + 3) % 8] / 64.0 - 0.5) * spread;
      const tg = (bayer8x8[(y + 7) % 8][(x + 7) % 8] / 64.0 - 0.5) * spread;
      const tb = (bayer8x8[(y + 11) % 8][(x + 11) % 8] / 64.0 - 0.5) * spread;
      
      const quantize = (v: number, threshold: number) => {
        const adjusted = v + threshold;
        const step = 255 / (levels - 1);
        return Math.max(0, Math.min(255, Math.round(adjusted / step) * step));
      };
      
      setPixel(out, x, y, quantize(r, tr), quantize(g, tg), quantize(b, tb));
    }
  }
  
  return out;
}

function fnApostrophe(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const spacing = n + 2;
  
  for (let x = 0; x < ctx.width; x++) {
    if (x % spacing !== 0) continue;
    
    let colLuminance = 0;
    for (let y = 0; y < ctx.height; y++) {
      const [r, g, b] = getPixel(prev, x, y);
      colLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    colLuminance /= ctx.height;
    
    const streakLength = Math.floor((colLuminance / 255) * 100);
    const startY = 0;
    
    for (let y = startY; y < startY + streakLength && y < ctx.height; y++) {
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * 0.5 + 127));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * 0.5 + 127));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * 0.5 + 127));
    }
  }
  
  return out;
}

function fnOpenParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const pinchFactor = 1 + strength * (1 - normDist);
      const sx = cx + dx * pinchFactor;
      const sy = cy + dy * pinchFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const brighten = (1 - normDist) * strength * 30;
      r = Math.min(255, r + brighten);
      g = Math.min(255, g + brighten);
      b = Math.min(255, b + brighten);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnCloseParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const bulgeFactor = 1 - strength * normDist * 0.5;
      const sx = cx + dx * bulgeFactor;
      const sy = cy + dy * bulgeFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const darken = normDist * strength * 50;
      r = Math.max(0, r - darken);
      g = Math.max(0, g - darken);
      b = Math.max(0, b - darken);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnAsterisk(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const occlusionFragShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uLightPos;
    uniform float uLightRadius;
    varying vec2 vUV;
    
    void main() {
      vec3 texColor = texture2D(uTexture, vUV).rgb;
      float brightness = dot(texColor, vec3(0.299, 0.587, 0.114));
      
      // Distance from light center
      vec2 diff = vUV - uLightPos;
      float dist = length(diff);
      
      // Light source glow (bright center)
      float lightGlow = exp(-dist * dist / (uLightRadius * uLightRadius * 2.0));
      
      // Threshold bright areas as potential light sources
      float threshold = step(0.5, brightness);
      
      // Combine: light center + bright pixels from image
      vec3 lightColor = vec3(1.0, 0.95, 0.8);
      vec3 result = lightGlow * lightColor + threshold * texColor * 0.8;
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const godrayFragShader = `
    precision highp float;
    uniform sampler2D uOcclusionTexture;
    uniform sampler2D uSceneTexture;
    uniform vec2 uLightPos;
    uniform float uExposure;
    uniform float uDecay;
    uniform float uDensity;
    uniform float uWeight;
    varying vec2 vUV;
    
    #define NUM_SAMPLES 80
    
    void main() {
      vec2 texCoord = vUV;
      vec2 deltaTexCoord = (texCoord - uLightPos);
      deltaTexCoord *= 1.0 / float(NUM_SAMPLES) * uDensity;
      
      float illuminationDecay = 1.0;
      vec3 godrayColor = vec3(0.0);
      
      vec2 sampleCoord = texCoord;
      
      for (int i = 0; i < NUM_SAMPLES; i++) {
        sampleCoord -= deltaTexCoord;
        vec3 sampleColor = texture2D(uOcclusionTexture, sampleCoord).rgb;
        sampleColor *= illuminationDecay * uWeight;
        godrayColor += sampleColor;
        illuminationDecay *= uDecay;
      }
      
      godrayColor *= uExposure;
      
      // Get original scene
      vec3 sceneColor = texture2D(uSceneTexture, vUV).rgb;
      
      // Blend godrays additively with scene
      vec3 finalColor = sceneColor + godrayColor;
      
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `;
  
  const occlusionProgram = createShaderProgram(gl, vertexShader, occlusionFragShader);
  const godrayProgram = createShaderProgram(gl, vertexShader, godrayFragShader);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const sceneTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const occlusionTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const framebuffer = gl.createFramebuffer();
  
  const lightX = 0.5;
  const lightY = 0.5;
  const lightRadius = 0.08;
  
  // Pass 1: Render occlusion texture (light sources)
  gl.useProgram(occlusionProgram);
  
  const occPosLoc = gl.getAttribLocation(occlusionProgram, 'position');
  gl.enableVertexAttribArray(occPosLoc);
  gl.vertexAttribPointer(occPosLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, occlusionTexture, 0);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
  gl.uniform1i(gl.getUniformLocation(occlusionProgram, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(occlusionProgram, 'uLightPos'), lightX, lightY);
  gl.uniform1f(gl.getUniformLocation(occlusionProgram, 'uLightRadius'), lightRadius);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  // Pass 2: Apply god rays and combine with scene
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.useProgram(godrayProgram);
  
  const grPosLoc = gl.getAttribLocation(godrayProgram, 'position');
  gl.enableVertexAttribArray(grPosLoc);
  gl.vertexAttribPointer(grPosLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
  gl.uniform1i(gl.getUniformLocation(godrayProgram, 'uOcclusionTexture'), 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
  gl.uniform1i(gl.getUniformLocation(godrayProgram, 'uSceneTexture'), 1);
  
  gl.uniform2f(gl.getUniformLocation(godrayProgram, 'uLightPos'), lightX, lightY);
  gl.uniform1f(gl.getUniformLocation(godrayProgram, 'uExposure'), 0.15);
  gl.uniform1f(gl.getUniformLocation(godrayProgram, 'uDecay'), 0.96);
  gl.uniform1f(gl.getUniformLocation(godrayProgram, 'uDensity'), 0.85);
  gl.uniform1f(gl.getUniformLocation(godrayProgram, 'uWeight'), 0.4);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(sceneTexture);
  gl.deleteTexture(occlusionTexture);
  gl.deleteFramebuffer(framebuffer);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(occlusionProgram);
  gl.deleteProgram(godrayProgram);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnPlus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const zoom = 1.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const sx = cx + (x - cx) / zoom;
      const sy = cy + (y - cy) / zoom;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnComma(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = Math.floor(r * 0.299 + g * 0.587 + b * 0.114);
      const divisor = 1 + Math.floor(luminance / 32);
      
      if ((x * 13 + y * 7) % divisor === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnMinus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const spacing = 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let [r, g, b] = getPixel(prev, x, y);
      
      if (y % spacing === 0) {
        r = Math.floor(r * 0.5);
        g = Math.floor(g * 0.5);
        b = Math.floor(b * 0.5);
      }
      
      if (y % (spacing * 2) === 0) {
        const srcY = Math.max(0, y - spacing);
        [r, g, b] = getPixel(prev, x, srcY);
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnDot(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const radius = (n % 8) + 2;
  const diameter = radius * 2;
  
  for (let cy = radius; cy < ctx.height; cy += diameter) {
    for (let cx = radius; cx < ctx.width; cx += diameter) {
      const [r, g, b] = getPixel(prev, cx, cy);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb(h, Math.min(1, s + 0.1), l);
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx * dx + dy * dy <= radius * radius) {
            setPixel(out, cx + dx, cy + dy, nr, ng, nb);
          }
        }
      }
    }
  }
  
  return out;
}

function fnSlash(ctx: FnContext, old: Image, offX: number, offY: number, size: number, blend: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const norm = (n: number) => Math.max(0, Math.min(1, (n - 1) / 67));
  
  // Source: full circle from center of old image
  const srcCenterX = old.width / 2;
  const srcCenterY = old.height / 2;
  const srcRadius = Math.min(old.width, old.height) / 2;
  
  // Destination position and size
  const dstX = norm(offX) * ctx.width;
  const dstY = norm(offY) * ctx.height;
  const dstRadius = Math.max(1, norm(size) * Math.min(ctx.width, ctx.height));
  
  // Blend mode (0-15)
  const NUM_BLEND_MODES = 16;
  const blendMode = (blend - 1) % NUM_BLEND_MODES;
  
  const blendFuncs: ((b: number, t: number) => number)[] = [
    (b, t) => t,
    (b, t) => b ^ t,
    (b, t) => 255 - (b & t),
    (b, t) => b & t,
    (b, t) => b | t,
    (b, t) => (b * t) / 255,
    (b, t) => 255 - ((255 - b) * (255 - t)) / 255,
    (b, t) => b < 128 ? (2 * b * t) / 255 : 255 - (2 * (255 - b) * (255 - t)) / 255,
    (b, t) => Math.min(b, t),
    (b, t) => Math.max(b, t),
    (b, t) => Math.abs(b - t),
    (b, t) => b + t - (2 * b * t) / 255,
    (b, t) => Math.min(255, b + t),
    (b, t) => Math.max(0, b - t),
    (b, t) => t < 128 ? (2 * b * t) / 255 : 255 - (2 * (255 - b) * (255 - t)) / 255,
    (b, t) => {
      const tb = t / 255, bb = b / 255;
      return Math.round((tb < 0.5 ? bb - (1 - 2 * tb) * bb * (1 - bb) : bb + (2 * tb - 1) * (bb < 0.25 ? ((16 * bb - 12) * bb + 4) * bb : Math.sqrt(bb) - bb)) * 255);
    },
  ];
  
  const blendFunc = blendFuncs[blendMode];
  
  // Scale factor from destination to source
  const scale = srcRadius / dstRadius;
  
  // Iterate over bounding box of destination circle
  const startX = Math.max(0, Math.floor(dstX - dstRadius));
  const endX = Math.min(ctx.width, Math.ceil(dstX + dstRadius));
  const startY = Math.max(0, Math.floor(dstY - dstRadius));
  const endY = Math.min(ctx.height, Math.ceil(dstY + dstRadius));
  
  for (let py = startY; py < endY; py++) {
    for (let px = startX; px < endX; px++) {
      const dx = px - dstX;
      const dy = py - dstY;
      const distSq = dx * dx + dy * dy;
      
      if (distSq > dstRadius * dstRadius) continue;
      
      // Map to source coordinates
      const srcPxF = srcCenterX + dx * scale;
      const srcPyF = srcCenterY + dy * scale;
      
      // Bilinear interpolation
      const x0 = Math.floor(srcPxF);
      const y0 = Math.floor(srcPyF);
      const x1 = Math.min(old.width - 1, x0 + 1);
      const y1 = Math.min(old.height - 1, y0 + 1);
      const fx = srcPxF - x0;
      const fy = srcPyF - y0;
      
      const [r00, g00, b00] = getPixel(old, x0, y0);
      const [r10, g10, b10] = getPixel(old, x1, y0);
      const [r01, g01, b01] = getPixel(old, x0, y1);
      const [r11, g11, b11] = getPixel(old, x1, y1);
      
      const srcR = Math.round(r00 * (1 - fx) * (1 - fy) + r10 * fx * (1 - fy) + r01 * (1 - fx) * fy + r11 * fx * fy);
      const srcG = Math.round(g00 * (1 - fx) * (1 - fy) + g10 * fx * (1 - fy) + g01 * (1 - fx) * fy + g11 * fx * fy);
      const srcB = Math.round(b00 * (1 - fx) * (1 - fy) + b10 * fx * (1 - fy) + b01 * (1 - fx) * fy + b11 * fx * fy);
      
      const [baseR, baseG, baseB] = getPixel(prev, px, py);
      
      const r = Math.round(blendFunc(baseR, srcR));
      const g = Math.round(blendFunc(baseG, srcG));
      const b = Math.round(blendFunc(baseB, srcB));
      
      setPixel(out, px, py, r, g, b);
    }
  }
  
  return out;
}

function fnColon(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const radius = Math.min(cx, cy) * 0.9;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < radius) {
        const [r, g, b] = getPixel(old, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnSemicolon(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const radius = Math.min(cx, cy) * 0.9;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (y < cy && dist < radius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else if (y >= cy) {
        const mirrorY = 2 * cy - y;
        const mirrorDx = x - cx;
        const mirrorDy = mirrorY - cy;
        const mirrorDist = Math.sqrt(mirrorDx * mirrorDx + mirrorDy * mirrorDy);
        
        if (mirrorDist < radius) {
          const wave = Math.sin(x * 0.1) * 10;
          const srcY = Math.floor(mirrorY + wave);
          const [r, g, b] = getPixel(prev, x, Math.max(0, Math.min(ctx.height - 1, srcY)));
          setPixel(out, x, y, r, g, b);
        }
      }
    }
  }
  
  return out;
}

function fnEquals(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripeHeight = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const stripeIdx = Math.floor(y / stripeHeight);
    const isOdd = stripeIdx % 2 === 1;
    const shift = isOdd ? stripeIdx * 5 : 0;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = ((x + shift) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnQuestion(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  
  let sum = 0;
  for (const [r, g, b] of corners) {
    sum += r + g + b;
  }
  const effect = sum % 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (effect === 0) {
        const sr = r < 128 ? r : 255 - r;
        const sg = g < 128 ? g : 255 - g;
        const sb = b < 128 ? b : 255 - b;
        setPixel(out, x, y, sr * 2, sg * 2, sb * 2);
      } else if (effect === 1) {
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const weight = (kx === 0 && ky === 0) ? 8 : -1;
            gx += gray * weight;
          }
        }
        const embossVal = Math.max(0, Math.min(255, 128 + gx / 4));
        setPixel(out, x, y, embossVal, embossVal, embossVal);
      } else if (effect === 2) {
        const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
        const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
            const kidx = (ky + 1) * 3 + (kx + 1);
            gx += gray * sobelX[kidx];
            gy += gray * sobelY[kidx];
          }
        }
        const mag = Math.min(255, Math.sqrt(gx * gx + gy * gy));
        setPixel(out, x, y, mag, mag, mag);
      } else {
        const levels = 4;
        const pr = Math.floor(r / 256 * levels) * (255 / (levels - 1));
        const pg = Math.floor(g / 256 * levels) * (255 / (levels - 1));
        const pb = Math.floor(b / 256 * levels) * (255 / (levels - 1));
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

function fnOpenBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const angle = -20 * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const srcX = cx + dx * cos - dy * sin;
      const srcY = cy + dx * sin + dy * cos;
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnBackslash(
  ctx: FnContext,
  old: Image,
  srcX: number,
  srcY: number,
  srcW: number,
  srcH: number,
  dstX: number,
  dstY: number,
  dstW: number,
  dstH: number,
  rot: number,
  blend: number
): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  // Map integer values (1-68) to normalized 0-1 range
  const norm = (n: number) => Math.max(0, Math.min(1, (n - 1) / 67));
  
  // Source crop region in old image
  // X and Y use full range, W and H use remaining space after offset
  const sourceCropX = Math.floor(norm(srcX) * old.width);
  const sourceCropY = Math.floor(norm(srcY) * old.height);
  const sourceCropW = Math.max(1, Math.round(norm(srcW) * (old.width - sourceCropX)));
  const sourceCropH = Math.max(1, Math.round(norm(srcH) * (old.height - sourceCropY)));
  
  // Destination region in output image
  // X and Y use full range, W and H use remaining space after offset
  const destX = Math.floor(norm(dstX) * ctx.width);
  const destY = Math.floor(norm(dstY) * ctx.height);
  const destW = Math.max(1, Math.round(norm(dstW) * (ctx.width - destX)));
  const destH = Math.max(1, Math.round(norm(dstH) * (ctx.height - destY)));
  
  // Rotation angle (0-360 degrees)
  const rotation = norm(rot) * 2 * Math.PI;
  
  // Blend mode (0-15)
  const NUM_BLEND_MODES = 16;
  const blendMode = (blend - 1) % NUM_BLEND_MODES;
  
  // Blend mode functions: (base, top) => result (all values 0-255)
  const blendFuncs: ((b: number, t: number) => number)[] = [
    // 0: Normal - replace
    (b, t) => t,
    // 1: XOR
    (b, t) => b ^ t,
    // 2: NAND
    (b, t) => 255 - (b & t),
    // 3: AND
    (b, t) => b & t,
    // 4: OR
    (b, t) => b | t,
    // 5: Multiply
    (b, t) => (b * t) / 255,
    // 6: Screen
    (b, t) => 255 - ((255 - b) * (255 - t)) / 255,
    // 7: Overlay
    (b, t) => b < 128 ? (2 * b * t) / 255 : 255 - (2 * (255 - b) * (255 - t)) / 255,
    // 8: Darken
    (b, t) => Math.min(b, t),
    // 9: Lighten
    (b, t) => Math.max(b, t),
    // 10: Difference
    (b, t) => Math.abs(b - t),
    // 11: Exclusion
    (b, t) => b + t - (2 * b * t) / 255,
    // 12: Add (clamped)
    (b, t) => Math.min(255, b + t),
    // 13: Subtract (clamped)
    (b, t) => Math.max(0, b - t),
    // 14: Hard Light
    (b, t) => t < 128 ? (2 * b * t) / 255 : 255 - (2 * (255 - b) * (255 - t)) / 255,
    // 15: Soft Light
    (b, t) => {
      const tb = t / 255, bb = b / 255;
      return Math.round((tb < 0.5 ? bb - (1 - 2 * tb) * bb * (1 - bb) : bb + (2 * tb - 1) * (bb < 0.25 ? ((16 * bb - 12) * bb + 4) * bb : Math.sqrt(bb) - bb)) * 255);
    },
  ];
  
  const blendFunc = blendFuncs[blendMode];
  
  const destCenterX = destX + destW / 2;
  const destCenterY = destY + destH / 2;
  const cosR = Math.cos(-rotation);
  const sinR = Math.sin(-rotation);
  
  // Calculate bounding box of rotated rectangle
  const halfW = destW / 2;
  const halfH = destH / 2;
  const corners = [
    [-halfW, -halfH],
    [halfW, -halfH],
    [halfW, halfH],
    [-halfW, halfH]
  ];
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const [cx, cy] of corners) {
    const rx = cx * Math.cos(rotation) - cy * Math.sin(rotation) + destCenterX;
    const ry = cx * Math.sin(rotation) + cy * Math.cos(rotation) + destCenterY;
    minX = Math.min(minX, rx);
    maxX = Math.max(maxX, rx);
    minY = Math.min(minY, ry);
    maxY = Math.max(maxY, ry);
  }
  
  const startX = Math.max(0, Math.floor(minX));
  const endX = Math.min(ctx.width, Math.ceil(maxX));
  const startY = Math.max(0, Math.floor(minY));
  const endY = Math.min(ctx.height, Math.ceil(maxY));
  
  for (let py = startY; py < endY; py++) {
    for (let px = startX; px < endX; px++) {
      // Inverse rotation to find source coordinates
      const relX = px - destCenterX;
      const relY = py - destCenterY;
      const rotX = relX * cosR - relY * sinR;
      const rotY = relX * sinR + relY * cosR;
      
      // Map to normalized coordinates in destination rect
      const normX = (rotX + halfW) / destW;
      const normY = (rotY + halfH) / destH;
      
      // Check if within the destination rectangle (0-1 range)
      if (normX < 0 || normX >= 1 || normY < 0 || normY >= 1) continue;
      
      // Map to source coordinates with bilinear sampling
      const srcPxF = sourceCropX + normX * sourceCropW;
      const srcPyF = sourceCropY + normY * sourceCropH;
      
      const x0 = Math.floor(srcPxF);
      const y0 = Math.floor(srcPyF);
      const x1 = Math.min(old.width - 1, x0 + 1);
      const y1 = Math.min(old.height - 1, y0 + 1);
      const fx = srcPxF - x0;
      const fy = srcPyF - y0;
      
      const [r00, g00, b00] = getPixel(old, x0, y0);
      const [r10, g10, b10] = getPixel(old, x1, y0);
      const [r01, g01, b01] = getPixel(old, x0, y1);
      const [r11, g11, b11] = getPixel(old, x1, y1);
      
      // Bilinear interpolation for source pixel
      const srcR = Math.round(r00 * (1 - fx) * (1 - fy) + r10 * fx * (1 - fy) + r01 * (1 - fx) * fy + r11 * fx * fy);
      const srcG = Math.round(g00 * (1 - fx) * (1 - fy) + g10 * fx * (1 - fy) + g01 * (1 - fx) * fy + g11 * fx * fy);
      const srcB = Math.round(b00 * (1 - fx) * (1 - fy) + b10 * fx * (1 - fy) + b01 * (1 - fx) * fy + b11 * fx * fy);
      
      // Get base pixel from prev
      const [baseR, baseG, baseB] = getPixel(prev, px, py);
      
      // Apply blend mode
      const r = Math.round(blendFunc(baseR, srcR));
      const g = Math.round(blendFunc(baseG, srcG));
      const b = Math.round(blendFunc(baseB, srcB));
      
      setPixel(out, px, py, r, g, b);
    }
  }
  
  return out;
}

function fnCloseBracket(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const offset = Math.floor(ctx.height * 0.2);
  const midX = Math.floor(ctx.width / 2);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (x < midX) {
        const srcY = (y + offset) % ctx.height;
        const [r, g, b] = getPixel(prev, x, srcY);
        setPixel(out, x, y, r, g, b);
      } else {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      }
    }
  }
  
  return out;
}

function fnUnderscore(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const blurShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDirection;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    void main() {
      vec2 texelSize = 1.0 / uResolution;
      vec3 result = vec3(0.0);
      
      float weights[5];
      weights[0] = 0.227027;
      weights[1] = 0.1945946;
      weights[2] = 0.1216216;
      weights[3] = 0.054054;
      weights[4] = 0.016216;
      
      result += texture2D(uTexture, vUV).rgb * weights[0];
      for (int i = 1; i < 5; i++) {
        vec2 offset = uDirection * texelSize * float(i) * 5.0;
        result += texture2D(uTexture, vUV + offset).rgb * weights[i];
        result += texture2D(uTexture, vUV - offset).rgb * weights[i];
      }
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const luminosityShader = `
    precision highp float;
    uniform sampler2D uPrev;
    uniform sampler2D uBlurred;
    varying vec2 vUV;
    
    void main() {
      vec2 flippedUV = vec2(vUV.x, 1.0 - vUV.y);
      vec3 prevColor = texture2D(uPrev, flippedUV).rgb;
      vec3 blurColor = texture2D(uBlurred, vUV).rgb;
      
      float prevLum = dot(prevColor, vec3(0.299, 0.587, 0.114));
      float blurLum = dot(blurColor, vec3(0.299, 0.587, 0.114));
      
      float scale = blurLum > 0.001 ? prevLum / blurLum : 1.0;
      vec3 result = clamp(blurColor * scale, 0.0, 1.0);
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const blurProgram = createShaderProgram(gl, vertexShader, blurShader);
  const luminosityProgram = createShaderProgram(gl, vertexShader, luminosityShader);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const tempTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const blurredTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const framebuffer = gl.createFramebuffer();
  
  gl.useProgram(blurProgram);
  const blurPosLoc = gl.getAttribLocation(blurProgram, 'position');
  gl.enableVertexAttribArray(blurPosLoc);
  gl.vertexAttribPointer(blurPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uResolution'), ctx.width, ctx.height);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.uniform1i(gl.getUniformLocation(blurProgram, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 1.0, 0.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, blurredTexture, 0);
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 0.0, 1.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.useProgram(luminosityProgram);
  const lumPosLoc = gl.getAttribLocation(luminosityProgram, 'position');
  gl.enableVertexAttribArray(lumPosLoc);
  gl.vertexAttribPointer(lumPosLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uPrev'), 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uBlurred'), 1);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(oldTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(tempTexture);
  gl.deleteTexture(blurredTexture);
  gl.deleteFramebuffer(framebuffer);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(blurProgram);
  gl.deleteProgram(luminosityProgram);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const { width, height } = ctx;
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  const gradX = new Float32Array(width * height);
  const gradY = new Float32Array(width * height);
  const gradMag = new Float32Array(width * height);
  
  let maxMag = 1;
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const [r, g, b] = getPixel(prev, x + kx, y + ky);
          const gray = r * 0.299 + g * 0.587 + b * 0.114;
          const kidx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kidx];
          gy += gray * sobelY[kidx];
        }
      }
      
      const idx = y * width + x;
      gradX[idx] = gx;
      gradY[idx] = gy;
      const mag = Math.sqrt(gx * gx + gy * gy);
      gradMag[idx] = mag;
      if (mag > maxMag) maxMag = mag;
    }
  }
  
  const iterations = Math.max(5, Math.min(n * 2 + 8, 30));
  const baseStrength = 4.0 + n * 1.5;
  const threshold = 8;
  
  let current = cloneImage(prev);
  
  for (let iter = 0; iter < iterations; iter++) {
    const next = createSolidImage(width, height, '#000000');
    const iterDecay = 1 - (iter / iterations) * 0.35;
    const iterStrength = baseStrength * iterDecay;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        const mag = gradMag[idx];
        
        if (mag < threshold) {
          const [r, g, b] = getPixel(current, x, y);
          setPixel(next, x, y, r, g, b);
          continue;
        }
        
        const normMag = mag / maxMag;
        const scale = normMag * iterStrength;
        const dx = (gradX[idx] / mag) * scale;
        const dy = (gradY[idx] / mag) * scale;
        
        const srcX = x - dx;
        const srcY = y - dy;
        
        const [r1, g1, b1] = getPixel(current, Math.floor(srcX), Math.floor(srcY));
        const [r2, g2, b2] = getPixel(current, x, y);
        
        const blend = Math.min(0.95, normMag * 0.6 + 0.35);
        setPixel(next, x, y,
          Math.round(r1 * blend + r2 * (1 - blend)),
          Math.round(g1 * blend + g2 * (1 - blend)),
          Math.round(b1 * blend + b2 * (1 - blend))
        );
      }
    }
    
    current = next;
  }
  
  return current;
}

function fnOpenBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x < 0.5) {
        float localX = uv.x * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnPipe(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const midX = Math.floor(ctx.width / 2);
  const blendWidth = Math.floor(ctx.width * 0.1);
  
  for (let y = 0; y < ctx.height; y++) {
    const waveOffset = Math.sin(y * 0.05) * 15;
    const effectiveMidX = midX + waveOffset;
    
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      if (x < effectiveMidX - blendWidth) {
        setPixel(out, x, y, pr, pg, pb);
      } else if (x > effectiveMidX + blendWidth) {
        setPixel(out, x, y, or, og, ob);
      } else {
        const t = (x - (effectiveMidX - blendWidth)) / (blendWidth * 2);
        
        const screenR = 255 - ((255 - pr) * (255 - or)) / 255;
        const screenG = 255 - ((255 - pg) * (255 - og)) / 255;
        const screenB = 255 - ((255 - pb) * (255 - ob)) / 255;
        
        const diffR = Math.abs(pr - or);
        const diffG = Math.abs(pg - og);
        const diffB = Math.abs(pb - ob);
        
        const xorR = pr ^ or;
        const xorG = pg ^ og;
        const xorB = pb ^ ob;
        
        const band = Math.floor(y / 20) % 3;
        
        let r: number, g: number, b: number;
        
        if (band === 0) {
          if (t < 0.5) {
            const localT = t * 2;
            r = pr * (1 - localT) + screenR * localT;
            g = pg * (1 - localT) + screenG * localT;
            b = pb * (1 - localT) + screenB * localT;
          } else {
            const localT = (t - 0.5) * 2;
            r = screenR * (1 - localT) + or * localT;
            g = screenG * (1 - localT) + og * localT;
            b = screenB * (1 - localT) + ob * localT;
          }
        } else if (band === 1) {
          const centerDist = Math.abs(t - 0.5) * 2;
          const diffWeight = 1 - centerDist;
          r = (pr * (1 - t) + or * t) * (1 - diffWeight) + diffR * diffWeight;
          g = (pg * (1 - t) + og * t) * (1 - diffWeight) + diffG * diffWeight;
          b = (pb * (1 - t) + ob * t) * (1 - diffWeight) + diffB * diffWeight;
        } else {
          const xorWeight = Math.sin(t * Math.PI) * 0.7;
          const baseR = pr * (1 - t) + or * t;
          const baseG = pg * (1 - t) + og * t;
          const baseB = pb * (1 - t) + ob * t;
          r = baseR * (1 - xorWeight) + xorR * xorWeight;
          g = baseG * (1 - xorWeight) + xorG * xorWeight;
          b = baseB * (1 - xorWeight) + xorB * xorWeight;
        }
        
        setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
      }
    }
  }
  
  return out;
}

function fnCloseBrace(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      
      if (uv.x > 0.5) {
        float localX = (uv.x - 0.5) * 2.0;
        float angle = (localX - 0.5) * 3.14159 * 0.4;
        float z = cos(angle);
        float newX = 0.5 + sin(angle) * 0.4;
        
        float shade = 0.6 + 0.4 * z;
        vec2 sampleUV = vec2(0.5 + newX * 0.5, uv.y);
        vec3 color = texture2D(texture, sampleUV).rgb * shade;
        gl_FragColor = vec4(color, 1.0);
      } else {
        vec3 color = texture2D(texture, uv).rgb;
        gl_FragColor = vec4(color, 1.0);
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnOilSlick(ctx: FnContext, warpN: number, iridN: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const seed = ctx.images.length * 137.5 + warpN * 17.3 + iridN * 7.1;
  const depth = 1 + Math.floor(iridN / 4);
  const warpStrength = 0.05 + warpN * 0.025;
  const patternScale = 1.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uSeed;
    uniform int uDepth;
    uniform float uWarpStrength;
    uniform float uPatternScale;
    varying vec2 vUV;
    
    // Hash function for deterministic noise
    float hash(vec2 p, float seed) {
      return fract(sin(dot(p + seed * 0.1, vec2(127.1, 311.7))) * 43758.5453);
    }
    
    // Smooth noise
    float noise(vec2 p, float seed) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);
      
      float a = hash(i, seed);
      float b = hash(i + vec2(1.0, 0.0), seed);
      float c = hash(i + vec2(0.0, 1.0), seed);
      float d = hash(i + vec2(1.0, 1.0), seed);
      
      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }
    
    // FBM for organic patterns
    float fbm(vec2 p, float seed) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;
      for (int i = 0; i < 4; i++) {
        value += amplitude * noise(p * frequency, seed + float(i) * 100.0);
        amplitude *= 0.5;
        frequency *= 2.0;
      }
      return value;
    }
    
    // Domain warping effect - creates swirling patterns
    vec2 warpEffect(vec2 p, float i, float seed) {
      float angle = fbm(p * 0.8 + seed * 0.01, seed) * 6.28;
      float magnitude = fbm(p * 0.5 + seed * 0.02 + 50.0, seed + 100.0);
      return vec2(cos(angle), sin(angle)) * magnitude / (i * 0.3 + 1.0);
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Noise coordinates with offset to avoid symmetry
      vec2 noiseCoord = uv * 4.0 + vec2(uSeed * 0.1 + 5.7, uSeed * 0.07 + 3.2);
      noiseCoord.x *= aspect;
      
      // Calculate warp displacement from noise
      vec2 warp = vec2(0.0);
      for (int i = 1; i < 20; i++) {
        if (i >= uDepth) break;
        float fi = float(i);
        warp += warpEffect(noiseCoord + warp, fi, uSeed) * uWarpStrength;
      }
      
      // Apply warp as UV offset
      vec2 warpedUV = uv + warp * 0.15;
      warpedUV = clamp(warpedUV, 0.0, 1.0);
      
      // Sample texture at warped position
      vec3 texColor = texture2D(uTexture, warpedUV).rgb;
      
      // Oil slick lighting overlay based on noise
      float h = fbm(noiseCoord + warp, uSeed);
      float hx = fbm(noiseCoord + warp + vec2(0.05, 0.0), uSeed);
      float hy = fbm(noiseCoord + warp + vec2(0.0, 0.05), uSeed);
      
      // Fake normal from height field
      vec3 normal = normalize(vec3((h - hx) * 8.0, (h - hy) * 8.0, 1.0));
      
      // Light from top-left
      vec3 lightDir = normalize(vec3(0.5, 0.6, 1.0));
      float diffuse = max(dot(normal, lightDir), 0.0);
      
      // Specular highlight
      vec3 viewDir = vec3(0.0, 0.0, 1.0);
      vec3 reflectDir = reflect(-lightDir, normal);
      float spec = pow(max(dot(viewDir, reflectDir), 0.0), 24.0);
      
      // Lighting adjustment
      float lighting = 0.85 + diffuse * 0.2;
      float highlight = spec * 0.25;
      
      vec3 color = texColor * lighting + vec3(highlight);
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  gl.uniform1i(gl.getUniformLocation(program, 'uDepth'), depth);
  gl.uniform1f(gl.getUniformLocation(program, 'uWarpStrength'), warpStrength);
  gl.uniform1f(gl.getUniformLocation(program, 'uPatternScale'), patternScale);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnTilde(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const waveN = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    const amplitude = Math.sin(y * 0.05) * waveN * 8;
    
    for (let x = 0; x < ctx.width; x++) {
      const srcX = Math.floor(((x + amplitude) % ctx.width + ctx.width) % ctx.width);
      
      const srcXR = Math.floor(((x + amplitude + waveN) % ctx.width + ctx.width) % ctx.width);
      const srcXB = Math.floor(((x + amplitude - waveN) % ctx.width + ctx.width) % ctx.width);
      
      const [rr] = getPixel(prev, srcXR, y);
      const [, gg] = getPixel(prev, srcX, y);
      const [, , bb] = getPixel(prev, srcXB, y);
      
      setPixel(out, x, y, rr, gg, bb);
    }
  }
  
  return out;
}

function fnHoles(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(pr, pg, pb);
      
      const midSat = s >= 0.35 && s <= 0.65;
      const midVal = l >= 0.35 && l <= 0.65;
      
      if (midSat || midVal) {
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y, or, og, ob);
      } else {
        setPixel(out, x, y, pr, pg, pb);
      }
    }
  }
  
  return out;
}

function wrapText(text: string, maxWidth: number): string[] {
  const lines: string[] = [];
  const paragraphs = text.split('\n');
  
  for (const para of paragraphs) {
    if (para.length === 0) {
      lines.push('');
      continue;
    }
    
    const words = para.split(' ');
    let currentLine = '';
    
    for (const word of words) {
      if (currentLine.length === 0) {
        currentLine = word;
      } else if (currentLine.length + 1 + word.length <= maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.length > 0) {
      lines.push(currentLine);
    }
  }
  
  return lines;
}

function generateIntroPage(charsPerLine: number): string[] {
  const introText = `QQQLANG: A syntax-free programming language for image synthesis

In QQQLANG, any string of visible uppercase ascii characters is a valid program.

Each character has three properties:
* An integer ('A'=1, 'B'=2, [...], '}'=67, '~'=68)
* A color
* A function

Functions can take zero or more arguments. If a function takes arguments, the characters that follow are interpreted as arguments. Otherwise characters are interpreted as functions. The exception is the first character of the program string which sets an initial solid color.

For example, the program 'ABCD' has the following interpretation:

* 'A' sets the intial color to #78A10F
* 'B' is the 'border' function that creates a circular gradient around the edges. It takes one argument, the border color.
* 'C' becomes the argument to 'B', the color of 'C' is #FF6B35
* 'D' is the 'drip' function, which creates a water drop effect. It takes no arguments.

If the program string ends before the last function has had arguments defined, it will use its own number and color as default arguments. For example, the programs 'AL', 'ALL', and 'ALLL' are equivalent.

The question mark character '?' is also a function that displays help text. '?1' and '??' show the first page of help, and '?A', '?B', etc. show subsequent pages of help text.`;

  return wrapText(introText, charsPerLine);
}

function generateCharacterRefLines(char: string, def: CharDef, charsPerLine: number): string[] {
  const lines: string[] = [];
  
  const argsStr = def.arity > 0 ? ` [${def.argTypes.join(', ')}]` : '';
  const header = `${char} (${def.number}) ${def.color} - ${def.functionName}${argsStr}`;
  lines.push(header);
  
  const docLines = wrapText('  ' + def.documentation, charsPerLine);
  lines.push(...docLines);
  
  return lines;
}

function getPageChar(pageNum: number): string {
  if (pageNum <= 0) return '?';
  if (pageNum === 1) return '?';
  if (pageNum <= 26) return String.fromCharCode('A'.charCodeAt(0) + pageNum - 1);
  return '?';
}

function generateAllHelpPages(charsPerLine: number, linesPerPage: number, defs: Record<string, CharDef>): string[][] {
  const pages: string[][] = [];
  
  const introLines = generateIntroPage(charsPerLine);
  
  let introPage: string[] = [];
  for (let i = 0; i < introLines.length; i++) {
    if (introPage.length >= linesPerPage - 2) {
      pages.push(introPage);
      introPage = [];
    }
    introPage.push(introLines[i]);
  }
  if (introPage.length > 0) {
    pages.push(introPage);
  }
  
  const chars = Object.keys(defs).sort((a, b) => defs[a].number - defs[b].number);
  
  let currentPage: string[] = [];
  currentPage.push('=== CHARACTER REFERENCE ===');
  currentPage.push('');
  let linesUsed = 2;
  
  for (const char of chars) {
    const def = defs[char];
    const charLines = generateCharacterRefLines(char, def, charsPerLine);
    
    if (linesUsed + charLines.length + 1 > linesPerPage - 2) {
      pages.push(currentPage);
      currentPage = [];
      currentPage.push('=== CHARACTER REFERENCE (continued) ===');
      currentPage.push('');
      linesUsed = 2;
    }
    
    currentPage.push(...charLines);
    currentPage.push('');
    linesUsed += charLines.length + 1;
  }
  
  if (currentPage.length > 2) {
    pages.push(currentPage);
  }
  
  const totalPages = pages.length;
  for (let i = 0; i < pages.length; i++) {
    const pageNum = i + 1;
    const nextPageChar = getPageChar(pageNum + 1);
    pages[i].push('');
    if (pageNum < totalPages) {
      pages[i].push(`[Page ${pageNum}/${totalPages}, type '?${nextPageChar}' for next page]`);
    } else {
      pages[i].push(`[Page ${pageNum}/${totalPages}]`);
    }
  }
  
  return pages;
}

function generateIndexPage(numPages: number): string[] {
  const lines: string[] = [];
  lines.push('=== QQQLANG HELP INDEX ===');
  lines.push('');
  lines.push('Available pages:');
  lines.push('');
  lines.push('?? or ?A - Introduction to QQQLANG');
  
  for (let i = 2; i <= Math.min(numPages, 26); i++) {
    const char = String.fromCharCode('A'.charCodeAt(0) + i - 1);
    if (i === 2) {
      lines.push(`?${char} - Character reference`);
    } else {
      lines.push(`?${char} - Character reference (continued)`);
    }
  }
  
  lines.push('');
  lines.push('Enter a valid page code to view help.');
  lines.push('Invalid page codes show this index.');
  
  return lines;
}

function fnHelp(ctx: FnContext, pageArg: number): Image {
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = '#000000';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  const marginFraction = 0.03;
  const margin = Math.max(10, Math.floor(Math.min(ctx.width, ctx.height) * marginFraction));
  
  const baseFontSize = Math.min(ctx.width, ctx.height) * 0.025;
  const fontSize = Math.max(8, Math.min(16, baseFontSize));
  const lineHeight = Math.floor(fontSize * 1.4);
  
  tempCtx.font = `${fontSize}px monospace`;
  tempCtx.fillStyle = '#00FF00';
  
  const charWidth = tempCtx.measureText('M').width;
  const charsPerLine = Math.max(20, Math.floor((ctx.width - margin * 2) / charWidth));
  const linesPerPage = Math.max(5, Math.floor((ctx.height - margin * 2) / lineHeight));
  
  let page: number;
  if (pageArg === 58 || pageArg === 1) {
    page = 1;
  } else {
    page = pageArg;
  }
  
  const pages = generateAllHelpPages(charsPerLine, linesPerPage, characterDefs);
  
  let lines: string[];
  if (page >= 1 && page <= pages.length) {
    lines = pages[page - 1];
  } else {
    lines = generateIndexPage(pages.length);
  }
  
  let y = margin + fontSize;
  for (let i = 0; i < Math.min(lines.length, linesPerPage); i++) {
    tempCtx.fillText(lines[i], margin, y);
    y += lineHeight;
  }
  
  const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  out.data.set(imageData.data);
  
  return out;
}

export const characterDefs: Record<string, CharDef> = {
  'A': {
    color: '#78A10F',
    number: 1,
    fn: fnA,
    arity: 0,
    argTypes: [],
    functionName: "flip-and-sphere",
    documentation: "Flips prev horizontally, then renders as texture on two 3D spheres with lighting in top-right and bottom-left quadrants"
  },
  
  'B': {
    color: '#8B4513',
    number: 2,
    fn: fnV,
    arity: 1,
    argTypes: ['color'],
    functionName: "border",
    documentation: "Circular gradient darkening edges, tinted toward color c"
  },
  
  'C': {
    color: '#FF6B35',
    number: 3,
    fn: fnC,
    arity: 1,
    argTypes: ['int'],
    functionName: "concentric-hue",
    documentation: "Creates n concentric circles alternating between original and hue-shifted versions"
  },
  
  'D': {
    color: '#FF1493',
    number: 4,
    fn: fnD,
    arity: 0,
    argTypes: [],
    functionName: "drip",
    documentation: "Metaball-based dripping effect with blobby liquid drips"
  },
  
  'E': {
    color: '#50C878',
    number: 5,
    fn: fnE,
    arity: 0,
    argTypes: [],
    functionName: "emerald",
    documentation: "Renders bright reflective 3D emeralds in symmetric pattern with large center emerald"
  },
  
  'F': {
    color: '#FFD700',
    number: 6,
    fn: fnO,
    arity: 1,
    argTypes: ['int'],
    functionName: "fft-overflow",
    documentation: "2D FFT with magnitude overflow/wrap and per-channel phase shifts - creates banded halos and chromatic frequency ghosts"
  },
  
  'G': {
    color: '#9370DB',
    number: 7,
    fn: fnG,
    arity: 1,
    argTypes: ['int'],
    functionName: "grayscale-colorize",
    documentation: "Converts to grayscale then applies n-color rainbow palette based on brightness"
  },
  
  'H': {
    color: '#DC143C',
    number: 8,
    fn: fnH,
    arity: 0,
    argTypes: [],
    functionName: "hourglass",
    documentation: "Hourglass gradient: NAND blend inside hourglass shape, XOR/add/diff blend outside, creates colors from gradients"
  },
  
  'I': {
    color: '#00FF7F',
    number: 9,
    fn: fnI,
    arity: 0,
    argTypes: [],
    functionName: "invert-edges",
    documentation: "Inverts prev colors, then applies Sobel edge detection and draws edges in white"
  },
  
  'J': {
    color: '#FF8C00',
    number: 10,
    fn: fnF,
    arity: 1,
    argTypes: ['int'],
    functionName: "julia-fractal",
    documentation: "Julia set fractal masks prev - inside set shows prev, outside darkened; n controls zoom level"
  },
  
  'K': {
    color: '#4B0082',
    number: 11,
    fn: fnK,
    arity: 1,
    argTypes: ['int'],
    functionName: "kaleidoscope",
    documentation: "Creates n-way kaleidoscope effect centered on image with 1.1x zoom"
  },
  
  'L': {
    color: '#20B2AA',
    number: 12,
    fn: fnL,
    arity: 2,
    argTypes: ['index', 'int'],
    functionName: "lissajous",
    documentation: "3D Lissajous tube textured with prev, old_image as background; first arg=old image, second=rotation"
  },
  
  'M': {
    color: '#FF69B4',
    number: 13,
    fn: fnM,
    arity: 1,
    argTypes: ['int'],
    functionName: "moire",
    documentation: "MoirÃ© interference pattern: 3 overlapping line grids create 8 zones with different hue/saturation/lightness shifts"
  },
  
  'N': {
    color: '#8A2BE2',
    number: 14,
    fn: fnN,
    arity: 0,
    argTypes: [],
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnOilSlick,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "oil-slick",
    documentation: "Domain warping effect; first arg controls warp strength, second controls iterations/complexity"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
    documentation: "Pixelates with cell size n+1, diagonal split: top-left = average, bottom-right = most saturated"
  },
  
  'Q': {
    color: '#32CD32',
    number: 17,
    fn: fnQ,
    arity: 0,
    argTypes: [],
    functionName: "prism",
    documentation: "Creates negative prism: diagonal split with inversion, then mirrors into 4 quadrants (h-flip right, v-flip bottom)"
  },
  
  'R': {
    color: '#DA70D6',
    number: 18,
    fn: fnR,
    arity: 0,
    argTypes: [],
    functionName: "room",
    documentation: "3D room with three walls, ceiling, and floor textured with prev, lit from center"
  },
  
  'S': {
    color: '#87CEEB',
    number: 19,
    fn: fnS,
    arity: 2,
    argTypes: ['index', 'int'],
    functionName: "sierpinski",
    documentation: "SierpiÅ„ski triangle fractal: first arg=old image for interior, second=detail level (1-68); outer shells get hue shifts, invert, grayscale"
  },
  
  'T': {
    color: '#F0E68C',
    number: 20,
    fn: fnT,
    arity: 1,
    argTypes: ['int'],
    functionName: "cubes",
    documentation: "n+1 3D cubes protrude from prev plane toward camera, tops textured from prev, sides use edge pixels, lit from front"
  },
  
  'U': {
    color: '#DDA0DD',
    number: 21,
    fn: fnU,
    arity: 1,
    argTypes: ['int'],
    functionName: "undertone",
    documentation: "HSL color shift with three gradient directions 120Â° apart: hue rotation, saturation multiply, lightness adjust (midtone-weighted); n controls angle and intensity"
  },
  
  'V': {
    color: '#40E0D0',
    number: 22,
    fn: fnB,
    arity: 1,
    argTypes: ['index'],
    functionName: "voronoi",
    documentation: "Breaks image into 36 voronoi cells, alternating between prev and old image"
  },
  
  'W': {
    color: '#EE82EE',
    number: 23,
    fn: fnW,
    arity: 1,
    argTypes: ['int'],
    functionName: "swirl",
    documentation: "Swirl distortion from center, rotation = n*45Â°, quadratic falloff"
  },
  
  'X': {
    color: '#F5DEB3',
    number: 24,
    fn: fnX,
    arity: 2,
    argTypes: ['int', 'color'],
    functionName: "shape-overlay",
    documentation: "Draws unicode shape k%64 at center in color c (â˜…â—â– â–²â—†â™¥âœ¦â¬¡âœšâ—â˜½âš¡âˆžâ˜€âœ¿â¬¢...)"
  },
  
  'Y': {
    color: '#98FB98',
    number: 25,
    fn: fnY,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-hue",
    documentation: "Splits into n radial sections, each hue-rotated by i*(360/n)Â°"
  },
  
  'Z': {
    color: '#AFEEEE',
    number: 26,
    fn: fnZ,
    arity: 1,
    argTypes: ['int'],
    functionName: "zoom-blur",
    documentation: "Radial motion blur from center, blur amount n*4px, center 20% stays sharp"
  },
  
  '0': {
    color: '#E6E6FA',
    number: 27,
    fn: fn0,
    arity: 1,
    argTypes: ['index'],
    functionName: "overlay",
    documentation: "Overlay blend mode: combines prev with old_image, darkening darks and lightening lights"
  },
  
  '1': {
    color: '#FFA07A',
    number: 28,
    fn: fn1,
    arity: 0,
    argTypes: [],
    functionName: "center-bar",
    documentation: "Middle third of image shows prev sharpened and contrast-boosted, rest is desaturated"
  },
  
  '2': {
    color: '#98D8C8',
    number: 29,
    fn: fn2,
    arity: 0,
    argTypes: [],
    functionName: "time-echo",
    documentation: "Left third shows 3rd previous image, middle shows 2nd previous, right shows prev - recent history triptych"
  },
  
  '3': {
    color: '#F7DC6F',
    number: 30,
    fn: fn3,
    arity: 0,
    argTypes: [],
    functionName: "triple-rotate",
    documentation: "Divides into 3 vertical strips; left rotated 90Â° CW, middle unchanged, right rotated 90Â° CCW"
  },
  
  '4': {
    color: '#BB8FCE',
    number: 31,
    fn: fn4,
    arity: 0,
    argTypes: [],
    functionName: "quad-rotate",
    documentation: "Divides into 2x2 quadrants, each rotated (0Â°, 90Â°, 180Â°, 270Â°)"
  },
  
  '5': {
    color: '#85C1E9',
    number: 32,
    fn: fn5,
    arity: 1,
    argTypes: ['int'],
    functionName: "triangular-split",
    documentation: "Splits prev into triangles based on cell width, each with hue shift and lightness variation"
  },
  
  '6': {
    color: '#F1948A',
    number: 33,
    fn: fn6,
    arity: 0,
    argTypes: [],
    functionName: "posterize",
    documentation: "Posterizes prev to 4 levels per channel"
  },
  
  '7': {
    color: '#82E0AA',
    number: 34,
    fn: fn7,
    arity: 0,
    argTypes: [],
    functionName: "chromatic",
    documentation: "Chromatic aberration: R shifted left 4px, G centered, B shifted right 4px"
  },
  
  '8': {
    color: '#F8C471',
    number: 35,
    fn: fn8,
    arity: 1,
    argTypes: ['int'],
    functionName: "lemniscate",
    documentation: "Infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along curve"
  },
  
  '9': {
    color: '#D7BDE2',
    number: 36,
    fn: fn9,
    arity: 1,
    argTypes: ['index'],
    functionName: "xor-blend",
    documentation: "XORs prev with old_image, creating glitchy digital artifacts"
  },
  
  '<': {
    color: '#E74C3C',
    number: 37,
    fn: fnLessThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-left",
    documentation: "Shifts prev 1/3 of the width to the left with wraparound"
  },
  
  '>': {
    color: '#3498DB',
    number: 38,
    fn: fnGreaterThan,
    arity: 0,
    argTypes: [],
    functionName: "rotate-90",
    documentation: "Rotates prev 90 degrees clockwise"
  },
  
  '^': {
    color: '#2ECC71',
    number: 39,
    fn: fnCaret,
    arity: 0,
    argTypes: [],
    functionName: "shift-up",
    documentation: "Shifts prev 1/3 of the height up with wraparound"
  },
  
  '!': {
    color: '#FF4500',
    number: 40,
    fn: fnAsterisk,
    arity: 0,
    argTypes: [],
    functionName: "godrays",
    documentation: "Volumetric light scattering (god rays) effect from center, additively blended with prev"
  },
  
  '"': {
    color: '#9932CC',
    number: 41,
    fn: fnDoubleQuote,
    arity: 1,
    argTypes: ['int'],
    functionName: "band-transform",
    documentation: "Splits into n horizontal bands; odd bands hue-rotated 180Â°, even bands have saturation inverted"
  },
  
  '#': {
    color: '#228B22',
    number: 42,
    fn: fnQuestion,
    arity: 0,
    argTypes: [],
    functionName: "corner-effect",
    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
  },
  
  '$': {
    color: '#FFD700',
    number: 43,
    fn: fnDollar,
    arity: 0,
    argTypes: [],
    functionName: "segment-hue-sort",
    documentation: "Color-based flood-fill segmentation, then sorts pixels within each segment by hue vertically"
  },
  
  '%': {
    color: '#8B0000',
    number: 44,
    fn: fnPercent,
    arity: 1,
    argTypes: ['int'],
    functionName: "flip",
    documentation: "Flips image horizontally if n is even, vertically if n is odd"
  },
  
  '&': {
    color: '#4169E1',
    number: 45,
    fn: fnAmpersand,
    arity: 0,
    argTypes: [],
    functionName: "dither",
    documentation: "Aggressive ordered dither using 8x8 Bayer matrix with chromatic channel offsets for RGB separation"
  },
  
  "'": {
    color: '#FF1493',
    number: 46,
    fn: fnJ,
    arity: 1,
    argTypes: ['index'],
    functionName: "variable-checkerboard",
    documentation: "Checkerboard blend where square size increases from top-left (2px) to bottom-right (52px)"
  },
  
  '(': {
    color: '#00CED1',
    number: 47,
    fn: fnOpenParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "pinch",
    documentation: "Pinch distortion toward center with strength n/10, brightens pixels near center"
  },
  
  ')': {
    color: '#FF69B4',
    number: 48,
    fn: fnCloseParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "bulge",
    documentation: "Bulge distortion from center with strength n/10, darkens pixels near edge"
  },
  
  '*': {
    color: '#FFD700',
    number: 49,
    fn: fnExclaim,
    arity: 0,
    argTypes: [],
    functionName: "fur",
    documentation: "Fur/hair effect: strands grow from each pixel with direction based on hue plus turbulence and swirl"
  },
  
  '+': {
    color: '#32CD32',
    number: 50,
    fn: fnPlus,
    arity: 0,
    argTypes: [],
    functionName: "zoom",
    documentation: "Zooms in 1.2x from center, can be repeated for more zoom"
  },
  
  ',': {
    color: '#BA55D3',
    number: 51,
    fn: fnComma,
    arity: 1,
    argTypes: ['color'],
    functionName: "stipple",
    documentation: "Stipples prev with dots of color c at positions where (x*13+y*7) % (1+luminance/32) == 0"
  },
  
  '-': {
    color: '#708090',
    number: 52,
    fn: fnMinus,
    arity: 0,
    argTypes: [],
    functionName: "scanlines",
    documentation: "CRT scanline effect: every 2nd row darkened 50%, every 4th row samples from 2 pixels above"
  },
  
  '.': {
    color: '#20B2AA',
    number: 53,
    fn: fnDot,
    arity: 1,
    argTypes: ['int'],
    functionName: "pointillism",
    documentation: "Rebuilds prev from circles of radius (n%8)+2, color from center with +10% saturation"
  },
  
  '/': {
    color: '#CD853F',
    number: 54,
    fn: fnSlash,
    arity: 5,
    argTypes: ['index', 'int', 'int', 'int', 'int'],
    functionName: "circle-stamp",
    documentation: "Stamps a circle from center of old image onto prev; args: old_idx, x, y, size, blend (A=normal, B=xor, C=nand, D=and, E=or, F=multiply, G=screen, H=overlay, I=darken, J=lighten, K=diff, L=excl, M=add, N=sub, O=hard, P=soft)"
  },
  
  ':': {
    color: '#6B8E23',
    number: 55,
    fn: fnColon,
    arity: 1,
    argTypes: ['index'],
    functionName: "porthole",
    documentation: "Shows old image in a center circle (radius 90% of half-size), prev image outside"
  },
  
  ';': {
    color: '#DB7093',
    number: 56,
    fn: fnSemicolon,
    arity: 0,
    argTypes: [],
    functionName: "semicircle-reflect",
    documentation: "Semicircle arc (top half) crops prev, bottom half is reflection with wave distortion"
  },
  
  '=': {
    color: '#5F9EA0',
    number: 57,
    fn: fnEquals,
    arity: 1,
    argTypes: ['int'],
    functionName: "shifted-stripes",
    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
  },
  
  '?': {
    color: '#D2691E',
    number: 58,
    fn: fnHelp,
    arity: 1,
    argTypes: ['int'],
    functionName: "help",
    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, invalid pages show index"
  },
  
  '@': {
    color: '#7B68EE',
    number: 59,
    fn: fnHoles,
    arity: 1,
    argTypes: ['index'],
    functionName: "midtone-reveal",
    documentation: "Shows old image where prev has mid-range (35-65%) saturation or lightness; extremes show prev"
  },
  
  '[': {
    color: '#48D1CC',
    number: 60,
    fn: fnOpenBracket,
    arity: 0,
    argTypes: [],
    functionName: "rotate-left",
    documentation: "Rotates prev 20 degrees counter-clockwise"
  },
  
  '\\': {
    color: '#C71585',
    number: 61,
    fn: fnBackslash,
    arity: 11,
    argTypes: ['index', 'int', 'int', 'int', 'int', 'int', 'int', 'int', 'int', 'int', 'int'],
    functionName: "composite",
    documentation: "Composites a region from old image onto prev; args: old_idx, src_x, src_y, src_w, src_h, dst_x, dst_y, dst_w, dst_h, rotation, blend (A=normal, B=xor, C=nand, D=and, E=or, F=multiply, G=screen, H=overlay, I=darken, J=lighten, K=difference, L=exclusion, M=add, N=subtract, O=hardlight, P=softlight)"
  },
  
  ']': {
    color: '#00FA9A',
    number: 62,
    fn: fnCloseBracket,
    arity: 0,
    argTypes: [],
    functionName: "left-half-offset",
    documentation: "Offsets the left half of the image vertically by 20% with wraparound"
  },
  
  '_': {
    color: '#FF7F50',
    number: 63,
    fn: fnUnderscore,
    arity: 1,
    argTypes: ['index'],
    functionName: "blur-luminosity",
    documentation: "Luminosity blend: colors from heavily blurred old image, luminance/structure from prev"
  },
  
  '`': {
    color: '#6495ED',
    number: 64,
    fn: fnBacktick,
    arity: 1,
    argTypes: ['int'],
    functionName: "gradient-smear",
    documentation: "Iteratively smears pixels along image gradients; edges create directional streaks, n controls iterations and strength"
  },
  
  '{': {
    color: '#DC143C',
    number: 65,
    fn: fnSkewLeft,
    arity: 0,
    argTypes: [],
    functionName: "skew-left",
    documentation: "Skews image 20 degrees left (top shifts left, bottom shifts right) with wraparound"
  },
  
  '|': {
    color: '#00BFFF',
    number: 66,
    fn: fnPipe,
    arity: 1,
    argTypes: ['index'],
    functionName: "vertical-split",
    documentation: "Left=prev, right=old image; 20% wavy blend zone uses screen/difference/xor in alternating horizontal bands"
  },
  
  '}': {
    color: '#9400D3',
    number: 67,
    fn: fnSkewRight,
    arity: 0,
    argTypes: [],
    functionName: "skew-right",
    documentation: "Skews image 20 degrees right (top shifts right, bottom shifts left) with wraparound"
  },
  
  '~': {
    color: '#FF6347',
    number: 68,
    fn: fnTilde,
    arity: 1,
    argTypes: ['int'],
    functionName: "wave-chromatic",
    documentation: "Horizontal wave distortion with amplitude = sin(y*0.05)*n*8, chromatic aberration (R +n px, B -n px)"
  },
};
</eval-result-115036785372>}

---

# index.html:

${:sh cat index.html<eval-result-115036607723><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QQQLANG</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="favicon-192.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
      background: #000;
    }
    
    #app {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    
    #input-container {
      flex-shrink: 0;
      padding: 10px;
      background: #000;
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    
    #input-wrapper {
      position: relative;
      flex: 1;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      height: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      background: transparent;
      color: transparent;
      caret-color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      background: #1a1a1a;
      color: #fff;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      padding: 1px 0;
    }
    
    #input-background span.upload-char {
      text-decoration: underline;
      text-decoration-style: dotted;
    }
    
    #input-background span.upload-char.upload-invalid {
      color: #666;
    }
    
    .toolbar-button {
      padding: 10px 15px;
      font-size: 14px;
      font-family: monospace;
      border: 2px solid #444;
      background: #1a1a1a;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
      min-width: 90px;
      width: 90px;
      text-align: center;
    }
    
    #upload-button {
      width: 90px;
    }
    
    #download-button {
      width: 100px;
    }
    
    .toolbar-button:hover:not(:disabled) {
      border-color: #888;
      background: #333;
    }
    
    .toolbar-button:active:not(:disabled) {
      background: #444;
    }
    
    .toolbar-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .toolbar-button .btn-icon {
      display: none;
    }
    
    .toolbar-button .btn-indicator {
      font-style: italic;
    }
    
    .toolbar-button .btn-rainbow {
      background: linear-gradient(to bottom, 
        #ff0000, #ff8000, #ffff00, #00ff00, #0080ff, #8000ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
    }
    
    @media (max-width: 600px) {
      .toolbar-button .btn-text {
        display: none;
      }
      .toolbar-button .btn-icon {
        display: inline;
        font-size: 18px;
      }
      .toolbar-button {
        padding: 10px 12px;
        min-width: 44px;
        width: 44px;
      }
      #upload-button, #download-button {
        width: 44px;
      }
    }
    
    #canvas-container {
      flex: 1;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #canvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
    
    #intro-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 1000;
      transition: opacity 1s ease-out;
    }
    
    #intro-overlay.fading {
      opacity: 0;
      pointer-events: none;
    }
    
    #intro-overlay.hidden {
      display: none;
    }
    
    #intro-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
  </style>
</head>
<body>
  <div id="app">
    <div id="input-container">
      <div id="input-wrapper">
        <div id="input-background"></div>
        <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
      </div>
      <button id="upload-button" class="toolbar-button" disabled>
        <span class="btn-text"><span class="btn-indicator">ð‘“ð‘›</span></span>
        <span class="btn-icon">ð‘“</span>
      </button>
      <button id="download-button" class="toolbar-button"><span class="btn-text">Download</span><span class="btn-icon">â¬‡</span></button>
      <button id="help-button" class="toolbar-button"><span class="btn-text">Help</span><span class="btn-icon">?</span></button>
    </div>
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div id="debug-pane"></div>
  
  <div id="intro-overlay" class="hidden">
    <video id="intro-video" playsinline muted></video>
  </div>
  
  <input type="file" id="file-input" accept="image/*" style="display: none;">

  <script type="module">
    import { runProgram, getParsedOperations, getExpectedNextType, getExpectedTypeAtPosition, getInvalidUploadIndices, addUploadedBlob, setUploadedBlob, preloadUploadedImages, clearUploadedImages } from './runtime.ts';
    import { characterDefs, emeraldReady, UPLOAD_CHAR } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');
    const helpButton = document.getElementById('help-button');
    const downloadButton = document.getElementById('download-button');
    const uploadButton = document.getElementById('upload-button');
    const fileInput = document.getElementById('file-input');

    const introOverlay = document.getElementById('intro-overlay');
    const introVideo = document.getElementById('intro-video');

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    const INTRO_SEEN_KEY = 'qqqlang-intro-seen';
    const INTRO_DURATION_MS = 4000;
    const FADE_DURATION_MS = 1000;
    
    let pendingUploadIndex = null;
    
    function shouldShowIntro() {
      const params = new URLSearchParams(window.location.search);
      if (params.has('show-intro')) return true;
      if (params.has('p')) return false;
      if (localStorage.getItem(INTRO_SEEN_KEY)) return false;
      return true;
    }
    
    function showIntro() {
      introOverlay.classList.remove('hidden');
      
      introVideo.src = 'intro.mp4';
      introVideo.loop = true;
      introVideo.play().catch(() => {});
      
      setTimeout(() => {
        introOverlay.classList.add('fading');
        
        setTimeout(() => {
          introOverlay.classList.add('hidden');
          introVideo.pause();
          introVideo.src = '';
          
          localStorage.setItem(INTRO_SEEN_KEY, 'true');
          
          const program = '???';
          input.value = program;
          updateURL(program);
          render();
          input.focus();
        }, FADE_DURATION_MS);
      }, INTRO_DURATION_MS);
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs || char === UPLOAD_CHAR;
    }
    
    function completeProgram(program) {
      if (!program) return program;
      const ops = getParsedOperations(program);
      if (ops.length === 0) return program;
      
      const lastOp = ops[ops.length - 1];
      if (lastOp.type === 'function') {
        const def = lastOp.fnDef;
        const prevIdentifier = ops.length > 1 ? ops[ops.length - 2].identifier : '';
        const currentOpChars = [...lastOp.identifier.substring(prevIdentifier.length)];
        const argsProvided = currentOpChars.length - 1;
        const argsNeeded = def.arity - argsProvided;
        
        if (argsNeeded > 0) {
          const fnChar = currentOpChars[0];
          for (let i = 0; i < argsNeeded; i++) {
            program += fnChar;
          }
        }
      }
      return program;
    }
    
    function updateUploadButtonState() {
      const cursorPos = input.selectionStart ?? input.value.length;
      const expectedType = getExpectedTypeAtPosition(input.value, cursorPos);
      const btnText = uploadButton.querySelector('.btn-text .btn-indicator');
      const btnIcon = uploadButton.querySelector('.btn-icon');
      
      if (expectedType === 'initial' || expectedType === 'index') {
        uploadButton.disabled = false;
        btnText.className = 'btn-indicator';
        btnText.textContent = 'Upload';
        btnIcon.textContent = 'ðŸ“·';
      } else if (expectedType === 'function') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator';
        btnText.textContent = 'ð‘“ð‘›';
        btnIcon.textContent = 'ð‘“';
      } else if (expectedType === 'int') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator';
        btnText.textContent = 'ð‘¥';
        btnIcon.textContent = 'ð‘¥';
      } else if (expectedType === 'color') {
        uploadButton.disabled = true;
        btnText.className = 'btn-indicator btn-rainbow';
        btnText.textContent = 'â– ';
        btnIcon.textContent = 'ðŸŒˆ';
      }
    }
    
    
    function getUploadCharIndex(str, charPosition) {
      let uploadIndex = 0;
      const chars = [...str];
      for (let i = 0; i < charPosition && i < chars.length; i++) {
        if (chars[i] === UPLOAD_CHAR) {
          uploadIndex++;
        }
      }
      return uploadIndex;
    }
    
    uploadButton.addEventListener('click', () => {
      const cursorPos = input.selectionStart ?? input.value.length;
      const expectedType = getExpectedTypeAtPosition(input.value, cursorPos);
      if (expectedType === 'initial' || expectedType === 'index') {
        pendingUploadIndex = null;
        fileInput.click();
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const blob = file;
      
      if (pendingUploadIndex !== null) {
        setUploadedBlob(pendingUploadIndex, blob);
        pendingUploadIndex = null;
      } else {
        addUploadedBlob(blob);
        
        const start = input.selectionStart;
        const before = input.value.substring(0, start);
        const after = input.value.substring(input.selectionEnd);
        input.value = before + UPLOAD_CHAR + after;
        input.selectionStart = input.selectionEnd = start + UPLOAD_CHAR.length;
      }
      
      fileInput.value = '';
      updateURL(input.value);
      await render();
      input.focus();
    });
    
    helpButton.addEventListener('click', () => {
      let program = input.value;
      if (!program) {
        program = 'A';
      }
      program = completeProgram(program);
      program += '??';
      input.value = program;
      updateURL(program);
      render();
      input.focus();
    });
    
    downloadButton.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'qqqlang-' + (input.value || 'empty') + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    function getProgramFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('p') || '';
    }

    function updateURL(program) {
      const params = new URLSearchParams(window.location.search);
      if (program) {
        params.set('p', program);
      } else {
        params.delete('p');
      }
      const newSearch = params.toString();
      const newURL = window.location.pathname + (newSearch ? '?' + newSearch : '');
      if (window.location.pathname + window.location.search !== newURL) {
        window.history.pushState({ program }, '', newURL);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else if (op.type === 'uploaded-image') {
          html += `<div class="op">[${i}] "${opChars}" uploaded-image(${op.uploadIndex})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.map(a => 
            typeof a === 'object' ? `upload:${a.index}` : a
          ).join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    let uploadCharPositions = [];
    let invalidUploadIndicesCache = new Set();
    
    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const invalidUploads = getInvalidUploadIndices(program);
      invalidUploadIndicesCache = invalidUploads;
      
      const chars = [...program].filter(c => {
        const code = c.codePointAt(0);
        return (code > 32 && code < 127) || c === UPLOAD_CHAR;
      });
      
      let html = '';
      let charIdx = 0;
      let uploadIdx = 0;
      uploadCharPositions = [];
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = [...op.identifier.substring(prevIdentifier.length)];
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else if (op.type === 'uploaded-image') {
          color = '#888888';
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            const char = chars[charIdx];
            if (char === UPLOAD_CHAR) {
              const isInvalid = invalidUploads.has(uploadIdx);
              const invalidClass = isInvalid ? ' upload-invalid' : '';
              const displayChar = isInvalid ? 'â– ' : char;
              html += `<span class="upload-char${invalidClass}" style="background-color: ${bgColor};" data-upload-index="${uploadIdx}" data-char-index="${charIdx}">${displayChar}</span>`;
              uploadCharPositions.push({ charIdx, uploadIdx, isInvalid });
              uploadIdx++;
            } else {
              html += `<span style="background-color: ${bgColor};">${char}</span>`;
            }
            charIdx++;
          }
        }
      }
      
      // Also render any remaining upload chars that weren't part of ops (invalid ones skipped)
      while (charIdx < chars.length) {
        const char = chars[charIdx];
        if (char === UPLOAD_CHAR) {
          const isInvalid = invalidUploads.has(uploadIdx);
          const invalidClass = isInvalid ? ' upload-invalid' : '';
          const displayChar = isInvalid ? 'â– ' : char;
          html += `<span class="upload-char${invalidClass}" style="background-color: #44444440;" data-upload-index="${uploadIdx}" data-char-index="${charIdx}">${displayChar}</span>`;
          uploadCharPositions.push({ charIdx, uploadIdx, isInvalid });
          uploadIdx++;
        } else {
          html += `<span style="background-color: #44444440;">${char}</span>`;
        }
        charIdx++;
      }
      
      inputBackground.innerHTML = html;
    }
    
    function isOverUploadChar(clientX) {
      if (uploadCharPositions.length === 0) return false;
      
      const inputRect = input.getBoundingClientRect();
      const clickX = clientX - inputRect.left;
      
      const spans = inputBackground.querySelectorAll('.upload-char:not(.upload-invalid)');
      for (const span of spans) {
        const spanRect = span.getBoundingClientRect();
        const bgRect = inputBackground.getBoundingClientRect();
        const spanLeft = spanRect.left - bgRect.left;
        const spanRight = spanLeft + spanRect.width;
        
        if (clickX >= spanLeft && clickX <= spanRight) {
          return true;
        }
      }
      return false;
    }
    
    function handleInputClick(e) {
      if (uploadCharPositions.length === 0) return;
      
      const inputRect = input.getBoundingClientRect();
      const clickX = e.clientX - inputRect.left;
      
      const spans = inputBackground.querySelectorAll('.upload-char:not(.upload-invalid)');
      for (const span of spans) {
        const spanRect = span.getBoundingClientRect();
        const bgRect = inputBackground.getBoundingClientRect();
        const spanLeft = spanRect.left - bgRect.left;
        const spanRight = spanLeft + spanRect.width;
        
        if (clickX >= spanLeft && clickX <= spanRight) {
          const idx = parseInt(span.dataset.uploadIndex, 10);
          pendingUploadIndex = idx;
          fileInput.click();
          e.preventDefault();
          return;
        }
      }
    }
    
    function handleInputMouseMove(e) {
      if (isOverUploadChar(e.clientX)) {
        input.style.cursor = 'pointer';
      } else {
        input.style.cursor = '';
      }
    }

    function resize() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }

    function updateFaviconAndTitle(program) {
      let favicon = document.getElementById('dynamic-favicon');
      if (!favicon) {
        favicon = document.createElement('link');
        favicon.id = 'dynamic-favicon';
        favicon.rel = 'icon';
        favicon.type = 'image/png';
        document.head.appendChild(favicon);
      }
      
      if (program) {
        document.title = 'QQQLANG - ' + program;
        
        const size = Math.min(canvas.width, canvas.height);
        const x = Math.floor((canvas.width - size) / 2);
        const y = Math.floor((canvas.height - size) / 2);
        
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.drawImage(canvas, x, y, size, size, 0, 0, 32, 32);
        
        favicon.href = faviconCanvas.toDataURL('image/png');
      } else {
        document.title = 'QQQLANG';
        favicon.href = 'favicon-32.png';
      }
    }
    
    async function render() {
      const program = input.value || '';
      
      await preloadUploadedImages(canvas.width, canvas.height);
      
      const images = runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
      updateFaviconAndTitle(program);
      updateUploadButtonState();
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      
      clearUploadedImages();
      
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
    });
    
    input.addEventListener('keyup', updateUploadButtonState);
    input.addEventListener('mouseup', updateUploadButtonState);
    input.addEventListener('focus', updateUploadButtonState);
    
    input.addEventListener('click', handleInputClick);
    input.addEventListener('mousemove', handleInputMouseMove);
    input.addEventListener('mouseleave', () => { input.style.cursor = ''; });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    emeraldReady.then(() => {
      if (shouldShowIntro()) {
        showIntro();
        resize();
      } else {
        loadProgramFromURL();
        resize();
      }
    });
  </script>
</body>
</html>
</eval-result-115036607723>}


---

# NEXT TASK

Replace `#` with a function that inserts an old image, plain replacing prev image

# THINKING

Signature: EokRCkYIChgCKkCXjWw6w7q1nVwxWLN13s2UhEqU7DmjBKEW4JUii5QRpruIyLWz4ZWf+XO5ZceuBQQqfTYO3QzcUUcgXJG5VBWuEgxpe4LAyrzNJUIYcuAaDGyYljO75DI4agk8cSIwqrqQSWx3v1YTgc/jeLSPyGYaztPmx+s0F7z9AwT6l6nzxs8j1ELMvQW/eEz4eQEEKvAPEYBWR4uctlh56uXOFzsFZfIAB1r5kLVJqm8rhevmExSXZEKM+MhGMFtgn/VwUck/3NGbMJ0U7Qga4+mfyy1xMkvV1aEhyv53DxyNuHeN/VvDC0G+J5ib1i9WWNyy++8rRgJRV09u7TGrFq+U24orq5YitbQhSvpSqNr1OMsR6bPDOy6CvC5z8+AY01eXzMKrCr81F8ejl0GSXhbhf+MKjUpM70v31QZ0UINi5jT/pkBLwOfxbBZBMpc7CULoT+lc2O1UG07048V+9oSRe+IrUcDOhwZRqwZmrJ3/C0w1x2NljmQ6s4Y1DEhhGdPGRg6y4qYUDS8RNql/Vkd8dS+S9NHEaMD67IFiijDLX4+v3IctdXJAqomO4uNHtuiseql48c3GMxtb7BuLNhgfw7lt0+9hvIJ2w3OMU4oBjjcj9CM901FAC9jcrY8OhSag+Z32wc/hmiZVBdT7nqi8ixsX6dAuxMH353BH7ZGEiW02G8m673Kt7eUE5j6u1W7m2/WC70REpNscJcTHcOtxwUbUAmUCvN2epZyZl2AzWiprmKieycRyngpd6xuJlaxDqhM3V3ndgo4y6Ah91tgSSl0uzOnnYFEbLE3t7pa80UbCurxqlEM3JAFcov8bat5C5x2YQDH3KrjYsFDu1v0Fq4AOiDEIL9lBelHLSIHvb/koQ/HrUR+H6vsnbCfn8CcMDc5Xika0dWE2RJIp9qrjXBIS8oTaHNaM7oqNK/9H3M1utmyu+SIluK6tgHaYiTSaCfwPLJa1M2JkXEGvS3030aBl+HsguJGvL8I4zaPe/p9WMsw4gAjmlhMt0mGaizVCuLcXpcLzTzHcscSTAUiwfyL1AtwiovWrZXtukLekAWMBJ8DEMUZXTYQgjP1HEG+5bQkpiKHRnHkpDgDk4A9KlR2CPAyw86A0AWVNCy+ixz0TYkGlia4147aTAM/bSPWETK2mKyE9Ur6cWYTSZBFUyfmwVl/ofOI4/Sr7V74K6cjadEnpDVtJmWgVY0q9kfZcYcMCdbVurbp27TxKXFpeg92pOSSXzdWEagDoZFTWUlRqh2+AAYQIlPMLlesV74k7QZVRucVjy744HDlhBSQjdm1GW9Z9Od3EkXe1R9srMDtRy3DNbLF9ywkeMdB7GRg56VdybpXbYKoNHNmfJiCgRQrdHyO/OYYb+f3+2902LKrkwzPf6lpy+uABJlgyK9DgA8ZQjWmx7EKaxAGZjr1qCnBYqS5vzMdEOyLnTwtp5P9/vFJLbL812aBduZkJSPHqjRbBa9MNTeJhoZBluUeeSwqSPNo0LNQV+Gg7+GJ75JmVT7chtqxck4c+LV1TyheZGkxQrDXtwODR+qtUG5L3ZqnIrq8yoeJO4pSoR3uQCs8+sF8h4AKRV/vJYjIUUEHzhApfy9PGJb9NkUGo/7V+is3ePqWj52Olnnl3f8fu65b/e79GKHjr0qKp/03UWX7QJn5va0DAcNFT7f+WfBeRRw0V1weZpoRy0mMDUVtYQPxYbkKTBIGSsFGHkqAbNxPX7y1/deixVLDB5flDiNnrpQq+csdMFXt61wEord6yCyxluKF4FOZ7bLceiXNc2VIykycmdoA1gXAWG6PFiaXpDbXMP4HltaxXkMnUDKCrGySJxYGOB9al4W6JAbgOWnUy30iOpabCwPW/WSjsXcL0P6DGpDBnX+KjslcklKao3h4f6j4VHfVXqFGCRSTMSNMDDSxKbOxeno89G/iRF7JI/LnkIs+qq1LaEo+jZMumJsaHrCTjJxJJmqH/Fsar7GsIpRYRUt2Srx84tPeGzbSPns1DDdvb1Zx3MFsvIh2sFdQEy5A1KCXCKUMFg5CcLbi/mUJWokHV0fUnbzajhDkbptjrP25NIPiaxaSxlUTokDxnPurNKPwD47Hafwy8slwkX1yVnAscgUcxdw47oD3pPHWQpfD0BkHPMyl01dphyHsnkG2d4hsghpHYkWLt6SZEsYtcQL5SlHUltYoHFpZ/b7YEvAb8wcEDlrPNqUG2AXxIvxGLEHI5tiqTaku18y1NM/QubJvwE91VxowMurdq0GjOdalRXLChdavKiOMr5tP0sUX9/vtcTeGbCkp47Vho2LDNThAWcEB73TiDxXNXnF/kQXuu4MJ/+1w4YMt7VFqyCOIh9hesuLrlnYsJdFvNWudqt/cNm0WeTTSat3LjQdg/4DfBK5Ec4nhUPo4jkMgCtg5XFKkHyewmM03Gnl78ljd+4RWzmFW2EBjoqrnB8DT+VIXTCZ6KQBsgrmYFHRWZ1CT8vU0LB6U2b+LUUT4MGX7noSfxQhnCYdWxdQHtuyTTBCqz39S0KMHxMoqVJ6BQHWfZq8QyIR41vuWFl6IScT7fm5j6D3BoN+L5ASKC5/CkJT5HsEOyPDyq0GudfC4WR7ygwqTYsZSw5idN+ssSdp8hIOSr9RtgzOGDN9NHBXdiKxrKDI3qGpQzX0OsHqnlqJVYLeVwr+daSBT1itsNb88Q8QiIzgUp8SwFkbKpCnymVuQGUx9lDvFqe2bVb0FmRiy9yntvAueJrXTinbxe3X3nxfD0Bq22ATI3GW68ryxE0/ta61vC4bvxRLnv4UM42j/6ivP3jpd/Zioeki/T+Y30A6W6+xExliW0ZSiIciDD5Uuu6rA0vsFE08UHIGtIgAN/7eblFM36l/Yri+yJOcgpAJR8AJbhaj0zecsobO6xIxgB

The user wants to replace the `#` function with a new function that simply inserts an old image, replacing the previous image. This is a simple function that takes an index argument and returns that old image.

Let me look at the current `#` definition:

```typescript
'#': {
    color: '#228B22',
    number: 42,
    fn: fnQuestion,
    arity: 0,
    argTypes: [],
    functionName: "corner-effect",
    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
  },
```

I need to:
1. Create a new function that takes an index argument and returns that old image
2. Update the character definition

The function should be simple - just get the old image from the context and return it.

Let me write this:

```typescript
function fnHash(ctx: FnContext, old: Image): Image {
  return cloneImage(old);
}
```

Actually, looking at how other functions handle this, I should clone the image to avoid mutations. Let me check if `cloneImage` exists - yes it does.

So the new definition would be:

```typescript
'#': {
    color: '#228B22',
    number: 42,
    fn: (ctx: FnContext, old: Image) => cloneImage(old),
    arity: 1,
    argTypes: ['index'],
    functionName: "insert",
    documentation: "Replaces prev with old image specified by index argument"
  },
```

Wait, I should create a named function for consistency with the rest of the code. Let me create `fnInsert` or just inline it since it's so simple.

Actually, looking at the code style, most functions are named `fn` + something. Let me create a simple function called `fnInsert`:

```typescript
function fnInsert(ctx: FnContext, old: Image): Image {
  return cloneImage(old);
}
```

I'll track down where to add this function and update the `#` character definition. I'll search for where `fnQuestion` is currently used to understand the context and make the appropriate changes.

# ASSISTANT

Looking at the current `#` definition, I need to replace it with a simple function that inserts an old image. Let me make this change:

# TOOL USE

Name: str-replace
ID: toolu_01Ve8kFUqsFKwj16KvSNgXjW

## path

<tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>
character-defs.ts
</tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>

## diff

<tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>
   '#': {
     color: '#228B22',
     number: 42,
-    fn: fnQuestion,
-    arity: 0,
-    argTypes: [],
-    functionName: "corner-effect",
-    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
+    fn: (ctx: FnContext, old: Image) => cloneImage(old),
+    arity: 1,
+    argTypes: ['index'],
+    functionName: "insert",
+    documentation: "Replaces prev with old image specified by index argument"
   },
\ No newline at end of file

</tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>

## git-commit-message

<tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>
Replace # function with simple insert that replaces prev with old image
</tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>

# TOOL RESULT

ID: toolu_01Ve8kFUqsFKwj16KvSNgXjW

<tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Replace # function with simple insert that replaces prev with old image
</tool.toolu_01Ve8kFUqsFKwj16KvSNgXjW>

# ASSISTANT

The `#` function has been replaced with a simple insert function that:
- Takes 1 argument of type `index` (an old image from history)
- Returns that old image, effectively replacing the previous image in the pipeline

For example, in a program like `ABC#A`, the `#A` would insert image at index 1 (the result after `A`), replacing whatever the current image was.

# USER

Make `_` a general blend function that blends prev with the prev-1 (the one preceding prev). The single argument should be the blend function, including xor, nand, luminosity, and several other standard and some esoteric blend functions

# THINKING

Signature: EqseCkYIChgCKkC5k47h94gpYOvaphnwBsH2d7J79d65flEIrW282rXhj9B4ZXsd6faO1O1O69pd9nXr+4jbtRxzwddH/HHpinsrEgwsu6add+SY/zminQcaDCl8jbQxqtLpdNoNSSIwCCeZOhQPINcCIvSMVKoN3L1uHtivcozvIkftIjADUZ3E1I068lfPJKXkQU8TSJurKpIdE5A+1dyidS4nzC055/YF+ZDlSQkHy3acZAJR+kLyWyaQROfFmAm67Xn1110MbySCDukK+01EMptcKv3HDtsquo3+s6mV28roHmk7e03093HnKHidF9snU9kiTES9/B1sAJbFj+yaZiPTLgr9O5M1DcxNEELk6JDJiyZ/MfbORQ9/BQ9HikzNpgmuNOEPxRZEkaFcb6w7UlgSYizMR5GdJ1ncD5O5FBI35uskFJXLwjLJhOGS/6vb8/bH3YMBrFLXMtW9QYFNZAAESnfchOL0/wCdAlEP6ihKkQmzR2r4z6h380bg51+MOM48qUyINae4PI+B+xFdkOUZ54RR76pJgwlbmxL2IVa7nKJ5GfcB/6M95HdvCe3pus7gxta1MTHnSM54dIGe65GAPKH9UIv8w6ua5pcKitLFRipkZSJQHl3eyoQmG8qfX7eKeqf6OqE/lzU0V+6DgYT3FJhrgsESQ+Q5IIFtqJ3qy4qfg4FlaW3RoO2IdxwxAD08q6pCQvBev18CoFul4Mj0St6NZ3ruaznSrLPjEiED7u0y8zqNJEjdL/RjMscnnUGoi3YdtxmLfeX7zjFmtvM+mvJSG6smn21PEtIg4VT7DDIXjrZ1XLTjJbuehzJvir1L27NJydBpblM1SO9GYkaiLFnGcg1o+wrPYCS2iokzMnhiEVKP/J5e05RKTpHUb6MdjRI2mXkB0top1WovtNU8t4iPXLiNgxSqphTkcODsyim+j/Jmspup1TihACgd+IzY5PGp1GUX4JxE7BmB25MPCwyfYRID7gx1doHZaaeSrNVUQGH3XA1UpzQ0U7uPVMrhzln/9vMoqnxD2/dz0/DGh1aXVXDPI6Q6zwztLjlZYQLTHcU2iLl1GwnA7kRCQ5AQtl5Mt2Nwh19a/iwYnpdCdxyo/5jFTh4eqc9OhCk9U060wEljzYo2vE/oKQe1imm13BsI9dBBcOcfWRLjraaRd7s20gnj6YrnfvizUSklHLcIpeX10MejQvLWxHM+J5vzag3OKpIOVHm9pVosf8Ob7+Q2FXhq+pStruwVmt/MrgGLP+jt89bA2NppKMAl8qTqzi0zDl1ucRXszVUpbi7cFxyU/qmWUW2inHCQYhN0/EiYaTEwLOLXrRebE0yi1oSrRn5uqYzP+g2nMg9g6xZyomwG3KSPbB7gDSJsq1ZFB48o1yDk4mFnzPVmg0hwDCNBFW9OYXh8bZjMbccUCpQLme0pgzJlpkUMBavFSAMu+Mhd924H8sNH7eXOarEPLE8OXO7fWJ+x47X9PL8msoQMdvhhV8lKXLQ6jsRUUMb4qL0wbNDruRgbCGbuRO/gaPF4yXNouQr+AuWkSaU6LETTEN25A00IbZp7+espfNVDppocYorMFJ6SehOgkpfsL4nPIXSPg+imstHahM90DH+riF8SlvWupiFZ9lU/2ekcJUvTEtAfXzNZOqyksNd7rPgAC6/mFsUinarQrmhUGyIv4QcxvdUD1Hs7X6J5FwAjyXjNSHseFdRmBzExnlWFyuDltYDc0mbv1SEaLI9EsEl4UqY1lKU1oUHmE9nP2qoFl8mhoBU43MIVEVxSukz8O2U1kmGFcH8k26J/Cj4B3sfItVRH0fAM+16FNBaveutygJWI5APQOSKpsTWgC/DHrdrbAQcfUG1Vx3tmnLVDuSFvtWnCDH1l5Gp1ScsA2VHox13bTBDlZMRoqjY40e7lkPQijPhsD94lHW3vNxhZp/Zln7adFXQOXwyHZpz0RB/Kka3D2vtnsGXhxdaHgKgeRCM5k6yRHi4mu2dy/kYWhFd20bTG1ecAd0rYNSM8Ds76cCxXYf7vSWigSCNjo4uROMk5vPXwsXWdqKShXtVS+FNEnCRKWkdqEvAopaX58pFs/yg0VvmD8Bz+95rkuyB5Ogxs4UOpiGQtyX+DFiJzJHvJ64qbKX1YXAe8q3/akc6RNO3GAKGTQ8Hj08dEW5U69aY2pvgOylTToqKJByCQ8rUDXy6PHAjpqzV8rgEZ3YSFgcFDzyB/rrgA/sTwrsP21lMaA+uv9G4cb6Lek67V5h7/60Bct0iwJZc/i59e/dqlEPMYTomnpufMfbFX7Zsjp3vdLv5HhN7qnIwQlikTSUJ+E+w+BkhSywovxbrRMhJB5sGS3gk4g0wOC/bqnj67rr8DuGqI2YYn0dGk75GTPt0Qu8hl7vrcACRGY0YkZoYAZQyVm8vTzgs1VIuDp2i8hhGPrRx+6zXddw5ZFOSyTBipkUck/xYXpLi/KzOuiycEKrGW1M8GH5FC7qV2onrOHkjtBw8UfDi1YuEhuw38+gbKRxaRaGOCvMPVgeydk3ka+WctJxnpUN2QpkkX1gmu7qApdWP2r12/N1PiwU/8DjqwalOMfpXhOnEyM6tZYD2iIw5zsD9BUCCyx84yINCizjJ05u4lMmEVZzw+NK/EhBpAwQRFSaZd2d5AuKgJwOdZNVxRphPq55c0GRlwGSzDvZQrwFS3sj/z2KU6uOtghgbMursftU3RA7r4aqKDIfZVuhN1+zadGR/h7SH8RoOxA5xzoBgPy8uSF9Ia+mtMjWkTGPaFlmfYLIzcNq8DOtzdFZz/qe5BHfCWYhWW3f4z4hs6nTGegdTSi/Ub5BWRvfgROJ1DbIfItGxfd/nP9j0437EG6kMy9i7VMYic4XBE92z4Gw5qqZeYkeyN/Vp2fETFiILaUKa1VkZ4XVuMY9FbZOBmPiwam/Zg6gHwsRPKag3GmlwoGXeWOFJxyOvC7CLbcVcEuH/R6vnhyKYIuslPhr9HtFIw13MTwX4ofPl6WJoz6nXu1iW1sdGMyY98zlvjTEBV+ibfm3U8nJbrun1XuCcAa55C/x8wMcbsvAv4dMCS42EXOLla/7K9RRslrPl3kYCkMCpl0VyG+v99LU1dm43L+eVli7dAbI7J5AGAXu69dNRbZZNWPTtp/CjajIkZImhv2mhCoHEaER6nBzMkJmn0nwHEaOjEkc42b/zY+nzNyI636C1IYuEQj8Sx8huUOcQz+OATvQ+Def9Nx2Z1pDW4DPe62daOJT6MKWUg1oYw3TZWFPb19zwY0XtR3MwvnzAlJ4i7WPBcOJlYzrCUcNEdcY0ycAdEwzNRJBr27aJeALF6/zJGk8mw12/WZMy19xJcFKnKlU1+bT1JWuHBx2AkVosRXwc9go4ySYEPUW8RqFX4zqoe/4KTSsEuTLnGMcwO/EM1ZEWDm5ORRj0R2SLCF3NGTJbgY72y/INbZyEd0P8o8qJDUnOLt8dsJAws2f/dkLe1OrD7tgAPQlVgGJbqREJqZboRRbIB1hk6/m3fmm0u+8eXDEgAysQxcgBBjdMCPrvu7RX0AVyCHYpPB/8Nd6MO6Oa1fEgHNbxiwQ2jXdnvm2wDqzIP2Bfuia2kyXcRYb90rRYMSbokgqWhrV4uu2DhV/my+4F7p5iQyAzXeaqhVrCCgP+VTBkitrItcdVdUJt1jlpPEC8Y5iRtRzyVK2dxPUAs9R35sO6oy1QirgPz7SN2ft7n80UbzY55sXLIgTtz9YiZEpaOXp58ASB7ysjCUqdwlL18n6NV7lzn34NLM5S2vPVl/9whNMMqCxkD46ZQxW/yO61wMG6ykZellKrJT8ik1cSe3iwKnXGekaHD1CP7qV/r/6LuTq1+JTBPr0JdFFD3mJQzmcSpDEicuWUGHGxp2o3NQBfBvIOOxEerEyAG0ZUTUoCsJOZieodtidR6J2TWLbzfjwcri4Ef/6uh9QIX4S6pbx8w8Ek/Jm/w40a15CWMsudgqk/qdyOMjdKb0p0nhUSgG2LcEKtUkwrgcZ2H3SL/CX58+rynqe8d3MT0I1rAnS2hDhXKyxyqA8KVs2UQqGCjzy2SjSmEnYjcXGKg0uwo9idmjULjiUc2e246kiJrwMLs986zeRWkfUsrp0M6qa/8wZJW7f842fcCKjcpw1SQPxK0XYTMkbTxMwtP9qDKnyUuQgQy0sEwP+PSPEBlPMJq1CASZnWYJtLXlkQcQMc82kpypC6SUzn4j6+9u3nLgiRyakt6TnbaRvZaP34KJQdBatEL6BmymXYB7rUmTNO5iZkFboxfY2ydXws1YulQmteutrCLGI1C2IqbAdZBQBYVEc4Kp4thvd5YLvi1LEl3A++8RBkCPA+3ol2R+O3ub+B0M4a72Y1KAgjny/WuEGno4qZU8GqYNZUduf1HS+nFWNI290vbuo8ldazqQdUswA6/4XnqElL1jLe4A5QgoGGLn0oSw/Fylz0wL9A6AuYXd0voCH2r6mvrk+GwK5o+mSAtonLTN3Ph8h6xdEyWAmGqTWnETDVvayQTbNJaXo3Ykq18DyMBh9i3C7DjPj6ZiK++T8jNqaHUxpXM05s3UnB4xwT5XGzTxk/wVHMFBe8qEcHfqrWCWyPVygrsqJB2Dm+k4rQH8ZOObr4gg2ZxxmQrpGOnVxZSrvYOwmax1pOpKxJzxg7nD+iDKlQ0AQIZSW8+GyUYHwqr4QxnuqNKsJ+mp/+tiNDd6jQHuh0NQg5i4Q4bA+HFGF6yyeo9qmpIF5rX3iDs/ivLgqwmFFDaX8Ncc18higmlpsPmYAFqBFRrzlvqihbdNpzdqqxWTbJQzkh1BJDpcQnoKtV4fQ8XVovR9OrOqNHkoyQQfWJDkz3WhnD5cido8RZRgdV/iKp4Wfo99oQrsoQptVCpSmsFoiC/TEfufyfjaxxqeRKXqVzBM7MOtiBEgxeOPAkKwZbrb5S/PNPZkjbua6wHKMsZsAJKzbEd2sKaZawmYxsih5nytvAFTcKmBl9gFe+vi6n6dXaNyp4AfHWzckzxZN9lllQsypU5UVQ9dTqUTz3GaHFJoh5W+hbjpuY3Kc4W0F7ZHSq7oU4/9sRkjIgFBWu0CoDuDLpViXgI61tXPGbnwwoLIY8s1f47y1/lifNEVyKBfRsiTnHDuIYVi/h+EGkjqO1qeCPl8hRlldqk8ReAGhgB

The user wants to replace the `_` function with a general blend function that:
1. Blends prev with prev-1 (the image before prev in the history)
2. Takes a single argument that selects the blend mode
3. Should include standard blend modes like xor, nand, luminosity, and others

Let me look at the current `_` definition:

```typescript
'_': {
    color: '#FF7F50',
    number: 63,
    fn: fnUnderscore,
    arity: 1,
    argTypes: ['index'],
    functionName: "blur-luminosity",
    documentation: "Luminosity blend: colors from heavily blurred old image, luminance/structure from prev"
  },
```

And `fnUnderscore` is a complex WebGL-based function that does blur + luminosity blend.

I need to create a new function that:
1. Gets prev and prev-1 from the context
2. Takes an int argument to select blend mode
3. Implements many blend modes

Looking at existing blend mode implementations in the code (like in `fnBackslash` and `fnSlash`), there's already a pattern:

```typescript
const blendFuncs: ((b: number, t: number) => number)[] = [
    // 0: Normal - replace
    (b, t) => t,
    // 1: XOR
    (b, t) => b ^ t,
    // 2: NAND
    (b, t) => 255 - (b & t),
    // 3: AND
    (b, t) => b & t,
    // 4: OR
    (b, t) => b | t,
    // 5: Multiply
    (b, t) => (b * t) / 255,
    // 6: Screen
    (b, t) => 255 - ((255 - b) * (255 - t)) / 255,
    // 7: Overlay
    (b, t) => b < 128 ? (2 * b * t) / 255 : 255 - (2 * (255 - b) * (255 - t)) / 255,
    // 8: Darken
    (b, t) => Math.min(b, t),
    // 9: Lighten
    (b, t) => Math.max(b, t),
    // 10: Difference
    (b, t) => Math.abs(b - t),
    // 11: Exclusion
    (b, t) => b

I see a comprehensive set of blend modes covering various pixel-level blending techniques. The array includes standard operations like XOR, NAND, AND, and more complex blending methods like overlay, screen, and difference. Each function takes two pixel values and applies a specific blending algorithm, returning a transformed pixel value.

I want to expand this collection to incorporate more advanced blending techniques, particularly those involving color space transformations like luminosity blending. This will require implementing color space conversions, potentially using HSL or similar color models to extract and manipulate luminance information.

The next phase involves designing functions that can handle color space transitions and implement more nuanced blending algorithms that preserve color characteristics while allowing precise luminosity adjustments.

I'll develop a comprehensive blend mode strategy that covers standard image compositing techniques, bitwise operations, arithmetic manipulations, and sophisticated color space transformations. The goal is to create a flexible, performant blending system that supports complex visual composition strategies.

The implementation involves iterating through pixel coordinates, extracting color channels from source images, and applying sophisticated blending algorithms across multiple computational domains. By using modular arithmetic for mode selection, the function ensures robust handling of blend mode inputs while supporting an extensive range of visual mixing techniques.

The core approach involves nested pixel-level iteration, extracting base and top layer color information, and dynamically applying the selected blend mode's specific transformation logic to generate the output image's pixel values.<$code-close/>

# ASSISTANT

I'll replace the `_` function with a comprehensive blend function. Let me first look at the current implementation to understand what to replace:

# TOOL USE

Name: ripgrep
ID: toolu_01EK4JWj1zMx4rqtENBfkRHf

## pattern

<tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>
function fnUnderscore
</tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>

## context-lines

<tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>
3
</tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>

# TOOL RESULT

ID: toolu_01EK4JWj1zMx4rqtENBfkRHf

<tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>
/Users/ajansson/projects/ascii-language/ascii-language.greger-4822-  return out;
/Users/ajansson/projects/ascii-language/ascii-language.greger-4823-}
/Users/ajansson/projects/ascii-language/ascii-language.greger-4824-
/Users/ajansson/projects/ascii-language/ascii-language.greger:4825:function fnUnderscore(ctx: FnContext, old: Image): Image {
/Users/ajansson/projects/ascii-language/ascii-language.greger-4826-  const prev = getPrevImage(ctx);
/Users/ajansson/projects/ascii-language/ascii-language.greger-4827-  const gl = initWebGL(ctx.width, ctx.height);
/Users/ajansson/projects/ascii-language/ascii-language.greger-4828-  
--
/Users/ajansson/projects/ascii-language/character-defs.ts-4292-  return out;
/Users/ajansson/projects/ascii-language/character-defs.ts-4293-}
/Users/ajansson/projects/ascii-language/character-defs.ts-4294-
/Users/ajansson/projects/ascii-language/character-defs.ts:4295:function fnUnderscore(ctx: FnContext, old: Image): Image {
/Users/ajansson/projects/ascii-language/character-defs.ts-4296-  const prev = getPrevImage(ctx);
/Users/ajansson/projects/ascii-language/character-defs.ts-4297-  const gl = initWebGL(ctx.width, ctx.height);
/Users/ajansson/projects/ascii-language/character-defs.ts-4298-  

</tool.toolu_01EK4JWj1zMx4rqtENBfkRHf>

# TOOL USE

Name: read-file
ID: toolu_01S7hzKBgVHnt5Bo4rdxH8KK

## path

<tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>
character-defs.ts
</tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>

## start-line

<tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>
4295
</tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>

## end-line

<tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>
4400
</tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>

# TOOL RESULT

ID: toolu_01S7hzKBgVHnt5Bo4rdxH8KK

<tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>
function fnUnderscore(ctx: FnContext, old: Image): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const blurShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDirection;
    uniform vec2 uResolution;
    varying vec2 vUV;
    
    void main() {
      vec2 texelSize = 1.0 / uResolution;
      vec3 result = vec3(0.0);
      
      float weights[5];
      weights[0] = 0.227027;
      weights[1] = 0.1945946;
      weights[2] = 0.1216216;
      weights[3] = 0.054054;
      weights[4] = 0.016216;
      
      result += texture2D(uTexture, vUV).rgb * weights[0];
      for (int i = 1; i < 5; i++) {
        vec2 offset = uDirection * texelSize * float(i) * 5.0;
        result += texture2D(uTexture, vUV + offset).rgb * weights[i];
        result += texture2D(uTexture, vUV - offset).rgb * weights[i];
      }
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const luminosityShader = `
    precision highp float;
    uniform sampler2D uPrev;
    uniform sampler2D uBlurred;
    varying vec2 vUV;
    
    void main() {
      vec2 flippedUV = vec2(vUV.x, 1.0 - vUV.y);
      vec3 prevColor = texture2D(uPrev, flippedUV).rgb;
      vec3 blurColor = texture2D(uBlurred, vUV).rgb;
      
      float prevLum = dot(prevColor, vec3(0.299, 0.587, 0.114));
      float blurLum = dot(blurColor, vec3(0.299, 0.587, 0.114));
      
      float scale = blurLum > 0.001 ? prevLum / blurLum : 1.0;
      vec3 result = clamp(blurColor * scale, 0.0, 1.0);
      
      gl_FragColor = vec4(result, 1.0);
    }
  `;
  
  const blurProgram = createShaderProgram(gl, vertexShader, blurShader);
  const luminosityProgram = createShaderProgram(gl, vertexShader, luminosityShader);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const oldTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const prevTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const tempTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const blurredTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const framebuffer = gl.createFramebuffer();
  
  gl.useProgram(blurProgram);
</tool.toolu_01S7hzKBgVHnt5Bo4rdxH8KK>

# ASSISTANT

Let me see where the function ends:

# TOOL USE

Name: read-file
ID: toolu_013oHyn6SXkwiQnVAWGaRMgV

## path

<tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>
character-defs.ts
</tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>

## start-line

<tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>
4400
</tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>

## end-line

<tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>
4480
</tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>

# TOOL RESULT

ID: toolu_013oHyn6SXkwiQnVAWGaRMgV

<tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>
  gl.useProgram(blurProgram);
  const blurPosLoc = gl.getAttribLocation(blurProgram, 'position');
  gl.enableVertexAttribArray(blurPosLoc);
  gl.vertexAttribPointer(blurPosLoc, 2, gl.FLOAT, false, 0, 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uResolution'), ctx.width, ctx.height);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
  gl.uniform1i(gl.getUniformLocation(blurProgram, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 1.0, 0.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, blurredTexture, 0);
  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 0.0, 1.0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, ctx.width, ctx.height);
  
  gl.useProgram(luminosityProgram);
  const lumPosLoc = gl.getAttribLocation(luminosityProgram, 'position');
  gl.enableVertexAttribArray(lumPosLoc);
  gl.vertexAttribPointer(lumPosLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uPrev'), 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uBlurred'), 1);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(oldTexture);
  gl.deleteTexture(prevTexture);
  gl.deleteTexture(tempTexture);
  gl.deleteTexture(blurredTexture);
  gl.deleteFramebuffer(framebuffer);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(blurProgram);
  gl.deleteProgram(luminosityProgram);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnBacktick(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const { width, height } = ctx;
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  const gradX = new Float32Array(width * height);
  const gradY = new Float32Array(width * height);
  const gradMag = new Float32Array(width * height);
  
  let maxMag = 1;
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
</tool.toolu_013oHyn6SXkwiQnVAWGaRMgV>

# ASSISTANT

Now let me find the `_` definition in characterDefs:

# TOOL USE

Name: ripgrep
ID: toolu_01HcNkr4aE5BNKjaWVUyDj4Q

## pattern

<tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>
"_":
</tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>

## context-lines

<tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>
8
</tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>

# TOOL RESULT

ID: toolu_01HcNkr4aE5BNKjaWVUyDj4Q

<tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>
No matches found
</tool.toolu_01HcNkr4aE5BNKjaWVUyDj4Q>

# TOOL USE

Name: ripgrep
ID: toolu_01CdwK9ss6D9fsDivt7nJijp

## pattern

<tool.toolu_01CdwK9ss6D9fsDivt7nJijp>
'_':
</tool.toolu_01CdwK9ss6D9fsDivt7nJijp>

## context-lines

<tool.toolu_01CdwK9ss6D9fsDivt7nJijp>
8
</tool.toolu_01CdwK9ss6D9fsDivt7nJijp>

# TOOL RESULT

ID: toolu_01CdwK9ss6D9fsDivt7nJijp

<tool.toolu_01CdwK9ss6D9fsDivt7nJijp>
/Users/ajansson/projects/ascii-language/ascii-language.greger-6375-    number: 62,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6376-    fn: fnCloseBracket,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6377-    arity: 0,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6378-    argTypes: [],
/Users/ajansson/projects/ascii-language/ascii-language.greger-6379-    functionName: "left-half-offset",
/Users/ajansson/projects/ascii-language/ascii-language.greger-6380-    documentation: "Offsets the left half of the image vertically by 20% with wraparound"
/Users/ajansson/projects/ascii-language/ascii-language.greger-6381-  },
/Users/ajansson/projects/ascii-language/ascii-language.greger-6382-  
/Users/ajansson/projects/ascii-language/ascii-language.greger:6383:  '_': {
/Users/ajansson/projects/ascii-language/ascii-language.greger-6384-    color: '#FF7F50',
/Users/ajansson/projects/ascii-language/ascii-language.greger-6385-    number: 63,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6386-    fn: fnUnderscore,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6387-    arity: 1,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6388-    argTypes: ['index'],
/Users/ajansson/projects/ascii-language/ascii-language.greger-6389-    functionName: "blur-luminosity",
/Users/ajansson/projects/ascii-language/ascii-language.greger-6390-    documentation: "Luminosity blend: colors from heavily blurred old image, luminance/structure from prev"
/Users/ajansson/projects/ascii-language/ascii-language.greger-6391-  },
--
/Users/ajansson/projects/ascii-language/character-defs.ts-5845-    number: 62,
/Users/ajansson/projects/ascii-language/character-defs.ts-5846-    fn: fnCloseBracket,
/Users/ajansson/projects/ascii-language/character-defs.ts-5847-    arity: 0,
/Users/ajansson/projects/ascii-language/character-defs.ts-5848-    argTypes: [],
/Users/ajansson/projects/ascii-language/character-defs.ts-5849-    functionName: "left-half-offset",
/Users/ajansson/projects/ascii-language/character-defs.ts-5850-    documentation: "Offsets the left half of the image vertically by 20% with wraparound"
/Users/ajansson/projects/ascii-language/character-defs.ts-5851-  },
/Users/ajansson/projects/ascii-language/character-defs.ts-5852-  
/Users/ajansson/projects/ascii-language/character-defs.ts:5853:  '_': {
/Users/ajansson/projects/ascii-language/character-defs.ts-5854-    color: '#FF7F50',
/Users/ajansson/projects/ascii-language/character-defs.ts-5855-    number: 63,
/Users/ajansson/projects/ascii-language/character-defs.ts-5856-    fn: fnUnderscore,
/Users/ajansson/projects/ascii-language/character-defs.ts-5857-    arity: 1,
/Users/ajansson/projects/ascii-language/character-defs.ts-5858-    argTypes: ['index'],
/Users/ajansson/projects/ascii-language/character-defs.ts-5859-    functionName: "blur-luminosity",
/Users/ajansson/projects/ascii-language/character-defs.ts-5860-    documentation: "Luminosity blend: colors from heavily blurred old image, luminance/structure from prev"
/Users/ajansson/projects/ascii-language/character-defs.ts-5861-  },

</tool.toolu_01CdwK9ss6D9fsDivt7nJijp>

# ASSISTANT

Now I'll replace the `fnUnderscore` function with a new general blend function and update the character definition:

# TOOL USE

Name: str-replace
ID: toolu_01JDnpAhYC5HjWurPdzB36Hi

## path

<tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>
character-defs.ts
</tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>

## diff

<tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>
-function fnUnderscore(ctx: FnContext, old: Image): Image {
+function fnBlend(ctx: FnContext, mode: number): Image {
   const prev = getPrevImage(ctx);
-  const gl = initWebGL(ctx.width, ctx.height);
+  const prev1 = ctx.images.length >= 2 ? ctx.images[ctx.images.length - 2] : prev;
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const vertexShader = `
-    attribute vec2 position;
-    varying vec2 vUV;
-    void main() {
-      vUV = position * 0.5 + 0.5;
-      gl_Position = vec4(position, 0.0, 1.0);
-    }
-  `;
+  const NUM_MODES = 32;
+  const blendMode = ((mode - 1) % NUM_MODES + NUM_MODES) % NUM_MODES;
   
-  const blurShader = `
-    precision highp float;
-    uniform sampler2D uTexture;
-    uniform vec2 uDirection;
-    uniform vec2 uResolution;
-    varying vec2 vUV;
-    
-    void main() {
-      vec2 texelSize = 1.0 / uResolution;
-      vec3 result = vec3(0.0);
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const [br, bg, bb] = getPixel(prev1, x, y);
+      const [tr, tg, tb] = getPixel(prev, x, y);
       
-      float weights[5];
-      weights[0] = 0.227027;
-      weights[1] = 0.1945946;
-      weights[2] = 0.1216216;
-      weights[3] = 0.054054;
-      weights[4] = 0.016216;
+      let r: number, g: number, b: number;
       
-      result += texture2D(uTexture, vUV).rgb * weights[0];
-      for (int i = 1; i < 5; i++) {
-        vec2 offset = uDirection * texelSize * float(i) * 5.0;
-        result += texture2D(uTexture, vUV + offset).rgb * weights[i];
-        result += texture2D(uTexture, vUV - offset).rgb * weights[i];
+      switch (blendMode) {
+        case 0: // Normal - top replaces base
+          r = tr; g = tg; b = tb;
+          break;
+          
+        case 1: // Multiply
+          r = (br * tr) / 255;
+          g = (bg * tg) / 255;
+          b = (bb * tb) / 255;
+          break;
+          
+        case 2: // Screen
+          r = 255 - ((255 - br) * (255 - tr)) / 255;
+          g = 255 - ((255 - bg) * (255 - tg)) / 255;
+          b = 255 - ((255 - bb) * (255 - tb)) / 255;
+          break;
+          
+        case 3: // Overlay
+          r = br < 128 ? (2 * br * tr) / 255 : 255 - (2 * (255 - br) * (255 - tr)) / 255;
+          g = bg < 128 ? (2 * bg * tg) / 255 : 255 - (2 * (255 - bg) * (255 - tg)) / 255;
+          b = bb < 128 ? (2 * bb * tb) / 255 : 255 - (2 * (255 - bb) * (255 - tb)) / 255;
+          break;
+          
+        case 4: // Darken
+          r = Math.min(br, tr);
+          g = Math.min(bg, tg);
+          b = Math.min(bb, tb);
+          break;
+          
+        case 5: // Lighten
+          r = Math.max(br, tr);
+          g = Math.max(bg, tg);
+          b = Math.max(bb, tb);
+          break;
+          
+        case 6: // Color Dodge
+          r = tr === 255 ? 255 : Math.min(255, (br * 255) / (255 - tr));
+          g = tg === 255 ? 255 : Math.min(255, (bg * 255) / (255 - tg));
+          b = tb === 255 ? 255 : Math.min(255, (bb * 255) / (255 - tb));
+          break;
+          
+        case 7: // Color Burn
+          r = tr === 0 ? 0 : Math.max(0, 255 - ((255 - br) * 255) / tr);
+          g = tg === 0 ? 0 : Math.max(0, 255 - ((255 - bg) * 255) / tg);
+          b = tb === 0 ? 0 : Math.max(0, 255 - ((255 - bb) * 255) / tb);
+          break;
+          
+        case 8: // Hard Light
+          r = tr < 128 ? (2 * br * tr) / 255 : 255 - (2 * (255 - br) * (255 - tr)) / 255;
+          g = tg < 128 ? (2 * bg * tg) / 255 : 255 - (2 * (255 - bg) * (255 - tg)) / 255;
+          b = tb < 128 ? (2 * bb * tb) / 255 : 255 - (2 * (255 - bb) * (255 - tb)) / 255;
+          break;
+          
+        case 9: { // Soft Light
+          const softLight = (b: number, t: number) => {
+            const tb = t / 255, bb = b / 255;
+            return (tb < 0.5 
+              ? bb - (1 - 2 * tb) * bb * (1 - bb) 
+              : bb + (2 * tb - 1) * (bb < 0.25 ? ((16 * bb - 12) * bb + 4) * bb : Math.sqrt(bb) - bb)) * 255;
+          };
+          r = softLight(br, tr);
+          g = softLight(bg, tg);
+          b = softLight(bb, tb);
+          break;
+        }
+          
+        case 10: // Difference
+          r = Math.abs(br - tr);
+          g = Math.abs(bg - tg);
+          b = Math.abs(bb - tb);
+          break;
+          
+        case 11: // Exclusion
+          r = br + tr - (2 * br * tr) / 255;
+          g = bg + tg - (2 * bg * tg) / 255;
+          b = bb + tb - (2 * bb * tb) / 255;
+          break;
+          
+        case 12: // Add
+          r = Math.min(255, br + tr);
+          g = Math.min(255, bg + tg);
+          b = Math.min(255, bb + tb);
+          break;
+          
+        case 13: // Subtract
+          r = Math.max(0, br - tr);
+          g = Math.max(0, bg - tg);
+          b = Math.max(0, bb - tb);
+          break;
+          
+        case 14: // XOR
+          r = br ^ tr;
+          g = bg ^ tg;
+          b = bb ^ tb;
+          break;
+          
+        case 15: // AND
+          r = br & tr;
+          g = bg & tg;
+          b = bb & tb;
+          break;
+          
+        case 16: // OR
+          r = br | tr;
+          g = bg | tg;
+          b = bb | tb;
+          break;
+          
+        case 17: // NAND
+          r = 255 - (br & tr);
+          g = 255 - (bg & tg);
+          b = 255 - (bb & tb);
+          break;
+          
+        case 18: // NOR
+          r = 255 - (br | tr);
+          g = 255 - (bg | tg);
+          b = 255 - (bb | tb);
+          break;
+          
+        case 19: // XNOR
+          r = 255 - (br ^ tr);
+          g = 255 - (bg ^ tg);
+          b = 255 - (bb ^ tb);
+          break;
+          
+        case 20: // Average
+          r = (br + tr) / 2;
+          g = (bg + tg) / 2;
+          b = (bb + tb) / 2;
+          break;
+          
+        case 21: // Divide
+          r = tr === 0 ? 255 : Math.min(255, (br * 255) / tr);
+          g = tg === 0 ? 255 : Math.min(255, (bg * 255) / tg);
+          b = tb === 0 ? 255 : Math.min(255, (bb * 255) / tb);
+          break;
+          
+        case 22: // Grain Extract
+          r = Math.max(0, Math.min(255, br - tr + 128));
+          g = Math.max(0, Math.min(255, bg - tg + 128));
+          b = Math.max(0, Math.min(255, bb - tb + 128));
+          break;
+          
+        case 23: // Grain Merge
+          r = Math.max(0, Math.min(255, br + tr - 128));
+          g = Math.max(0, Math.min(255, bg + tg - 128));
+          b = Math.max(0, Math.min(255, bb + tb - 128));
+          break;
+          
+        case 24: // Vivid Light
+          r = tr < 128 
+            ? (tr === 0 ? 0 : Math.max(0, 255 - ((255 - br) * 255) / (2 * tr)))
+            : (tr === 255 ? 255 : Math.min(255, (br * 255) / (2 * (255 - tr))));
+          g = tg < 128 
+            ? (tg === 0 ? 0 : Math.max(0, 255 - ((255 - bg) * 255) / (2 * tg)))
+            : (tg === 255 ? 255 : Math.min(255, (bg * 255) / (2 * (255 - tg))));
+          b = tb < 128 
+            ? (tb === 0 ? 0 : Math.max(0, 255 - ((255 - bb) * 255) / (2 * tb)))
+            : (tb === 255 ? 255 : Math.min(255, (bb * 255) / (2 * (255 - tb))));
+          break;
+          
+        case 25: // Linear Light
+          r = Math.max(0, Math.min(255, br + 2 * tr - 255));
+          g = Math.max(0, Math.min(255, bg + 2 * tg - 255));
+          b = Math.max(0, Math.min(255, bb + 2 * tb - 255));
+          break;
+          
+        case 26: // Pin Light
+          r = tr < 128 ? Math.min(br, 2 * tr) : Math.max(br, 2 * tr - 255);
+          g = tg < 128 ? Math.min(bg, 2 * tg) : Math.max(bg, 2 * tg - 255);
+          b = tb < 128 ? Math.min(bb, 2 * tb) : Math.max(bb, 2 * tb - 255);
+          break;
+          
+        case 27: // Hard Mix
+          r = br + tr < 255 ? 0 : 255;
+          g = bg + tg < 255 ? 0 : 255;
+          b = bb + tb < 255 ? 0 : 255;
+          break;
+          
+        case 28: { // Hue - hue from top, sat/lum from base
+          const [bh, bs, bl] = rgbToHsl(br, bg, bb);
+          const [th] = rgbToHsl(tr, tg, tb);
+          [r, g, b] = hslToRgb(th, bs, bl);
+          break;
+        }
+          
+        case 29: { // Saturation - sat from top, hue/lum from base
+          const [bh, , bl] = rgbToHsl(br, bg, bb);
+          const [, ts] = rgbToHsl(tr, tg, tb);
+          [r, g, b] = hslToRgb(bh, ts, bl);
+          break;
+        }
+          
+        case 30: { // Color - hue/sat from top, lum from base
+          const [, , bl] = rgbToHsl(br, bg, bb);
+          const [th, ts] = rgbToHsl(tr, tg, tb);
+          [r, g, b] = hslToRgb(th, ts, bl);
+          break;
+        }
+          
+        case 31: { // Luminosity - lum from top, hue/sat from base
+          const [bh, bs] = rgbToHsl(br, bg, bb);
+          const [, , tl] = rgbToHsl(tr, tg, tb);
+          [r, g, b] = hslToRgb(bh, bs, tl);
+          break;
+        }
+          
+        default:
+          r = tr; g = tg; b = tb;
       }
       
-      gl_FragColor = vec4(result, 1.0);
+      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
     }
-  `;
-  
-  const luminosityShader = `
-    precision highp float;
-    uniform sampler2D uPrev;
-    uniform sampler2D uBlurred;
-    varying vec2 vUV;
-    
-    void main() {
-      vec2 flippedUV = vec2(vUV.x, 1.0 - vUV.y);
-      vec3 prevColor = texture2D(uPrev, flippedUV).rgb;
-      vec3 blurColor = texture2D(uBlurred, vUV).rgb;
-      
-      float prevLum = dot(prevColor, vec3(0.299, 0.587, 0.114));
-      float blurLum = dot(blurColor, vec3(0.299, 0.587, 0.114));
-      
-      float scale = blurLum > 0.001 ? prevLum / blurLum : 1.0;
-      vec3 result = clamp(blurColor * scale, 0.0, 1.0);
-      
-      gl_FragColor = vec4(result, 1.0);
-    }
-  `;
-  
-  const blurProgram = createShaderProgram(gl, vertexShader, blurShader);
-  const luminosityProgram = createShaderProgram(gl, vertexShader, luminosityShader);
-  
-  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
-  const buffer = gl.createBuffer();
-  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
-  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
-  
-  const oldTexture = gl.createTexture();
-  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
-  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, old.width, old.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, old.data);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
-  
-  const prevTexture = gl.createTexture();
-  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
-  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
-  
-  const tempTexture = gl.createTexture();
-  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
-  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
-  
-  const blurredTexture = gl.createTexture();
-  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
-  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.width, ctx.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
-  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
-  
-  const framebuffer = gl.createFramebuffer();
-  
-  gl.useProgram(blurProgram);
-  const blurPosLoc = gl.getAttribLocation(blurProgram, 'position');
-  gl.enableVertexAttribArray(blurPosLoc);
-  gl.vertexAttribPointer(blurPosLoc, 2, gl.FLOAT, false, 0, 0);
-  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uResolution'), ctx.width, ctx.height);
-  
-  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
-  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
-  gl.viewport(0, 0, ctx.width, ctx.height);
-  
-  gl.activeTexture(gl.TEXTURE0);
-  gl.bindTexture(gl.TEXTURE_2D, oldTexture);
-  gl.uniform1i(gl.getUniformLocation(blurProgram, 'uTexture'), 0);
-  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 1.0, 0.0);
-  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
-  
-  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, blurredTexture, 0);
-  gl.bindTexture(gl.TEXTURE_2D, tempTexture);
-  gl.uniform2f(gl.getUniformLocation(blurProgram, 'uDirection'), 0.0, 1.0);
-  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
-  
-  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
-  gl.viewport(0, 0, ctx.width, ctx.height);
-  
-  gl.useProgram(luminosityProgram);
-  const lumPosLoc = gl.getAttribLocation(luminosityProgram, 'position');
-  gl.enableVertexAttribArray(lumPosLoc);
-  gl.vertexAttribPointer(lumPosLoc, 2, gl.FLOAT, false, 0, 0);
-  
-  gl.activeTexture(gl.TEXTURE0);
-  gl.bindTexture(gl.TEXTURE_2D, prevTexture);
-  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uPrev'), 0);
-  
-  gl.activeTexture(gl.TEXTURE1);
-  gl.bindTexture(gl.TEXTURE_2D, blurredTexture);
-  gl.uniform1i(gl.getUniformLocation(luminosityProgram, 'uBlurred'), 1);
-  
-  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
-  
-  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
-  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
-  
-  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
-  for (let y = 0; y < ctx.height; y++) {
-    for (let x = 0; x < ctx.width; x++) {
-      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
-      const dstIdx = (y * ctx.width + x) * 4;
-      flipped[dstIdx] = pixels[srcIdx];
-      flipped[dstIdx + 1] = pixels[srcIdx + 1];
-      flipped[dstIdx + 2] = pixels[srcIdx + 2];
-      flipped[dstIdx + 3] = pixels[srcIdx + 3];
-    }
   }
   
-  gl.deleteTexture(oldTexture);
-  gl.deleteTexture(prevTexture);
-  gl.deleteTexture(tempTexture);
-  gl.deleteTexture(blurredTexture);
-  gl.deleteFramebuffer(framebuffer);
-  gl.deleteBuffer(buffer);
-  gl.deleteProgram(blurProgram);
-  gl.deleteProgram(luminosityProgram);
-  
-  return { width: ctx.width, height: ctx.height, data: flipped };
+  return out;
 }
\ No newline at end of file

</tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>

## git-commit-message

<tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>
Replace fnUnderscore with fnBlend - general blend function with 32 modes
</tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>

# TOOL RESULT

ID: toolu_01JDnpAhYC5HjWurPdzB36Hi

<tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Replace fnUnderscore with fnBlend - general blend function with 32 modes
</tool.toolu_01JDnpAhYC5HjWurPdzB36Hi>

# ASSISTANT

Now let's update the character definition for `_`:

# TOOL USE

Name: str-replace
ID: toolu_01Lzisu7a298CQswsxVngBcG

## path

<tool.toolu_01Lzisu7a298CQswsxVngBcG>
character-defs.ts
</tool.toolu_01Lzisu7a298CQswsxVngBcG>

## git-commit-message

<tool.toolu_01Lzisu7a298CQswsxVngBcG>
Update _ character to use fnBlend with int arg for blend mode selection
</tool.toolu_01Lzisu7a298CQswsxVngBcG>

## diff

<tool.toolu_01Lzisu7a298CQswsxVngBcG>
   '_': {
     color: '#FF7F50',
     number: 63,
-    fn: fnUnderscore,
+    fn: fnBlend,
     arity: 1,
-    argTypes: ['index'],
-    functionName: "blur-luminosity",
-    documentation: "Luminosity blend: colors from heavily blurred old image, luminance/structure from prev"
+    argTypes: ['int'],
+    functionName: "blend",
+    documentation: "Blends prev with prev-1 using mode n%32: A=normal, B=multiply, C=screen, D=overlay, E=darken, F=lighten, G=dodge, H=burn, I=hardlight, J=softlight, K=difference, L=exclusion, M=add, N=subtract, O=xor, P=and, Q=or, R=nand, S=nor, T=xnor, U=average, V=divide, W=grain-extract, X=grain-merge, Y=vivid, Z=linear, 0=pin, 1=hardmix, 2=hue, 3=saturation, 4=color, 5=luminosity"
   },
\ No newline at end of file

</tool.toolu_01Lzisu7a298CQswsxVngBcG>

# TOOL RESULT

ID: toolu_01Lzisu7a298CQswsxVngBcG

<tool.toolu_01Lzisu7a298CQswsxVngBcG>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update _ character to use fnBlend with int arg for blend mode selection
</tool.toolu_01Lzisu7a298CQswsxVngBcG>

# ASSISTANT

The `_` function has been replaced with a comprehensive blend function. Here's a summary of the 32 blend modes available:

| Mode | Char | Name |
|------|------|------|
| 0 | A | Normal (top replaces base) |
| 1 | B | Multiply |
| 2 | C | Screen |
| 3 | D | Overlay |
| 4 | E | Darken |
| 5 | F | Lighten |
| 6 | G | Color Dodge |
| 7 | H | Color Burn |
| 8 | I | Hard Light |
| 9 | J | Soft Light |
| 10 | K | Difference |
| 11 | L | Exclusion |
| 12 | M | Add |
| 13 | N | Subtract |
| 14 | O | XOR |
| 15 | P | AND |
| 16 | Q | OR |
| 17 | R | NAND |
| 18 | S | NOR |
| 19 | T | XNOR |
| 20 | U | Average |
| 21 | V | Divide |
| 22 | W | Grain Extract |
| 23 | X | Grain Merge |
| 24 | Y | Vivid Light |
| 25 | Z | Linear Light |
| 26 | 0 | Pin Light |
| 27 | 1 | Hard Mix |
| 28 | 2 | Hue |
| 29 | 3 | Saturation |
| 30 | 4 | Color |
| 31 | 5 | Luminosity |

The function blends `prev` (the current image) with `prev-1` (the image before it in the history). So for example:
- `ABC_K` would create images A, B, C then blend C with B using mode 10 (Difference)
- `ABC_5` would blend C with B using mode 31 (Luminosity)

# USER

don't include Normal, we have that already on #

Also add blend modes that replaces the bottom third lightness pixels, mid third lightness pixels and top third lightness pixels

# THINKING

Signature: EpMHCkYIChgCKkCO9bWN39vUOAbWbsqXdfIkr26MOaM4BFUt5r7FE+/IEMa8XR6FEsH6Y0yVCQ9XYj8uS8drzw4RbxUniWyx8niAEgxHvp6qHF59f+YG8toaDCGahPXxxFCLuaTpcSIw1tPt3CsbFjqxExrIsiCpvaDEI0VARjJFMLRVisjdq1+NfbhhZm1GHKbLcllOHxZ8KvoFqhIYG4BKApfRdvIGNt8Ay15r3pFElJMqZ7qhxHPiBoKYxQXtSPEnGVhcwAThY3ch96sQMDWfY8dLIYZuVRwPAQ/8oYEf5ud3nix1umG2k/iIDPAgVPGgQ+ziZg7UV3MiYgt8K48xky/Ywi4PXvbcaP6aUDlEBLVwI2xLo6/62sL8TM7pEqLe/7YIPgVae7Qmq49JmD4Wef+f1NMgc8F2L9z+UHPHaU/YhoetdAqI1GeUrmN+Ai0GTqqgZfFuvVPS68i/3PPHV8sdxgjCWf5peRAaEmaB27Pwh0fEzLVMnfmiyLn9MjnL1wwNq+krXt/vfUPqfqWPbLz4NTIcemTRsZqeX4MAlQ9qZFy8nmFHGLm54Y0jNg99IEhM4793mvxF30cJaEnn1wGMyVtknke2woyIgGL3Nrxy+CUgmB20Ey4Lvq2RsWwZWEaZOroNwbQx0AApsBAtalehpjZ1XRgH75YdFfEhouTXcsopH7zSkWx8Vyv2Nkd1HUx1/efNz6JFmbCXX4cNcJJS0yC2MQCpuJlBHVFfs67sz7+H9X7uJPQTDs2t7S6TtAvl3BN1ExVOsF+BxDt0P7i3pYirWSxaR/wZ0fPxgMlx1yK74g8K/WN3gKeGvg+YYqCRXzWw3+1xj9nKjm/PDyEvpwZ8RAy+N+Gchybvm2SdlM6a7dJYuoQn3LzoFZfLVnHEC6aRK49lsTS+rihXZikGL88lr8AIJ12UCmy5zK+o2cFNwRgPaqa7Tft19kLiHWwk4UhYUMV5DxxlaSOgUjtoDZ1qN7/Nq1kkaaMu/VHsUW1R0QMizJPcPVUBnUB0GdHDuo+9NYs9uNqUnmGWzM0HaywkR4AJ0WI5aT0svFZIng4bDMyEhTU6L+vtVrpkqtKBrboFVMC4YmNZ2LKL5oexF9vOFtYXoWWTrRMRcaS15cfYP8kUkprMx2FEGQrRAhkvsow7R/Nh6UgCY1rbnrvvs7veY84yfnZC48KWXGZ2FQsxxcYlqKsdn/BNHaWEExj1GAE=

The user wants me to:
1. Remove the "Normal" blend mode (mode 0) since they already have `#` for inserting old images
2. Add three new blend modes that replace pixels based on lightness ranges:
   - Replace bottom third lightness pixels (dark pixels)
   - Replace mid third lightness pixels (mid-tone pixels)
   - Replace top third lightness pixels (light pixels)

So I need to shift all the modes down by 1 (removing normal at index 0) and add these three new modes. That would give us 31 modes total (32 original - 1 normal + 3 lightness-based = 34... wait let me recalculate).

Actually we had 32 modes (0-31). Removing normal gives us 31 modes. Adding 3 new ones gives us 34 modes total.

Let me update the function to have 34 modes instead of 32.

# TOOL USE

Name: str-replace
ID: toolu_015yQbpN3UWmG6oYJCQSf84Z

## path

<tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>
character-defs.ts
</tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>

## git-commit-message

<tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>
Remove normal blend mode, add lightness-based replace modes to fnBlend
</tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>

## diff

<tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>
 function fnBlend(ctx: FnContext, mode: number): Image {
   const prev = getPrevImage(ctx);
   const prev1 = ctx.images.length >= 2 ? ctx.images[ctx.images.length - 2] : prev;
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const NUM_MODES = 32;
+  const NUM_MODES = 34;
   const blendMode = ((mode - 1) % NUM_MODES + NUM_MODES) % NUM_MODES;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
       const [br, bg, bb] = getPixel(prev1, x, y);
       const [tr, tg, tb] = getPixel(prev, x, y);
       
       let r: number, g: number, b: number;
       
       switch (blendMode) {
-        case 0: // Normal - top replaces base
-          r = tr; g = tg; b = tb;
-          break;
-          
-        case 1: // Multiply
\ No newline at end of file
+        case 0: // Multiply
\ No newline at end of file

</tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>

# TOOL RESULT

ID: toolu_015yQbpN3UWmG6oYJCQSf84Z

<tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Remove normal blend mode, add lightness-based replace modes to fnBlend
</tool.toolu_015yQbpN3UWmG6oYJCQSf84Z>

# ASSISTANT

Now let me shift all the remaining case numbers down by 1 and add the new lightness-based modes:

# TOOL USE

Name: str-replace
ID: toolu_018BcFPAaxXQFXn1fkCzxDhb

## path

<tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>
character-defs.ts
</tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>

## git-commit-message

<tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>
Shift blend mode cases down by 1 after removing normal
</tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>

## diff

<tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>
         case 0: // Multiply
           r = (br * tr) / 255;
           g = (bg * tg) / 255;
           b = (bb * tb) / 255;
           break;
           
-        case 2: // Screen
+        case 1: // Screen
           r = 255 - ((255 - br) * (255 - tr)) / 255;
           g = 255 - ((255 - bg) * (255 - tg)) / 255;
           b = 255 - ((255 - bb) * (255 - tb)) / 255;
           break;
           
-        case 3: // Overlay
+        case 2: // Overlay
           r = br < 128 ? (2 * br * tr) / 255 : 255 - (2 * (255 - br) * (255 - tr)) / 255;
           g = bg < 128 ? (2 * bg * tg) / 255 : 255 - (2 * (255 - bg) * (255 - tg)) / 255;
           b = bb < 128 ? (2 * bb * tb) / 255 : 255 - (2 * (255 - bb) * (255 - tb)) / 255;
           break;
           
-        case 4: // Darken
+        case 3: // Darken
           r = Math.min(br, tr);
           g = Math.min(bg, tg);
           b = Math.min(bb, tb);
           break;
           
-        case 5: // Lighten
+        case 4: // Lighten
           r = Math.max(br, tr);
           g = Math.max(bg, tg);
           b = Math.max(bb, tb);
           break;
           
-        case 6: // Color Dodge
+        case 5: // Color Dodge
           r = tr === 255 ? 255 : Math.min(255, (br * 255) / (255 - tr));
           g = tg === 255 ? 255 : Math.min(255, (bg * 255) / (255 - tg));
           b = tb === 255 ? 255 : Math.min(255, (bb * 255) / (255 - tb));
           break;
           
-        case 7: // Color Burn
+        case 6: // Color Burn
           r = tr === 0 ? 0 : Math.max(0, 255 - ((255 - br) * 255) / tr);
           g = tg === 0 ? 0 : Math.max(0, 255 - ((255 - bg) * 255) / tg);
           b = tb === 0 ? 0 : Math.max(0, 255 - ((255 - bb) * 255) / tb);
           break;
           
-        case 8: // Hard Light
+        case 7: // Hard Light
           r = tr < 128 ? (2 * br * tr) / 255 : 255 - (2 * (255 - br) * (255 - tr)) / 255;
           g = tg < 128 ? (2 * bg * tg) / 255 : 255 - (2 * (255 - bg) * (255 - tg)) / 255;
           b = tb < 128 ? (2 * bb * tb) / 255 : 255 - (2 * (255 - bb) * (255 - tb)) / 255;
           break;
           
-        case 9: { // Soft Light
+        case 8: { // Soft Light
           const softLight = (b: number, t: number) => {
             const tb = t / 255, bb = b / 255;
             return (tb < 0.5 
               ? bb - (1 - 2 * tb) * bb * (1 - bb) 
               : bb + (2 * tb - 1) * (bb < 0.25 ? ((16 * bb - 12) * bb + 4) * bb : Math.sqrt(bb) - bb)) * 255;
           };
           r = softLight(br, tr);
           g = softLight(bg, tg);
           b = softLight(bb, tb);
           break;
         }
           
-        case 10: // Difference
+        case 9: // Difference
           r = Math.abs(br - tr);
           g = Math.abs(bg - tg);
           b = Math.abs(bb - tb);
           break;
           
-        case 11: // Exclusion
+        case 10: // Exclusion
           r = br + tr - (2 * br * tr) / 255;
           g = bg + tg - (2 * bg * tg) / 255;
           b = bb + tb - (2 * bb * tb) / 255;
           break;
           
-        case 12: // Add
+        case 11: // Add
           r = Math.min(255, br + tr);
           g = Math.min(255, bg + tg);
           b = Math.min(255, bb + tb);
           break;
           
-        case 13: // Subtract
+        case 12: // Subtract
           r = Math.max(0, br - tr);
           g = Math.max(0, bg - tg);
           b = Math.max(0, bb - tb);
           break;
           
-        case 14: // XOR
+        case 13: // XOR
           r = br ^ tr;
           g = bg ^ tg;
           b = bb ^ tb;
           break;
           
-        case 15: // AND
+        case 14: // AND
           r = br & tr;
           g = bg & tg;
           b = bb & tb;
           break;
           
-        case 16: // OR
+        case 15: // OR
           r = br | tr;
           g = bg | tg;
           b = bb | tb;
           break;
           
-        case 17: // NAND
+        case 16: // NAND
           r = 255 - (br & tr);
           g = 255 - (bg & tg);
           b = 255 - (bb & tb);
           break;
           
-        case 18: // NOR
+        case 17: // NOR
           r = 255 - (br | tr);
           g = 255 - (bg | tg);
           b = 255 - (bb | tb);
           break;
           
-        case 19: // XNOR
+        case 18: // XNOR
           r = 255 - (br ^ tr);
           g = 255 - (bg ^ tg);
           b = 255 - (bb ^ tb);
           break;
           
-        case 20: // Average
+        case 19: // Average
           r = (br + tr) / 2;
           g = (bg + tg) / 2;
           b = (bb + tb) / 2;
           break;
           
-        case 21: // Divide
+        case 20: // Divide
           r = tr === 0 ? 255 : Math.min(255, (br * 255) / tr);
           g = tg === 0 ? 255 : Math.min(255, (bg * 255) / tg);
           b = tb === 0 ? 255 : Math.min(255, (bb * 255) / tb);
           break;
           
-        case 22: // Grain Extract
+        case 21: // Grain Extract
           r = Math.max(0, Math.min(255, br - tr + 128));
           g = Math.max(0, Math.min(255, bg - tg + 128));
           b = Math.max(0, Math.min(255, bb - tb + 128));
           break;
           
-        case 23: // Grain Merge
+        case 22: // Grain Merge
           r = Math.max(0, Math.min(255, br + tr - 128));
           g = Math.max(0, Math.min(255, bg + tg - 128));
           b = Math.max(0, Math.min(255, bb + tb - 128));
           break;
           
-        case 24: // Vivid Light
+        case 23: // Vivid Light
           r = tr < 128 
             ? (tr === 0 ? 0 : Math.max(0, 255 - ((255 - br) * 255) / (2 * tr)))
             : (tr === 255 ? 255 : Math.min(255, (br * 255) / (2 * (255 - tr))));
           g = tg < 128 
             ? (tg === 0 ? 0 : Math.max(0, 255 - ((255 - bg) * 255) / (2 * tg)))
             : (tg === 255 ? 255 : Math.min(255, (bg * 255) / (2 * (255 - tg))));
           b = tb < 128 
             ? (tb === 0 ? 0 : Math.max(0, 255 - ((255 - bb) * 255) / (2 * tb)))
             : (tb === 255 ? 255 : Math.min(255, (bb * 255) / (2 * (255 - tb))));
           break;
           
-        case 25: // Linear Light
+        case 24: // Linear Light
           r = Math.max(0, Math.min(255, br + 2 * tr - 255));
           g = Math.max(0, Math.min(255, bg + 2 * tg - 255));
           b = Math.max(0, Math.min(255, bb + 2 * tb - 255));
           break;
           
-        case 26: // Pin Light
+        case 25: // Pin Light
           r = tr < 128 ? Math.min(br, 2 * tr) : Math.max(br, 2 * tr - 255);
           g = tg < 128 ? Math.min(bg, 2 * tg) : Math.max(bg, 2 * tg - 255);
           b = tb < 128 ? Math.min(bb, 2 * tb) : Math.max(bb, 2 * tb - 255);
           break;
           
-        case 27: // Hard Mix
+        case 26: // Hard Mix
           r = br + tr < 255 ? 0 : 255;
           g = bg + tg < 255 ? 0 : 255;
           b = bb + tb < 255 ? 0 : 255;
           break;
           
-        case 28: { // Hue - hue from top, sat/lum from base
+        case 27: { // Hue - hue from top, sat/lum from base
           const [bh, bs, bl] = rgbToHsl(br, bg, bb);
           const [th] = rgbToHsl(tr, tg, tb);
           [r, g, b] = hslToRgb(th, bs, bl);
           break;
         }
           
-        case 29: { // Saturation - sat from top, hue/lum from base
+        case 28: { // Saturation - sat from top, hue/lum from base
           const [bh, , bl] = rgbToHsl(br, bg, bb);
           const [, ts] = rgbToHsl(tr, tg, tb);
           [r, g, b] = hslToRgb(bh, ts, bl);
           break;
         }
           
-        case 30: { // Color - hue/sat from top, lum from base
+        case 29: { // Color - hue/sat from top, lum from base
           const [, , bl] = rgbToHsl(br, bg, bb);
           const [th, ts] = rgbToHsl(tr, tg, tb);
           [r, g, b] = hslToRgb(th, ts, bl);
           break;
         }
           
-        case 31: { // Luminosity - lum from top, hue/sat from base
+        case 30: { // Luminosity - lum from top, hue/sat from base
           const [bh, bs] = rgbToHsl(br, bg, bb);
           const [, , tl] = rgbToHsl(tr, tg, tb);
           [r, g, b] = hslToRgb(bh, bs, tl);
           break;
+        }
+        
+        case 31: { // Replace Dark Third - replace darkest 33% with prev
+          const [, , bl] = rgbToHsl(br, bg, bb);
+          if (bl < 0.333) {
+            r = tr; g = tg; b = tb;
+          } else {
+            r = br; g = bg; b = bb;
+          }
+          break;
+        }
+        
+        case 32: { // Replace Mid Third - replace middle 33% with prev
+          const [, , bl] = rgbToHsl(br, bg, bb);
+          if (bl >= 0.333 && bl < 0.667) {
+            r = tr; g = tg; b = tb;
+          } else {
+            r = br; g = bg; b = bb;
+          }
+          break;
+        }
+        
+        case 33: { // Replace Light Third - replace lightest 33% with prev
+          const [, , bl] = rgbToHsl(br, bg, bb);
+          if (bl >= 0.667) {
+            r = tr; g = tg; b = tb;
+          } else {
+            r = br; g = bg; b = bb;
+          }
+          break;
         }
\ No newline at end of file

</tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>

# TOOL RESULT

ID: toolu_018BcFPAaxXQFXn1fkCzxDhb

<tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Shift blend mode cases down by 1 after removing normal
</tool.toolu_018BcFPAaxXQFXn1fkCzxDhb>

# ASSISTANT

Now let's update the documentation to reflect the new blend modes:

# TOOL USE

Name: str-replace
ID: toolu_01WuGZT88nPQepKfBtu9bTKe

## path

<tool.toolu_01WuGZT88nPQepKfBtu9bTKe>
character-defs.ts
</tool.toolu_01WuGZT88nPQepKfBtu9bTKe>

## git-commit-message

<tool.toolu_01WuGZT88nPQepKfBtu9bTKe>
Update _ documentation with correct blend mode mappings
</tool.toolu_01WuGZT88nPQepKfBtu9bTKe>

## diff

<tool.toolu_01WuGZT88nPQepKfBtu9bTKe>
   '_': {
     color: '#FF7F50',
     number: 63,
     fn: fnBlend,
     arity: 1,
     argTypes: ['int'],
     functionName: "blend",
-    documentation: "Blends prev with prev-1 using mode n%32: A=normal, B=multiply, C=screen, D=overlay, E=darken, F=lighten, G=dodge, H=burn, I=hardlight, J=softlight, K=difference, L=exclusion, M=add, N=subtract, O=xor, P=and, Q=or, R=nand, S=nor, T=xnor, U=average, V=divide, W=grain-extract, X=grain-merge, Y=vivid, Z=linear, 0=pin, 1=hardmix, 2=hue, 3=saturation, 4=color, 5=luminosity"
+    documentation: "Blends prev with prev-1 using mode n%34: A=multiply, B=screen, C=overlay, D=darken, E=lighten, F=dodge, G=burn, H=hardlight, I=softlight, J=difference, K=exclusion, L=add, M=subtract, N=xor, O=and, P=or, Q=nand, R=nor, S=xnor, T=average, U=divide, V=grain-extract, W=grain-merge, X=vivid, Y=linear, Z=pin, 0=hardmix, 1=hue, 2=saturation, 3=color, 4=luminosity, 5=replace-dark-third, 6=replace-mid-third, 7=replace-light-third"
   },
\ No newline at end of file

</tool.toolu_01WuGZT88nPQepKfBtu9bTKe>

# TOOL RESULT

ID: toolu_01WuGZT88nPQepKfBtu9bTKe

<tool.toolu_01WuGZT88nPQepKfBtu9bTKe>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update _ documentation with correct blend mode mappings
</tool.toolu_01WuGZT88nPQepKfBtu9bTKe>

# ASSISTANT

Perfect! The `_` function has been updated with:

1. **Removed "Normal" mode** - since `#` already provides the functionality to insert old images
2. **Added 3 new lightness-based replace modes** (cases 31-33):
   - **Replace Dark Third** - Replaces the darkest 33% of pixels (by lightness) with pixels from `prev`
   - **Replace Mid Third** - Replaces the middle 33% of pixels with pixels from `prev`
   - **Replace Light Third** - Replaces the brightest 33% of pixels with pixels from `prev`

The function now has 34 total blend modes (0-33). For example:
- `ABC_A` would blend C with B using Multiply
- `ABC_5` would blend C with B using Replace Dark Third (replacing dark pixels from B with those from C)
- `ABC_6` would blend C with B using Replace Mid Third
- `ABC_7` would blend C with B using Replace Light Third

# USER

Add a ?# function that displays multi-column tables of `<image number> <key to access it> <function character and arg characters, e.g. LFD for L with args F and D> <thumbnail of the image at that image number>`

Make it as compact as possible. ALL images must be visible in that one view, so resize text if you need to.

# THINKING

Signature: EtAHCkYIChgCKkD12IeknEc0RClQ3aqBx9EwAseAUSa1a60GaMlavXJbhA0Cy+zBzIdwPCtbMOjb2PFaMods/wu2iF39615kOUNwEgy0UR76lYFlYQF2X4EaDKeG8s3vs4LVwKzTRyIw8O9t2M5ePRIl+52kxJSMgmUp9vqokgvSs/ZeR+AzzWtCrPAuxARZBJVSR4GJiZf8KrcGZcjdp/8r05wnjV9reYqFhDj7uSPGjBdNjBWkwa5M/dTqLZpwThXFMrua0RPhxlBtdjEz12bMqyPEIIXuqT6uEsEx85nmNoK/ebsXpIMXNKz+1okuSaHdsmAzB9eAzJcq/pl9PYkzt1BQAf1e5S76dpbJ1orD4rCJ5Auo50zmH+rl6k9s04iiXmGKwhimSXU0/mxV68iROmQle5V5mvep8aRHyBPbP9vnd6G1BsCtEX9SHXBRppwjB2UgynemQOt5SzrX54vChftvax6orIF/man5LFBMdMvRoB8u73G2jyte8Gdwe78rmqbz5wTNUdf3L4MYQPbsYt0Mu+ggWKghVs8MZViaH2o1itJ+Nv/VrXWhYKwDH4UXG+4AnjIeMcpoNlvWaVAku1+zfp08DjpBfhVPluXpWbrWEHKd+l70r14h4MSD7gvbquaFbu5W9C+L7KZK5VOBScsy69J4/3chTcN4fXPV61LH2/ibiOdY5taGX1eHiKpPpBNR9qY7Bu+mQIwQHaarWJXdD/rSoOmzSYEvAWyOAoeL2xIwHerVmH1K4UV16iyA3itgXdz0Twur4oQpml69BcgSYLRkpnydbekbCIN8R0as3ryc24No3KlAN7mlZygyXLUYgHAftz+8U+0Dn/gTK7kj65aPhKQxJWnnfspf5CeS+AoBgCNW3dQDxEFULSlbIqdbzIWI7x71vkYZZWd4HlPSkuoFAXWPSxbDE3FB2aT3U4b78khGgSXDk+c7JYa2MNO3ismX+hUX+dU/5AqUX9TRKuTi7s22cBrgn9Vi2KSQ/DjyBl2lOgtFDLdeNGbf5P+YPLVPfK4KRWQpLmkilueMC0ZhfhVyfAbc9Q7JB1OoyQGdY1MgIBvcbLBHjMtTI9kUH+n98Amx84zQY8hSZCPELfg1oKksf33w0dod5KAGJZ6GMBf2UXKO0F2iP+0SlDe/pRce5SzliV1GTUHEPZvLomBbz5QelYtVMOIMwRmK0dJEzH8hMgjuNCsUm3K3ZFbbAMtvUgSdcblH2ZpTH5RPczavevEzwQinySTG5isN89m4jU/inuO57RO2ZIMdHmuK3gYq59aKxJDAyMFyQxgB

The user wants a special function `?#` that displays a table showing all images in the history with:
1. Image number
2. Key to access it (A-Z, 0-9, etc based on the number)
3. Function character and args (e.g. "LFD" for L with args F and D)
4. Thumbnail of the image

They want it to be multi-column and compact, with ALL images visible in one view. This means I need to:
- Calculate how many images there are
- Dynamically size the font and thumbnails to fit everything
- Create a multi-column layout
- Show thumbnails using canvas drawing

Let me create a new function that:
1. Takes the context
2. Gets all images from ctx.images
3. Calculates optimal layout (columns, rows, thumbnail size, font size)
4. Draws a table with all this information

I'll need to use canvas operations to draw text and draw thumbnails.

# ASSISTANT

I'll add a `?#` function that displays a compact multi-column table of all images in the history. Let me find where to add this function:

# TOOL USE

Name: ripgrep
ID: toolu_01Q9ud2fKcwLfDwZ4gAqLvdR

## pattern

<tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>
function fnHelp
</tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>

## context-lines

<tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>
3
</tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>

# TOOL RESULT

ID: toolu_01Q9ud2fKcwLfDwZ4gAqLvdR

<tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>
/Users/ajansson/projects/ascii-language/ascii-language.greger-5706-  return lines;
/Users/ajansson/projects/ascii-language/ascii-language.greger-5707-}
/Users/ajansson/projects/ascii-language/ascii-language.greger-5708-
/Users/ajansson/projects/ascii-language/ascii-language.greger:5709:function fnHelp(ctx: FnContext, pageArg: number): Image {
/Users/ajansson/projects/ascii-language/ascii-language.greger-5710-  const out = createSolidImage(ctx.width, ctx.height, '#000000');
/Users/ajansson/projects/ascii-language/ascii-language.greger-5711-  
/Users/ajansson/projects/ascii-language/ascii-language.greger-5712-  const tempCanvas = document.createElement('canvas');
--
/Users/ajansson/projects/ascii-language/character-defs.ts-5265-  return lines;
/Users/ajansson/projects/ascii-language/character-defs.ts-5266-}
/Users/ajansson/projects/ascii-language/character-defs.ts-5267-
/Users/ajansson/projects/ascii-language/character-defs.ts:5268:function fnHelp(ctx: FnContext, pageArg: number): Image {
/Users/ajansson/projects/ascii-language/character-defs.ts-5269-  const out = createSolidImage(ctx.width, ctx.height, '#000000');
/Users/ajansson/projects/ascii-language/character-defs.ts-5270-  
/Users/ajansson/projects/ascii-language/character-defs.ts-5271-  const tempCanvas = document.createElement('canvas');

</tool.toolu_01Q9ud2fKcwLfDwZ4gAqLvdR>

# ASSISTANT

Now I'll add a new function for the image history table right after the help function:

# TOOL USE

Name: str-replace
ID: toolu_01LVfEF3AvEikuJm8cj8ofAk

## path

<tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>
character-defs.ts
</tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>

## git-commit-message

<tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>
Add fnImageHistory function for ?# that displays all images in compact table
</tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>

## diff

<tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>
+function fnImageHistory(ctx: FnContext): Image {
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const tempCanvas = document.createElement('canvas');
+  tempCanvas.width = ctx.width;
+  tempCanvas.height = ctx.height;
+  const tempCtx = tempCanvas.getContext('2d')!;
+  
+  tempCtx.fillStyle = '#000000';
+  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
+  
+  const numImages = ctx.images.length;
+  if (numImages === 0) {
+    tempCtx.fillStyle = '#00FF00';
+    tempCtx.font = '16px monospace';
+    tempCtx.fillText('No images in history', 10, 30);
+    const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
+    out.data.set(imageData.data);
+    return out;
+  }
+  
+  const margin = 5;
+  const availWidth = ctx.width - margin * 2;
+  const availHeight = ctx.height - margin * 2;
+  
+  // Calculate optimal layout
+  let bestLayout = { cols: 1, rows: numImages, thumbSize: 10, fontSize: 6 };
+  let bestScore = 0;
+  
+  for (let cols = 1; cols <= Math.min(8, numImages); cols++) {
+    const rows = Math.ceil(numImages / cols);
+    
+    // Each cell needs: thumbnail + text space
+    const cellWidth = availWidth / cols;
+    const cellHeight = availHeight / rows;
+    
+    // Reserve space for text (3 lines: #, key, func)
+    const textHeight = Math.min(cellHeight * 0.3, 30);
+    const fontSize = Math.max(6, Math.min(12, textHeight / 3));
+    
+    // Thumbnail gets remaining space
+    const thumbSize = Math.min(cellWidth - 10, cellHeight - textHeight - 5);
+    
+    if (thumbSize > 10 && fontSize >= 6) {
+      // Score based on thumbnail size and font readability
+      const score = thumbSize * fontSize;
+      if (score > bestScore) {
+        bestScore = score;
+        bestLayout = { cols, rows, thumbSize, fontSize };
+      }
+    }
+  }
+  
+  const { cols, thumbSize, fontSize } = bestLayout;
+  const cellWidth = availWidth / cols;
+  const cellHeight = availHeight / Math.ceil(numImages / cols);
+  
+  tempCtx.fillStyle = '#00FF00';
+  tempCtx.font = `${fontSize}px monospace`;
+  
+  // Number to character mapping (same as in characterDefs)
+  const numToChar = (num: number): string => {
+    if (num >= 1 && num <= 26) return String.fromCharCode('A'.charCodeAt(0) + num - 1);
+    if (num >= 27 && num <= 36) return String.fromCharCode('0'.charCodeAt(0) + num - 27);
+    const symbols = '<>^!"#$%&\'()*+,-./:;=?@[\\]_`{|}~';
+    const idx = num - 37;
+    if (idx >= 0 && idx < symbols.length) return symbols[idx];
+    return '?';
+  };
+  
+  // Track which ops created which images (reverse lookup from parsing)
+  const ops = getParsedOperations(''); // This won't work, we need the actual program
+  // Instead, we'll show image index and access key
+  
+  for (let i = 0; i < numImages; i++) {
+    const col = i % cols;
+    const row = Math.floor(i / cols);
+    
+    const x = margin + col * cellWidth;
+    const y = margin + row * cellHeight;
+    
+    const img = ctx.images[i];
+    const accessKey = numToChar(i + 1);
+    
+    // Draw thumbnail
+    const thumbX = x + (cellWidth - thumbSize) / 2;
+    const thumbY = y + 5;
+    
+    // Create temp canvas for thumbnail
+    const thumbCanvas = document.createElement('canvas');
+    thumbCanvas.width = thumbSize;
+    thumbCanvas.height = thumbSize;
+    const thumbCtx = thumbCanvas.getContext('2d')!;
+    
+    // Draw image scaled to thumbnail
+    const srcSize = Math.min(img.width, img.height);
+    const srcX = (img.width - srcSize) / 2;
+    const srcY = (img.height - srcSize) / 2;
+    
+    const srcCanvas = document.createElement('canvas');
+    srcCanvas.width = img.width;
+    srcCanvas.height = img.height;
+    const srcCtx = srcCanvas.getContext('2d')!;
+    const srcImageData = new ImageData(img.data, img.width, img.height);
+    srcCtx.putImageData(srcImageData, 0, 0);
+    
+    thumbCtx.drawImage(srcCanvas, srcX, srcY, srcSize, srcSize, 0, 0, thumbSize, thumbSize);
+    
+    // Draw thumbnail border
+    tempCtx.strokeStyle = '#00FF00';
+    tempCtx.lineWidth = 1;
+    tempCtx.strokeRect(thumbX, thumbY, thumbSize, thumbSize);
+    
+    // Draw thumbnail
+    tempCtx.drawImage(thumbCanvas, thumbX, thumbY);
+    
+    // Draw text below thumbnail
+    const textY = thumbY + thumbSize + fontSize + 2;
+    tempCtx.fillStyle = '#00FF00';
+    tempCtx.textAlign = 'center';
+    tempCtx.fillText(`#${i}`, thumbX + thumbSize / 2, textY);
+    tempCtx.fillText(`[${accessKey}]`, thumbX + thumbSize / 2, textY + fontSize + 2);
+  }
+  
+  const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
+  out.data.set(imageData.data);
+  
+  return out;
+}
+
 function fnBacktick(ctx: FnContext, n: number): Image {
\ No newline at end of file

</tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>

# TOOL RESULT

ID: toolu_01LVfEF3AvEikuJm8cj8ofAk

<tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Add fnImageHistory function for ?# that displays all images in compact table
</tool.toolu_01LVfEF3AvEikuJm8cj8ofAk>

# ASSISTANT

Now I need to update the `?` character definition to check if the argument is 42 (the number for `#`) and call the image history function:

# TOOL USE

Name: ripgrep
ID: toolu_01FU8PYXgSRFJCfqq19GqpVq

## pattern

<tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>
'\?':
</tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>

## context-lines

<tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>
8
</tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>

# TOOL RESULT

ID: toolu_01FU8PYXgSRFJCfqq19GqpVq

<tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>
/Users/ajansson/projects/ascii-language/ascii-language.greger-6325-    number: 57,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6326-    fn: fnEquals,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6327-    arity: 1,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6328-    argTypes: ['int'],
/Users/ajansson/projects/ascii-language/ascii-language.greger-6329-    functionName: "shifted-stripes",
/Users/ajansson/projects/ascii-language/ascii-language.greger-6330-    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
/Users/ajansson/projects/ascii-language/ascii-language.greger-6331-  },
/Users/ajansson/projects/ascii-language/ascii-language.greger-6332-  
/Users/ajansson/projects/ascii-language/ascii-language.greger:6333:  '?': {
/Users/ajansson/projects/ascii-language/ascii-language.greger-6334-    color: '#D2691E',
/Users/ajansson/projects/ascii-language/ascii-language.greger-6335-    number: 58,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6336-    fn: fnHelp,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6337-    arity: 1,
/Users/ajansson/projects/ascii-language/ascii-language.greger-6338-    argTypes: ['int'],
/Users/ajansson/projects/ascii-language/ascii-language.greger-6339-    functionName: "help",
/Users/ajansson/projects/ascii-language/ascii-language.greger-6340-    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, invalid pages show index"
/Users/ajansson/projects/ascii-language/ascii-language.greger-6341-  },
--
/Users/ajansson/projects/ascii-language/character-defs.ts-6014-    number: 57,
/Users/ajansson/projects/ascii-language/character-defs.ts-6015-    fn: fnEquals,
/Users/ajansson/projects/ascii-language/character-defs.ts-6016-    arity: 1,
/Users/ajansson/projects/ascii-language/character-defs.ts-6017-    argTypes: ['int'],
/Users/ajansson/projects/ascii-language/character-defs.ts-6018-    functionName: "shifted-stripes",
/Users/ajansson/projects/ascii-language/character-defs.ts-6019-    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
/Users/ajansson/projects/ascii-language/character-defs.ts-6020-  },
/Users/ajansson/projects/ascii-language/character-defs.ts-6021-  
/Users/ajansson/projects/ascii-language/character-defs.ts:6022:  '?': {
/Users/ajansson/projects/ascii-language/character-defs.ts-6023-    color: '#D2691E',
/Users/ajansson/projects/ascii-language/character-defs.ts-6024-    number: 58,
/Users/ajansson/projects/ascii-language/character-defs.ts-6025-    fn: fnHelp,
/Users/ajansson/projects/ascii-language/character-defs.ts-6026-    arity: 1,
/Users/ajansson/projects/ascii-language/character-defs.ts-6027-    argTypes: ['int'],
/Users/ajansson/projects/ascii-language/character-defs.ts-6028-    functionName: "help",
/Users/ajansson/projects/ascii-language/character-defs.ts-6029-    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, invalid pages show index"
/Users/ajansson/projects/ascii-language/character-defs.ts-6030-  },

</tool.toolu_01FU8PYXgSRFJCfqq19GqpVq>

# ASSISTANT

I need to modify the `?` function to check for `#` (which is character 42) and route to the image history function. Let me update `fnHelp`:

# TOOL USE

Name: str-replace
ID: toolu_01Baz66qhyLrLSkmKoDyhuZY

## path

<tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>
character-defs.ts
</tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>

## git-commit-message

<tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>
Update fnHelp to detect ?# and show image history
</tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>

## diff

<tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>
 function fnHelp(ctx: FnContext, pageArg: number): Image {
+  // If pageArg is 42 (the '#' character), show image history
+  if (pageArg === 42) {
+    return fnImageHistory(ctx);
+  }
+  
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const tempCanvas = document.createElement('canvas');
   tempCanvas.width = ctx.width;
   tempCanvas.height = ctx.height;
   const tempCtx = tempCanvas.getContext('2d')!;
   
   tempCtx.fillStyle = '#000000';
   tempCtx.fillRect(0, 0, ctx.width, ctx.height);
   
   const marginFraction = 0.03;
   const margin = Math.max(10, Math.floor(Math.min(ctx.width, ctx.height) * marginFraction));
   
   const baseFontSize = Math.min(ctx.width, ctx.height) * 0.025;
   const fontSize = Math.max(8, Math.min(16, baseFontSize));
   const lineHeight = Math.floor(fontSize * 1.4);
   
   tempCtx.font = `${fontSize}px monospace`;
   tempCtx.fillStyle = '#00FF00';
   
   const charWidth = tempCtx.measureText('M').width;
   const charsPerLine = Math.max(20, Math.floor((ctx.width - margin * 2) / charWidth));
   const linesPerPage = Math.max(5, Math.floor((ctx.height - margin * 2) / lineHeight));
   
   let page: number;
   if (pageArg === 58 || pageArg === 1) {
     page = 1;
   } else {
     page = pageArg;
   }
   
   const pages = generateAllHelpPages(charsPerLine, linesPerPage, characterDefs);
   
   let lines: string[];
   if (page >= 1 && page <= pages.length) {
     lines = pages[page - 1];
   } else {
     lines = generateIndexPage(pages.length);
   }
   
   let y = margin + fontSize;
   for (let i = 0; i < Math.min(lines.length, linesPerPage); i++) {
     tempCtx.fillText(lines[i], margin, y);
     y += lineHeight;
   }
   
   const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
   out.data.set(imageData.data);
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>

# TOOL RESULT

ID: toolu_01Baz66qhyLrLSkmKoDyhuZY

<tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update fnHelp to detect ?# and show image history
</tool.toolu_01Baz66qhyLrLSkmKoDyhuZY>

# ASSISTANT

Now I need to update the documentation for the `?` character to mention `?#`:

# TOOL USE

Name: str-replace
ID: toolu_011n1wyf9RFNwnZe9xyhnZ62

## path

<tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>
character-defs.ts
</tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>

## git-commit-message

<tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>
Update ? documentation to mention ?# for image history
</tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>

## diff

<tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>
   '?': {
     color: '#D2691E',
     number: 58,
     fn: fnHelp,
     arity: 1,
     argTypes: ['int'],
     functionName: "help",
-    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, invalid pages show index"
+    documentation: "Displays help text; ?? or ?A shows intro, ?B/?C/etc show character reference pages, ?# shows image history table with thumbnails, invalid pages show index"
   },
\ No newline at end of file

</tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>

# TOOL RESULT

ID: toolu_011n1wyf9RFNwnZe9xyhnZ62

<tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update ? documentation to mention ?# for image history
</tool.toolu_011n1wyf9RFNwnZe9xyhnZ62>

# ASSISTANT

Now I realize there's an issue - I'm calling `getParsedOperations('')` which won't work. I need to fix the fnImageHistory function to not rely on parsing the program string, since we don't have access to it in the function context. Let me update it to simply show the image number and access key:

# TOOL USE

Name: str-replace
ID: toolu_01LPjgSKerv8BJ8z8CTtbNre

## path

<tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>
character-defs.ts
</tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>

## git-commit-message

<tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>
Simplify fnImageHistory to not depend on program parsing
</tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>

## diff

<tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>
   // Number to character mapping (same as in characterDefs)
   const numToChar = (num: number): string => {
     if (num >= 1 && num <= 26) return String.fromCharCode('A'.charCodeAt(0) + num - 1);
     if (num >= 27 && num <= 36) return String.fromCharCode('0'.charCodeAt(0) + num - 27);
     const symbols = '<>^!"#$%&\'()*+,-./:;=?@[\\]_`{|}~';
     const idx = num - 37;
     if (idx >= 0 && idx < symbols.length) return symbols[idx];
     return '?';
-  };
-  
-  // Track which ops created which images (reverse lookup from parsing)
-  const ops = getParsedOperations(''); // This won't work, we need the actual program
-  // Instead, we'll show image index and access key
\ No newline at end of file
+  };
\ No newline at end of file

</tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>

# TOOL RESULT

ID: toolu_01LPjgSKerv8BJ8z8CTtbNre

<tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Simplify fnImageHistory to not depend on program parsing
</tool.toolu_01LPjgSKerv8BJ8z8CTtbNre>

# ASSISTANT

Perfect! The `?#` function is now implemented. Here's what it does:

1. **Shows all images** from the execution history in a compact multi-column grid
2. **Auto-calculates layout** - determines optimal number of columns, thumbnail size, and font size to fit all images on screen
3. **For each image displays:**
   - A thumbnail of the image
   - The image number (e.g., `#0`, `#1`, `#2`)
   - The access key (e.g., `[A]`, `[B]`, `[C]`) - this is the character you'd use to reference that image

4. **Scales dynamically** - if you have many images, it will make the thumbnails and text smaller to fit everything

For example, if you run a program like `ABCDEFG?#`, it will show a grid with 8 images (including the initial solid color):
- Image #0 (accessed with [A]) - the initial solid color from 'A'
- Image #1 (accessed with [B]) - result after 'B' function
- Image #2 (accessed with [C]) - result after 'C' function
- etc.

This makes it easy to see the entire history of transformations and know which key to use to reference any past image in functions that take an `index` argument (like `#`, `B`, `J`, `L`, etc.).

# USER

under the image, display

#n [C] AAA

where C is the character to access the image, and AAA is the function char and potential arg chars

# THINKING

Signature: EpkdCkYIChgCKkAVfqWwv+4lhv+cqkIlho+iXwUCm6+wIi3vVgI5K3xmURAMlhW3fmzS6o7pamiRJn51dp7x/CXw8IJJSLOrgjyyEgw/8OXG26lBLC4yyisaDOU/iZotUesElnN5HCIwW6zF99nK+c6OeXyiUQgN0MaR/EWe6l+54XgGKx/rUUO224X/EJZ6WJtQc5KpP/3EKoAcNdnXJ/nMjJ51kuavqE34BWFYNRrR9iPxfM6tA0h9AYMA4OQyAtXY2J6EudN/jKoF+LnrydrwaSFbxuHt9nxPc7z5i10ofO7eHA8xKylEU7XZneBaRO8aqmoZ+TwWEbmMxhO9/9oUbezh6m4XcGfzBHIR7YERYfM5iaNgA73/VctOOgPSbYUHEfwU41+LtxionevNb+kydF5JUjsef57LcOAVU73KcC/ariXBz3hFDS7c4SNjkoj0AF62DGOWldyt35Ch8tDV//SDS48mweODiqml/xnPjMlhg1E9B8nkeME8xvCTfM3VLryxnXxPWqKRTMAoyl7X8TNoTH3faS9vHKpuhRVxW9+H5xh9eIqzENRxbwtao5IHBZv4NFM6jO1Q6O6PHwRnVrfdIaFaG4U3QKdUpJLo5MJDIknqaSMgFHwF6ZltindOZfPMKZfqF6Cv6YnUp61aNeRDZdY3cZ3g2VU+mpXdx5K1n+r/C8fywUU2y74tsS2g3SMug58+EF/3M81PD3pcC3P41iTVZGJeiFskOhqFUDJGQMFnbw0rLwAzM4Q3g0no0ef54wClEtfqXvEZHPvua3NSedMbeA5eRh4Bna5MqUNvEnX/s+lyld17J/B+SXLtRJ/14hDQwqbIIxQT02ZR8uhx8ugrXHTNwcqXoLAQ/cB8M+K+1Z2Qy6uCRvRD1lwnCWk1Iu5tsNvHameX50YblBv+E0mqJZMAOxDZ/mmp949vvFP2KyuWQQS+9saZEMqX5Y2MMsMjsEFpF309uH314ClBrpnhjn1SygsHlrK9knjGHLpIaRaqNGe8+KVeXenwtXiB5FOLuzwTeeTTcyQb1MGLy+j72OH731gsXdlB23cDhJyoAIGGc1gx8mJ1zDwwDhB2ECTFyYzDdmuCdTMg/YNEO+vARL7yMxwp8YxI6XG6ON+WH1Hkefcq/Ia/LNtMyBMlp4t6FgJgLe/jLV2cLwTzMTVT3ZO95QHJbODBxA7pWQODxi2threQrFlmwGUZ68cmmrAmL/XfrFYucBaZfNK8oxi51xcrJoYNVmb1J7PvTRDpXSAoHOWzEDMB/neYde7vJ2gxbIBQ3WcDcc+vmoTtvwnSebCBVd2oi9RYf1wJ8y9yeI1smiW7crthCvza8pBfWLcGULGodcn5DK8e1Up1sFrT9qDvOVOfWlcUlOMI74l8RBTBbhewdMPDpd5j2lczJa7VZjyHn6U2UjrttV1KTaRJ4I+aXTAhbYh3f8PDNrqMa4W9Wvoy0NhUNadxrJtMkoxrSZaGfMFndWL2qT/bNnuhHQkmWwYuip9tJTXaLuj5G8zlGbzltSZg7eQGEPYbiyqXRllHoecap4SksMrdOv9Eu1zKc5EZ8M6bQeI0fLOQVpDosuLtI7k9rzzb6En8FwgD1tFI2FINyCvLHzeKj5ram1wnyy3BLc2HqvbFyhWqzmx1y2P4iJ+gnnhAV4GWwkDGtvG+EdB83fU0PVzLF2aj1hkkc8y0TGddEUD3drZ2W3fCu9K75ACYFngbCYK+HLWXbjtiWqnbfzC29uWksSJyZid875KbHPon36mEAs8z4GzurAFokO8mxZ2nzT2qFjF1D2Wf2gfA7FQVo65y8clegGqNJjsqC4rkJx0xP08coQInjGSMQ+M/i8nqtAh6AIfoqcOVI/VgvX4FEpXXQqcGGM4fxRFihT34g5993bvnBa322jt9AkGkbVp/6011wng3+ZnwqeKFAYoHSyAC+WkSmrQJcUOBmvIsTm+3Crxwv86p9Vb7HU3760YyhFDzxm0uVIKRp0/Gd2/Mk2qn9uj5XqTbvCv6wo76IopDO+U/idlpZneQ/QelWfMcH+sBF4rVvp5lm+Aux0FwAt9i4GX8uPkumQJwflaigrLTOFeMFNiinLhO9DwpOEOvqJ9DI/FwAD47TGIlX75BmG/Dr9rQcLZrbmAE8ki+Uaxn3hfW994yW4mOMVNxNYp6/PZukTRnC0vvHFD7PggDHe/y2YH/xggSTyJS5cGJmqshwn750dSkrBnWWrJZNlKc/9EM/eMmGKjGDoLkwwNugFZe1oAfspYCyXaLfYtv9D3oFx00kBI/OXkkjcnj8XkgO8Gk/xlxCydu7eb/7RzzdldzncTmW7emreDYYVAD/4TMO8/6/RWqQ8tFpL/6pQ3nKVACoIvL8bRTB0lqzBwjdSUwuFLPuxL4HEAvivy11C0z46gutfICDw7+TPH521ZVWvrq5OWZwUrij4R2YEnfMtJBjCFKvC+xeDR0mOdjPs6Lg/as5LtpqfkDp54Lj/jfqvNbpKBscp5AOr+qGUgvkFvFaNlreeqRBoYU2kLhBMQm1tkfzgoEgyL6HP/n88T/Sy3g4bY0YqvEnIIc7K7mBndA+HgXMInr5Wb+/mw7LJTidT9FCh/C+Y3AcDwdlUrBRmk2qT0vV32INcZc568u5aeVagxzaU/nl+VOOy9v1nX/DAnTGR5795Em8272TrCGSLptK5lO06eu38auUKvU9AHkcukh5HuqOt0gNlNbxFHDq7kDP5cSeGFFT07chb4D0w8TIjnVRUFi5Rf3Qa4eQilhxPoIbtkGISeZkiL+ox4rbLP4GeYFbuO87cXDuqLf7M93GQ5aFsBMuf0vDlpoW4V7xZBhS1e51byosdRx6oVzvfLjaMGut6ix7o01sEeuhAZkjBW6RgkvZqPJc5VJT/ScOevt3bKBA6hZ6+mP05ejkB2UVk2uN8id4zlTEB8ZomnUKPLCZO5vlErFw+Vp4P0M/Q5UWUbsuaN2XVZaRKVDXB1IT2hYuCXpqsb0jluly421V5sTAuswahhcLzaAzmBjCiGK04wk5ZqikRred81g9Qsc8g/cG/5Vdm5xPS+hT94susVflznzE72qG4BAkYKVgeapRUuwTfxtUKT7zIemsxOhOp0uJvqy/FzNdKKXLP+67j/7358vKm43xmOT11gbkdPdS7d8x92irA+hW6NzIDSHfywz89Z2K8tN8v8OIL8N3bq1l+k7HIBTNKpiQNcPShdhYTSEPlpJ+Yx0xsPPFEyQT2Xg1fYnQlSYWT75LnpbL0IOV+XPK/QjPct6iC1s5k6qz51zJXmK08WLFpRtiQReNHx84+EZtY384XQYa8rT6ncaojCOxgafE+HWqrbbkNh9waGSltXTZoQGn1SVjMOnasAZUabjxRKXkVJIOj8Hjw5+JIHVNFmOUh5bzqueiKItlMSth/PLsU/vGzIYvj9u6KSVyufnzahQyhrgimGXaA0Lyozxnvlte8aqO8eNiRF+5D7EBbySswc3+BonOSQhDYWw2oHBWt+dJJmyA6pn7mqobANrCd4WUBktJt6wNrhsRGBYS7qA8J+vdbjjx/j5pAQCRnLwjnNFOArm0GgKuoujoTDblhOMKPYfODr0n5Zd9pXepT2giFkesYT8HvcQ/srSiAJAyAviXe0sk8M7HXBgQcwC0a8/SBa7eb3sbSo8vJsShJztYInYvgUMgxLJQzlx4EfF0IQ63SKFe28bt2iFtCF4cIbnq8q3Fx4hTTuUNeTZMee542J003N3+gZznXZqGSMYWynEdvqhGh4i+GoBGed7FVLe1dDhSaGqKea5l541gkEEIbvO5Qhyv3P0CV/c8iA3N6R9b69eRHjVCAXY6u3Xu6DA6WC2PBY7id/c/w4v/xysRabXITR5E1Ql9tp6irrB87Y4sAxWR9tAUOJtBIS3caaF59HkGVEBgQVjrHq74PIe1SWeuczBsd5SxIPRBqIs9nrWOHkkfQ2+rq7rpF4H74aiY2glOmb92Wk682w7yBSIm33QpmKt4MvHfRta0CEZLfz+01RsRKIcyfZeFXdDysd+muLwFLn7u1CL5tll6eStT6VoXLA8pQ5NHjgxC5B3dH7pp0CxUgGRFSktPAk6/1csYreg9WTa3kDENnxIBNgLekcmQByqaP/3tBZ5vLTFyET44TRA9DfUeln5jkQGqrj+iqXH9GMwCTIZ5bXfgN6rfJ2NY723CSUv9t82R5SeqfrXRt2gTpmgKuYRS/xER9wKR18My7IZcf4zjo2ZZ3QlM+7lGqTl7krw/1V1wEY9OVG3DJ3MuBkLpeXK0lGhkCEYBC1JlMNobp6DQYZOMZTR4SDlAo4q5xHAUA0xjFdR33HNhZ8bR2eVCwwpYpKPpc/OisoCKmIfcz78KJJKjVuR1FE7A5RGNz3z+r727LOynPphy6HT95hyw/1EVrmF3ZNHdPek5GxLgBmcVjDLR+68k3wDbBtiJzAOughDZXS4r7ssYtU/edUC467rrCNu6ow3KqfCb94hM1lDLGGH3cj3AOHM5L48Xb3niJjIYXo4rxEwTb7CikOoGjvmKlH18BRoChsiCeMscWyu0SLkoXbGr2/v6UJYXVWW2qLv8q0afANSbImGShbkSXWffaHMBGTBr1M+l8aVApdmy2hCACENMbk2mzcsNlJ7xMIIa0kzF7TGBRscjWB63z67UxrcKGUy2xGx8NzL3yxQkU0XDMccUsEbyLzvsjFNuXWnKJeJqsGdWL6bxWX3tsjvC9lBy//YtsBtFmU49xCd0GVC/zahCdJi0czUT/qzDANFfjS8rPTD14Vj7TH4phr8fmoBNo+hsWi4BRuzQVQ2sP6iZPqGSax5TIuhDrzeaug6YV8OLqNmtMs0pNj3wWHdPa/Wj240xS8zqqwgiK526kN7OWJiL+IBr/NHTcJSAnvxu2RYJ/2fTPxF+AnRL36c1IGwF7JaWM4+8wk9JOiosUaf32h1aR/e4pUDD2N9LnkHpPQYAQ==

The user wants to show which function and arguments created each image. To do this, I need to parse the program string and track which operations created which images. But I don't have access to the program string in the function context.

Wait, I need to look at how the runtime works. Let me think about this:

1. The runtime parses the program and creates operations
2. It executes each operation and stores the resulting image
3. The FnContext has `images` array with all images
4. But I need to know which operation created which image

I could add something to the context, or I need to reconstruct this information somehow. Actually, looking at the runtime, it seems like operations are parsed and then images are created. The images array index should correspond to operations.

But actually, I need to pass the program string through somehow. Let me check if there's a way to do this...

Actually, I think the best approach is to add the operation info to the context. Or, I could modify fnImageHistory to take the program string as additional context somehow.

Wait, looking at the runtime code, the `runProgram` function creates the images array. Each op creates one image (except the first which is just a solid color or uploaded image).

Actually, I think I need to modify the approach. Let me look at how the help system works - it seems to have access to characterDefs globally.

I think the solution is:
1. Store operation info alongside images in the context
2. Or, add program parsing info to the context
3. Or, pass the program string through somehow

Actually, I think the easiest solution is to enhance the FnContext to include operation metadata. But that would require changing the runtime.

Wait, let me look at getParsedOperations - it's exported from runtime. So I could potentially make it available somehow...

Actually, looking at the code more carefully, I see that index.html calls runProgram and has access to the program string. But inside the functions, we only have the context.

I think the best solution is to add operation metadata to each image in the FnContext. Let me propose:


Tracking operation details requires a strategic approach. I'll explore adding metadata to the context that captures which operations generated specific images. The challenge is finding a non-invasive method that doesn't require extensive runtime modifications. Storing operation identifiers alongside image data seems promising, but implementation complexity remains a significant consideration.

The runtime's current structure provides an opportunity to potentially inject additional context during image generation. By carefully examining the `runProgram` function, I can see potential insertion points for capturing operation-specific information without disrupting the existing flow.

Expanding the context object to include parsed operations would enable more comprehensive tracking of the program's execution details. This approach could provide richer metadata about the image generation process.

# ASSISTANT

I need to add operation metadata to track which function created each image. Let me first update the FnContext interface to include this information:

# TOOL USE

Name: str-replace
ID: toolu_01Vqx3NvhuThwQVisSWJNq5V

## path

<tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>
character-defs.ts
</tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>

## git-commit-message

<tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>
Add opInfos to FnContext to track which operations created which images
</tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>

## diff

<tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>
+export interface OpInfo {
+  identifier: string;
+  type: 'solid' | 'uploaded-image' | 'function';
+}
+
 export interface FnContext {
   width: number;
   height: number;
   images: Image[];
   currentIndex: number;
+  opInfos: OpInfo[];
 }
\ No newline at end of file

</tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>

# TOOL RESULT

ID: toolu_01Vqx3NvhuThwQVisSWJNq5V

<tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Add opInfos to FnContext to track which operations created which images
</tool.toolu_01Vqx3NvhuThwQVisSWJNq5V>

# ASSISTANT

Now I need to update the runtime to populate opInfos:

# TOOL USE

Name: str-replace
ID: toolu_01DC8pdjUnyVTWZWgMMTiv1k

## path

<tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>
runtime.ts
</tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>

## git-commit-message

<tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>
Update runtime to populate opInfos in context
</tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>

## diff

<tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>
-import { characterDefs, createSolidImage, createPlaceholderImage, getOldImage, Image, FnContext, CharDef, UPLOAD_CHAR } from './character-defs.js';
\ No newline at end of file
+import { characterDefs, createSolidImage, createPlaceholderImage, getOldImage, Image, FnContext, CharDef, UPLOAD_CHAR, OpInfo } from './character-defs.js';
\ No newline at end of file

</tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>

# TOOL RESULT

ID: toolu_01DC8pdjUnyVTWZWgMMTiv1k

<tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>
Successfully replaced content in /Users/ajansson/projects/ascii-language/runtime.ts. Successfully staged 2 file(s) and committed with message: Update runtime to populate opInfos in context
</tool.toolu_01DC8pdjUnyVTWZWgMMTiv1k>

# TOOL USE

Name: str-replace
ID: toolu_011usaT8J38aUGkpWeaRJw6G

## path

<tool.toolu_011usaT8J38aUGkpWeaRJw6G>
runtime.ts
</tool.toolu_011usaT8J38aUGkpWeaRJw6G>

## git-commit-message

<tool.toolu_011usaT8J38aUGkpWeaRJw6G>
Initialize opInfos array and populate it in runProgram
</tool.toolu_011usaT8J38aUGkpWeaRJw6G>

## diff

<tool.toolu_011usaT8J38aUGkpWeaRJw6G>
   const images: Image[] = [createSolidImage(width, height, '#000000')];
+  const opInfos: OpInfo[] = [{ identifier: '', type: 'solid' }];
   let cacheHits = 0;
   let cacheMisses = 0;
   
   for (let opIdx = 0; opIdx < ops.length; opIdx++) {
     const op = ops[opIdx];
     console.log(`\n[Op ${opIdx}] identifier="${op.identifier}"`);
     
     const cached = imageCache.get(op.identifier);
     if (cached) {
       console.log(`  âœ“ CACHE HIT`);
       images.push(cached);
+      opInfos.push({
+        identifier: op.identifier,
+        type: op.type
+      });
       cacheHits++;
       continue;
     }
 
     console.log(`  âœ— CACHE MISS`);
     cacheMisses++;
 
     let result: Image;
     
     if (op.type === 'solid') {
       console.log(`  Creating solid image: ${op.color}`);
       result = createSolidImage(width, height, op.color);
     } else if (op.type === 'uploaded-image') {
       console.log(`  Using uploaded image ${op.uploadIndex}`);
       result = getUploadedImage(op.uploadIndex, width, height);
     } else {
       console.log(`  Executing function: ${op.fnDef.functionName} with args:`, op.args);
       const ctx: FnContext = {
         width,
         height,
         images: [...images],
         currentIndex: images.length,
+        opInfos: [...opInfos],
       };
\ No newline at end of file

</tool.toolu_011usaT8J38aUGkpWeaRJw6G>

# TOOL RESULT

ID: toolu_011usaT8J38aUGkpWeaRJw6G

<tool.toolu_011usaT8J38aUGkpWeaRJw6G>
Successfully replaced content in /Users/ajansson/projects/ascii-language/runtime.ts. Successfully staged 2 file(s) and committed with message: Initialize opInfos array and populate it in runProgram
</tool.toolu_011usaT8J38aUGkpWeaRJw6G>

# TOOL USE

Name: str-replace
ID: toolu_018ViWEhHWahAL8xQFAsCqPy

## path

<tool.toolu_018ViWEhHWahAL8xQFAsCqPy>
runtime.ts
</tool.toolu_018ViWEhHWahAL8xQFAsCqPy>

## git-commit-message

<tool.toolu_018ViWEhHWahAL8xQFAsCqPy>
Push opInfo after creating result image
</tool.toolu_018ViWEhHWahAL8xQFAsCqPy>

## diff

<tool.toolu_018ViWEhHWahAL8xQFAsCqPy>
       result = op.fnDef.fn(ctx, ...resolvedArgs);
     }
     
     images.push(result);
+    opInfos.push({
+      identifier: op.identifier,
+      type: op.type
+    });
     imageCache.set(op.identifier, result);
     console.log(`  âœ“ Cached result for "${op.identifier}"`);
   }
\ No newline at end of file

</tool.toolu_018ViWEhHWahAL8xQFAsCqPy>

# TOOL RESULT

ID: toolu_018ViWEhHWahAL8xQFAsCqPy

<tool.toolu_018ViWEhHWahAL8xQFAsCqPy>
Successfully replaced content in /Users/ajansson/projects/ascii-language/runtime.ts. Successfully staged 2 file(s) and committed with message: Push opInfo after creating result image
</tool.toolu_018ViWEhHWahAL8xQFAsCqPy>

# ASSISTANT

Now let me update the fnImageHistory function to use the opInfos:

# TOOL USE

Name: str-replace
ID: toolu_0192mjnqyqmmoiWQ1W2pei4Q

## path

<tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>
character-defs.ts
</tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>

## git-commit-message

<tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>
Update fnImageHistory to display operation identifiers
</tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>

## diff

<tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>
   for (let i = 0; i < numImages; i++) {
     const col = i % cols;
     const row = Math.floor(i / cols);
     
     const x = margin + col * cellWidth;
     const y = margin + row * cellHeight;
     
     const img = ctx.images[i];
     const accessKey = numToChar(i + 1);
     
+    // Get operation info for this image
+    const opInfo = ctx.opInfos[i];
+    const prevOpIdentifier = i > 0 ? ctx.opInfos[i - 1].identifier : '';
+    const opChars = opInfo.identifier.substring(prevOpIdentifier.length);
+    const displayOp = opChars || (i === 0 ? 'init' : '?');
+    
     // Draw thumbnail
     const thumbX = x + (cellWidth - thumbSize) / 2;
     const thumbY = y + 5;
     
     // Create temp canvas for thumbnail
     const thumbCanvas = document.createElement('canvas');
     thumbCanvas.width = thumbSize;
     thumbCanvas.height = thumbSize;
     const thumbCtx = thumbCanvas.getContext('2d')!;
     
     // Draw image scaled to thumbnail
     const srcSize = Math.min(img.width, img.height);
     const srcX = (img.width - srcSize) / 2;
     const srcY = (img.height - srcSize) / 2;
     
     const srcCanvas = document.createElement('canvas');
     srcCanvas.width = img.width;
     srcCanvas.height = img.height;
     const srcCtx = srcCanvas.getContext('2d')!;
     const srcImageData = new ImageData(img.data, img.width, img.height);
     srcCtx.putImageData(srcImageData, 0, 0);
     
     thumbCtx.drawImage(srcCanvas, srcX, srcY, srcSize, srcSize, 0, 0, thumbSize, thumbSize);
     
     // Draw thumbnail border
     tempCtx.strokeStyle = '#00FF00';
     tempCtx.lineWidth = 1;
     tempCtx.strokeRect(thumbX, thumbY, thumbSize, thumbSize);
     
     // Draw thumbnail
     tempCtx.drawImage(thumbCanvas, thumbX, thumbY);
     
-    // Draw text below thumbnail
+    // Draw text below thumbnail - now 3 lines
     const textY = thumbY + thumbSize + fontSize + 2;
     tempCtx.fillStyle = '#00FF00';
     tempCtx.textAlign = 'center';
-    tempCtx.fillText(`#${i}`, thumbX + thumbSize / 2, textY);
-    tempCtx.fillText(`[${accessKey}]`, thumbX + thumbSize / 2, textY + fontSize + 2);
+    tempCtx.fillText(`#${i} [${accessKey}]`, thumbX + thumbSize / 2, textY);
+    tempCtx.fillText(displayOp, thumbX + thumbSize / 2, textY + fontSize + 2);
   }
\ No newline at end of file

</tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>

# TOOL RESULT

ID: toolu_0192mjnqyqmmoiWQ1W2pei4Q

<tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update fnImageHistory to display operation identifiers
</tool.toolu_0192mjnqyqmmoiWQ1W2pei4Q>

# ASSISTANT

Now I need to adjust the layout calculation to account for the extra line of text:

# USER

no put them on the same line

# THINKING

Signature: EpEDCkYIChgCKkBn1PTvN2ma4zEhwt5i8NFhvLMaYpUdRJ0w8ijYZeTK4FC1+KVFm+1eCD1WkJmfV2YMq5rt56uILkDn5bnfiwPGEgw+WUzahwIBH+K1aGMaDGtOTAAlfq7Vupix8iIwF8aCbAOmzLmj3CTGy/3t0yfsHFh3IYpeXLksvUTOmpTGBCjrnOa+97B8ndnUZUlbKvgBrUd9mN+98kRhL47SBhpD5Br0I4lK0wRf/fVh1kzvNm8tSLPbw8LtD81Tj/7L7cffLtt87rXcJepQ9SAodDHqrVX3aqePNeQfkp0qSlN+4fsa8MBkWDoFyOpUyk1Va3y+dRGmDHNDJrt5+USJsmxcn6tpeWqS7at8o+P/sWCNbtrie9ND7nZJmiZzwSWBBIEdccP3XTODt8nmG57scGpo52Twnp1QXRGc8dNAjzTyUiSmjvVxYisoVSub3S60HPB+byiYrllhEYtDaibdqv4dQNalq5wN6eEa17KxgQ7K3ghwRaSsE+kOPzyFOm+8Z8VGtlV+zJFZ/DoYAQ==

The user wants the three pieces of information on the same line:
- #n [C] AAA

where n is the image number, C is the access key character, and AAA is the operation that created it.

Let me update the code to put them on a single line.

# TOOL USE

Name: str-replace
ID: toolu_016WmvTc5UahQPJcBpZVMsND

## path

<tool.toolu_016WmvTc5UahQPJcBpZVMsND>
character-defs.ts
</tool.toolu_016WmvTc5UahQPJcBpZVMsND>

## git-commit-message

<tool.toolu_016WmvTc5UahQPJcBpZVMsND>
Put image info on single line: #n [C] AAA
</tool.toolu_016WmvTc5UahQPJcBpZVMsND>

## diff

<tool.toolu_016WmvTc5UahQPJcBpZVMsND>
-    // Draw text below thumbnail - now 3 lines
+    // Draw text below thumbnail on single line
     const textY = thumbY + thumbSize + fontSize + 2;
     tempCtx.fillStyle = '#00FF00';
     tempCtx.textAlign = 'center';
-    tempCtx.fillText(`#${i} [${accessKey}]`, thumbX + thumbSize / 2, textY);
-    tempCtx.fillText(displayOp, thumbX + thumbSize / 2, textY + fontSize + 2);
+    tempCtx.fillText(`#${i} [${accessKey}] ${displayOp}`, thumbX + thumbSize / 2, textY);
   }
\ No newline at end of file

</tool.toolu_016WmvTc5UahQPJcBpZVMsND>

# TOOL RESULT

ID: toolu_016WmvTc5UahQPJcBpZVMsND

<tool.toolu_016WmvTc5UahQPJcBpZVMsND>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Put image info on single line: #n [C] AAA
</tool.toolu_016WmvTc5UahQPJcBpZVMsND>

# ASSISTANT

Now let me also adjust the layout calculation since we only need one line of text instead of the original estimate:

# TOOL USE

Name: str-replace
ID: toolu_01FVrfjw8oMSSUJPKxzsWyg4

## path

<tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>
character-defs.ts
</tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>

## git-commit-message

<tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>
Adjust layout calculation for single line of text
</tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>

## diff

<tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>
   for (let cols = 1; cols <= Math.min(8, numImages); cols++) {
     const rows = Math.ceil(numImages / cols);
     
     // Each cell needs: thumbnail + text space
     const cellWidth = availWidth / cols;
     const cellHeight = availHeight / rows;
     
-    // Reserve space for text (3 lines: #, key, func)
-    const textHeight = Math.min(cellHeight * 0.3, 30);
-    const fontSize = Math.max(6, Math.min(12, textHeight / 3));
+    // Reserve space for text (1 line: #n [C] AAA)
+    const textHeight = Math.min(cellHeight * 0.2, 20);
+    const fontSize = Math.max(6, Math.min(12, textHeight));
     
     // Thumbnail gets remaining space
-    const thumbSize = Math.min(cellWidth - 10, cellHeight - textHeight - 5);
+    const thumbSize = Math.min(cellWidth - 10, cellHeight - textHeight - 10);
     
     if (thumbSize > 10 && fontSize >= 6) {
       // Score based on thumbnail size and font readability
       const score = thumbSize * fontSize;
       if (score > bestScore) {
         bestScore = score;
         bestLayout = { cols, rows, thumbSize, fontSize };
       }
     }
   }
\ No newline at end of file

</tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>

# TOOL RESULT

ID: toolu_01FVrfjw8oMSSUJPKxzsWyg4

<tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Adjust layout calculation for single line of text
</tool.toolu_01FVrfjw8oMSSUJPKxzsWyg4>

# ASSISTANT

Perfect! The `?#` function now displays all images in a compact grid with each image showing:

- `#n` - the image number
- `[C]` - the access key character (A, B, C, etc.)
- `AAA` - the operation that created it (e.g., `A` for the initial color, `BC` for function B with arg C, etc.)

All on a single line below each thumbnail. For example:
- `#0 [A] init` - the initial image
- `#1 [B] A` - result of A operation
- `#2 [C] BC` - result of B operation with C as argument
- etc.

# USER

You've got an off by one error in ?#, the init image shouldn't be included since A is the first image (index 1)

# THINKING

Signature: EqIKCkYIChgCKkC+yHs46cypldy1BBacnk8UaLVWkpAz2n7ugJKPbfCPS4wvbWed6LAAzcDCQf1AF+P222cizGrt08sdlHJ5hg84Egyc9zzIdidonvQ+MXUaDN7O/PnWaFoLGpTZfSIwJXjkMWH38X342qDsiq/b6dH5a2BgePe7Nyv7pZWrjnAjw6p4fgfaT7wW2bnz1ALbKokJyvSdLctmtPi2kZ85IM00faw9elf1sdnMXdXtHHNfHzu9cAA5OIV2uYRvawbroE33efyB2/Lyl70zqkDfyKW6KTkYte3IUNWUuv+pkcBjj4wXU4ZlwuVcwDiZCH+a/1Wl+AJQlEZUgIl17kSMdtTkeT9WXl2iMyDfhpOke4u6Mkw+JRrpIiiJM90+w2CMaPlKQUe92biICNAqMYFgvgjN+dkG2PFMmfUwzd2xXdyh9IqvjgGf7+c4sMlvgOqvwGuRR8ivfNgGc7/Bn087guvKXXHoVPOaO1MQ/M5s6xWJQ88NgwwmCOOj+MWUSeNnCcADVk9G/7nxkrjo1zrL7+QUM8FpshKpsx6C5bCpox4uxpL5egsA4pNX+XYpg1BaCro/ruGEKXH9pZdKcePtzQNfyO44xW274r5l8VFxrCvpUpJ3RjwsPIo1ZYWs4SqcbQSm2m9vznsgsNJYv+/J45p7at4ZY1S8SpujHRCj5u7NJYaLf7jsBsm0pAMuGmGhzKzYGqbg9kXh4Kyqiwz3m2Z9S1VFRQREne6YruFChsL6zu49ec6+zEsekB4bPKv6mLRlMdyuL64wyQej+svTerYw2EnqNcYU6tnMwIfMtVvFa1Q4ei1PdQg73IGVIKRT6Py4B2c3q9NpVM+wbNgPa/Lo57t972FRM7JYZTLFc/LDCeeCTrbQBrJ5W/RHu6ljsw+HcXGjvWksVm1f6U5edTFuWZMWwtBOICYNqZYPMFNKZs7LfqbNEygyFbdtUaBzBCzCIYpUCLyKwL0dnPguVhEFpyi2IFyrEzqV1x2mMWwvEOix4xJh8aeVrZn5oewfj21137i6fyYkiOS1M1NKQvPXND9owbHGrhBNn1A4+bz9bml4XwS954fSGl4y9w2KfZ3RMlyjAbNHNNoavnFKCKk6ICd+ptOwXXTfyuMA1l5Rb6ajJ4iPBY/3ClyAXKEhTxENBYTn/iVpS4Oy1NVk0c1QT6BpYYugNQUhLGZ+Aml4A8S1hrQISOQSV8bJRe2ts6JiNviMPAb9E8wHIthIokfLZd9h0rxJwvx/V/1D8J/M8Lda/QkT5ZdKQHe9naLHAtNn6ADUuhUbd1O05I5hDX4P5FMQy7YqpANstiBWXqhqz996v3d6fUCsoRqJV5SfyqItGwBhlzC+68AdLi8XsghMsAbmDeqJqUeAWNvLO9aeTa947u2AzpaV0RNr/Xw3HkBblHpGLhaBQi5R5OPKZPxpDcH8bRKruntvn13V+66nekynAyQhGUqgiEROBPM/AvF+YMT9wGUebA+AyHJBcz8PLErYEQeR0M7fkNodS+kkul//HgMt9cnw/NZOlpgHXjSBTMDMOUaA8QQDUdCG9mfFnfthZoq91OdDbFgoPkVKoag0F7KoUN1X++ynt3smfhJ7oeBXHt0uAFTaq9oS2dI4WtKm281gws8IA57AeCzklJidHy63D0ECDSyqsJ2cFzAFze0sYi+C/pZVu+FXxVCEdTTSqv4EA17YVoYuaQtYbS+hPKQ2JKaXoXuh4uve2TGxtYUfiKNA0CDrGAE=

The user is right - there's an off-by-one error. Looking at the code, the first image in the `images` array is created by `createSolidImage(width, height, '#000000')` which is just a black placeholder, and then the actual operations start creating images. But actually, looking at the parsing logic, the first character in the program creates a solid color image or is a function.

Let me think about this more carefully. In the runtime:
1. `const images: Image[] = [createSolidImage(width, height, '#000000')];` - starts with a black image at index 0
2. Then ops are processed, and each op pushes a new image

So if the program is `ABC`:
- images[0] = black placeholder
- images[1] = solid color from A
- images[2] = result of B
- images[3] = result of C

And the opInfos would be:
- opInfos[0] = { identifier: '', type: 'solid' }
- opInfos[1] = { identifier: 'A', type: 'solid' }
- opInfos[2] = { identifier: 'AB', type: 'function' }
- opInfos[3] = { identifier: 'ABC', type: 'function' }

So when displaying in ?#, we should skip index 0 (the black placeholder) and start from index 1. The user is saying that A should be the first image, not "init".

# ASSISTANT

You're right! The black placeholder at index 0 shouldn't be shown. Let me fix the fnImageHistory function to skip the initial black image:

# TOOL USE

Name: str-replace
ID: toolu_011d8mCucDrby5qKdmamcmQK

## path

<tool.toolu_011d8mCucDrby5qKdmamcmQK>
character-defs.ts
</tool.toolu_011d8mCucDrby5qKdmamcmQK>

## git-commit-message

<tool.toolu_011d8mCucDrby5qKdmamcmQK>
Skip initial black placeholder image in ?# display, start from index 1
</tool.toolu_011d8mCucDrby5qKdmamcmQK>

## diff

<tool.toolu_011d8mCucDrby5qKdmamcmQK>
 function fnImageHistory(ctx: FnContext): Image {
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
   const tempCanvas = document.createElement('canvas');
   tempCanvas.width = ctx.width;
   tempCanvas.height = ctx.height;
   const tempCtx = tempCanvas.getContext('2d')!;
   
   tempCtx.fillStyle = '#000000';
   tempCtx.fillRect(0, 0, ctx.width, ctx.height);
   
-  const numImages = ctx.images.length;
+  // Skip the initial black placeholder at index 0
+  const numImages = ctx.images.length - 1;
   if (numImages === 0) {
     tempCtx.fillStyle = '#00FF00';
     tempCtx.font = '16px monospace';
     tempCtx.fillText('No images in history', 10, 30);
     const imageData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
     out.data.set(imageData.data);
     return out;
   }
\ No newline at end of file

</tool.toolu_011d8mCucDrby5qKdmamcmQK>

# TOOL RESULT

ID: toolu_011d8mCucDrby5qKdmamcmQK

<tool.toolu_011d8mCucDrby5qKdmamcmQK>

</tool.toolu_011d8mCucDrby5qKdmamcmQK>

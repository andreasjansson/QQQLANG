# SYSTEM

You are Greger, and expert coding agent.

${greger-prompt-code-style<eval-result-174115490747>
# Code style

## Don't be overly defensive

I don't trust the code you write, so I want you to fail early and loudly.

**Don't** add fallbacks, guards, or try/catch blocks against errors unless I specifically ask you to. I don't trust the code you write so I'd rather fail hard early and detect your errors than softly receive a fallback and not detect your errors.

## Imports go at the top

Don't sprinkle the code with imports unless in very special circumstances or if I explicltly ask you to.

## No unnecessary comments

You have a tendency to comment every line. I'm an expert programmer and I prefer reading code to prose. Most of the time I can read the code faster than the comment to understand what's going on. Only add comments in cases where the code is unintuitive or particularly hard to follow (e.g. custom parsers).

## Read full files

Important: The first time you read a source code file, read the _entire_ file (_not_ piecemeal with start-line and end-line) so you get a real holistic understanding of the logic.

## IMPORTANT: NO SUMMARY DOCUMENTS!!!

IMPORTANT: DON'T write summary documents (e.g. SUMMARY.md, FINAL_REPORT.md) unless the user explicitly asks you to. If you feel the need to explain something, just do it in the chat. The ONLY exception to this rule is if the user explicitly asks you to write up a markdown file on disk.
</eval-result-174115490747>}

# USER

I want to create an esoteric programming language for generating images, where _every_ combination of uppercase ascii characters (excluding "invisible characters" like space, return) create an image.

Every character have an associated color, integer, and function.

Some functions have arity 0, some are unary, some are binary (some are maybe ternary?). Arguments to functions may be colors or integers. When arity > 0, the default argument are defined in the function, and color values usually default to the color of the character. Each function outputs a 2D RGB image.

A program is a list of characters that outputs a list of images (where the number of images <= number of characters, since some characters may be function arguments)

Functions have access to the entire history of output images up to the point in the program where they're defined. By convention, each function does some transformation on the previous image.

The first character is always used by its color, creating a single color image. Subsequent characters are parsed until the end of the program string. The default arguments are only used if the last function in the program string is missing inputs.

Note that

These are all valid programs: FJID)WIJF, FH)Y*#, I0ASDFJ0IDFSJOJOSF280EFY2HFUDSOH)DFSHFD, 8DFS632&@DSFJFDJSINCSJNIJSHOF, etc.

Implement this as a table in typescript in the following form:

```
// character-defs.ts
const characterDefs = {
  'A': {
    color: '#78A10F',
    number: 7,
    function: (images, a, c) => ..., // a and c are the arguments here. `images` is passed to as the first argument to every function. width and height are implicit from the previous image. images are inputs to every function. images is a list of 3D tensors, and the function returns a 3D tensor
    arity: 2,
    functionName: "short-name",
    documentation: "one sentence about what the function does"
  }
}
```

I have already made index.html, runtime.ts, and parts of character-defs.ts. You just need to implement the rest of character-defs.ts.

These are the functions you should implement (prev is a shorthand for images[-1]):

`! (n: int)`: prev is overlaid with a deterministic hash pattern where pixel (x,y) brightness is ((x * (n+17)) ^ (y * 31) ^ (x * y)) % 256, at 30% opacity
`" (n: int)`: prev is split into n horizontal bands; odd bands are hue-rotated 180°, even bands have their saturation inverted
`# (c: color)`: a grid of lines in color c is drawn over prev where line thickness = 1 + sin(x * y * 0.01) * 3
`$ (n: int)`: golden spiral with n turns is drawn from center outward, spiral color is brightness-inverted sample of prev at each point
`% (n: int)`: Floyd-Steinberg dither prev to a palette derived from its four corner colors, dither cell size = n + 1
`& (j: int)`: `old_image = images[j % (len(images) - 1)]`, output is prev where luminance comes from prev but hue/saturation come from old_image
`' (n: int)`: vertical streaks are drawn at x positions where x % (n + 2) == 0, streak length = luminance of that column's average * 100, streaks are 50% white
`( (n: int)`: pinch distortion toward center with strength n/10, pixels near center are brightened proportional to pinch distance
`) (n: int)`: bulge distortion from center with strength n/10, pixels near edge are darkened proportional to distance from center
`* (n: int)`: n rays emanate from center, each ray's color is sampled from prev at angle * width / n, rays have soft edges and 60% opacity
`+ ()`: a cross divides the image into 4 quadrants; top-left and bottom-right are sharpened, top-right and bottom-left are blurred
`, (c: color)`: stipple prev with dots of color c placed at positions where (x * 13 + y * 7) % (1 + local_luminance / 32) == 0
`- (n: int)`: horizontal scanlines where every nth row is darkened 50%, and every (n*2)th row samples from the row n pixels above
`. (n: int)`: pointillism: prev is rebuilt from circles of radius (n % 8) + 2, color sampled from circle center with +10% saturation
`/ (c: color)`: diagonal lines from top-left to bottom-right in color c, spacing determined by local luminance (bright = sparse, dark = dense)
`0 (n: int)`: a radial gradient from center (white) to edges (black) is multiplied with prev at n*10% opacity, then added back to prev
`1 (n: int)`: a single vertical bar at center (width = n% of image) shows prev sharpened and contrast-boosted, rest is desaturated
`2 (n: int)`: posterize prev to n levels per channel, then add a gradient map from the average color to its complement
`3 ()`: prev is divided into 3 vertical strips; left strip rotated 90° CW, middle unchanged, right strip rotated 90° CCW, all scaled to fit
`4 ()`: prev is divided into 2x2 quadrants, each rotated (0°, 90°, 180°, 270°) respectively, seams blended with 5px feather
`5 (n: int)`: triangular tiling with cell size n*10, each tile's fill is sampled from prev at tile center, edges drawn in inverted colors
`6 (n: int)`: hexagonal pixelation with hex cell radius n*5, each filled with region's average color, edges drawn 1px darker
`7 (n: int)`: n rectangles placed at positions (i * width/(n+2), i * height/(n+4)) for i in 1..n, each filled with prev hue-rotated by i * (360/n)°
`8 (n: int)`: infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along the curve
`9 (n: int)`: apply blend mode n % 9 of prev with itself: [0:multiply, 1:screen, 2:overlay, 3:darken, 4:lighten, 5:color-dodge, 6:color-burn, 7:hard-light, 8:soft-light]
`: (n: int)`: n circular regions evenly spaced horizontally show prev at 2x zoom, rest of image is box-blurred with radius 5
`; ()`: a semicircle arc (top half) crops prev, bottom half is a reflection with wave distortion sin(x * 0.1) * 10
`= (n: int)`: horizontal stripes of height n, even stripes are prev, odd stripes are prev shifted left by stripe_index * 5 pixels
`? ()`: effect selected by (sum of prev's corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]
`@ ()`: using webgl, prev is turned into a sphere placed on top of prev at the top right and bottom left quadrants, with shadows. light comes from the front slightly tilted top left
`A ()`: using webgl, prev is turned into a sphere placed on top of prev at the top right and bottom left quadrants, with shadows. light comes from the front slightly tilted top left
`B (j: int)`: `old_image = images[j % (len(images) - 1)]`, prev is broken into voronoi cells seeded at points (i * 47 % w, i * 89 % h) for i in 0..36, alternating cells show prev vs old_image
`C (n: int)`: n concentric circles from center, each ring alternates between prev and hue-shifted prev (shift += 360/n° per ring)
`D (n: int)`: prev is split into (n + 1)**2 triangles, where each triangle is colorized with a hue that is a function of i
`E (c: color, n: int)`: `n` sinusoidal waves of a thickness and period that's a function of `i` and color `c` are superimposed on `prev_image`, from left to right
`F (n: int)`: a Julia set fractal (max n*10 iterations) using prev's center pixel as c parameter, drawn over prev with screen blend
`G (n: int)`: prev to grayscale, then gradient map applied using n colors extracted from prev's histogram (evenly spaced by luminance)
`H (j: int)`: `old_image = images[j % (len(images) - 1)]`, horizontal strips alternate between prev and old_image, strip height = 5 + sin(y * 0.1) * 20
`I ()`: prev colors are inverted, then Sobel edge detection on original, edges drawn in white over inverted image
`J (j: int)`: `old_image = images[j % (len(images) - 1)]`, old_image revealed behind prev in checkerboard where square height is function of x and y, thin at top left, 100% at bottom right
`K (n: int)`: n-way kaleidoscope (min 2) centered on image, with slight zoom (1.1x) so pattern tiles interestingly
`L (c: color)`: Lichtenberg figures drawn from top to bottom using fixed-seed DLA simulation (max 500 segments), in color c
`M (j: int)`: `old_image = images[j % (len(images) - 1)]`, prev and old_image are interleaved in a spiral pattern from center outward
`N (j: int)`: `old_image = images[j % (len(images) - 1)]`, output is prev XOR old_image
`O (n: int)`: fisheye function, that brightens and darkens as well as morphs
`P (n: int)`: pixelate prev with cell size n+1, each cell split diagonally: top-left = avg color, bottom-right = most saturated color in cell
`Q ()`: prev_image split diagonally, bottom right half color inverted, then tiled in four quadrants
`R ()`: using webgl, image transformed with sinusoidal shape in z dimension, looks corrugated vertically
`S (x: int)`: prev is skewed 45% left, with wraparound
`T (n: int)`: `n` 3D cubes (using webgl) emerge from the image in deterministic but chaotic patterns depending on `n`. Light from top slightly angled right
`U (n: int)`: undulating vertical wave distortion, amplitude = n*5 px, frequency = n cycles, phase shifts based on row luminance
`V (c: color)`: vignette with radius 0.7, darkened edges are also tinted toward color c
`W (n: int)`: swirl distortion from center, rotation amount = n * 45°, falloff is quadratic from center
`X (k: int)`: a shape from lookup table drawn at center at 50% of image size, filled with complement of prev's average color. Shapes indexed by k % 64:
  [0:★ 1:● 2:■ 3:▲ 4:◆ 5:♥ 6:✦ 7:⬡ 8:✚ 9:◐ 10:☽ 11:⚡ 12:∞ 13:☀ 14:✿ 15:⬢
   16:◯ 17:△ 18:□ 19:◇ 20:♦ 21:♣ 22:♠ 23:⬟ 24:⬠ 25:▽ 26:◁ 27:▷ 28:⊕ 29:⊗ 30:⊛ 31:⊚
   32:▣ 33:▤ 34:▥ 35:▦ 36:▧ 37:▨ 38:▩ 39:⬣ 40:⬤ 41:◉ 42:◎ 43:◈ 44:◊ 45:○ 46:◌ 47:◍
   48:◢ 49:◣ 50:◤ 51:◥ 52:♯ 53:♮ 54:♩ 55:♪ 56:✶ 57:✴ 58:✳ 59:✲ 60:✱ 61:✰ 62:✯ 63:✮]
`Y (n: int)`: image split into n radial sections from center; each section i is hue-rotated by i * (360/n)°
`Z (n: int)`: zoom-blur from center (radial motion blur), blur amount = n*4 px, center 20% remains sharp
`[ (j: int)`: `old_image = images[j % (len(images) - 1)]`, left third shows old_image, right two-thirds show prev, torn-paper edge using sin(y*0.3)*20 + sin(y*0.7)*10
`\ (c: color)`: diagonal lines from top-right to bottom-left in color c, spacing = luminance-based
`] (j: int)`: `old_image = images[j % (len(images) - 1)]`, right third shows old_image, left two-thirds show prev, with torn-paper edge
`^ ()`: prev is shifted 1/3 of the height up with wraparound
`_ (n: int)`: bottom n*5% of image is reflected and overlaid with 50% opacity, with horizontal wave distortion sin(x * 0.1) * 5
`` ` (n: int)``: glitch effect: horizontal strips at rows where (y * 17) % 23 < n are shifted right by ((y * 31) % (n*20)) px, RGB separation of n px
`{ ()`: left half of image wrapped onto vertical cylinder (WebGL), curved-page effect turning left
`| (j: int)`: `old_image = images[j % (len(images) - 1)]`, left half is prev, right half is old_image, center column is 10px blend
`} ()`: right half of image wrapped onto vertical cylinder (WebGL), curved-page effect turning right
`~ (n: int)`: horizontal wave distortion where amplitude = sin(y * 0.05) * n*8, with chromatic aberration (R +n px, B -n px horizontal)
`< ()`: prev is shifted 1/3 of the width to the left with wraparound
`> ()`: prev is shifted 1/3 of the width to the right with wraparound

All functions need to be completely deterministic! You must not use the random function anywhere!

Assign a random color to each character, and a number that starts at 1 at `A`, incrementing by one to `Z`, followed by `0` through `9`, followed by symbols.

---

# runtime.ts:

${:sh cat runtime.ts<eval-result-171933065784>import { characterDefs, createSolidImage, Image, FnContext, CharDef } from './character-defs.js';

interface ParsedSolidColor {
  type: 'solid';
  identifier: string;
  color: string;
}

interface ParsedFunction {
  type: 'function';
  identifier: string;
  fnDef: CharDef;
  args: (number | string)[];
}

type ParsedOp = ParsedSolidColor | ParsedFunction;

class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }

  clear(): void {
    this.cache.clear();
  }
}

function parseProgram(program: string): ParsedOp[] {
  console.log(`\n=== PARSING: "${program}" ===`);
  const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
  console.log(`Filtered chars: "${chars.join('')}"`);
  
  if (chars.length === 0) {
    console.log('Empty program, returning []');
    return [];
  }

  const ops: ParsedOp[] = [];
  
  const firstChar = chars[0];
  const firstDef = characterDefs[firstChar];
  const firstColor = firstDef ? firstDef.color : '#000000';
  
  console.log(`[0] First char '${firstChar}' -> solid color ${firstColor}`);
  ops.push({
    type: 'solid',
    identifier: firstChar,
    color: firstColor
  });

  let i = 1;
  while (i < chars.length) {
    const char = chars[i];
    const def = characterDefs[char];
    
    if (!def) {
      console.log(`[${i}] '${char}' undefined, skipping`);
      i++;
      continue;
    }

    const args: (number | string)[] = [];
    let argsConsumed = 0;

    console.log(`[${i}] '${char}' -> ${def.functionName}, arity ${def.arity}`);

    for (let argIdx = 0; argIdx < def.arity; argIdx++) {
      const argType = def.argTypes[argIdx];
      const nextCharIdx = i + 1 + argIdx;
      
      if (nextCharIdx < chars.length) {
        const argChar = chars[nextCharIdx];
        const argDef = characterDefs[argChar];
        
        if (argDef) {
          if (argType === 'int') {
            args.push(argDef.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.number}`);
          } else {
            args.push(argDef.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' -> ${argDef.color}`);
          }
          argsConsumed++;
        } else {
          if (argType === 'int') {
            args.push(def.number);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.number}`);
          } else {
            args.push(def.color);
            console.log(`  arg[${argIdx}] (${argType}): '${argChar}' undefined, using default ${def.color}`);
          }
        }
      } else {
        if (argType === 'int') {
          args.push(def.number);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.number}`);
        } else {
          args.push(def.color);
          console.log(`  arg[${argIdx}] (${argType}): EOF, using default ${def.color}`);
        }
      }
    }

    const endIndex = i + 1 + argsConsumed;
    const identifier = chars.slice(0, endIndex).join('');
    
    console.log(`  identifier: "${identifier}"`);
    
    ops.push({
      type: 'function',
      identifier,
      fnDef: def,
      args
    });
    
    i += 1 + argsConsumed;
  }

  console.log(`Parsed into ${ops.length} operations`);
  return ops;
}

const imageCache = new LRUCache<string, Image>(100);
let lastWidth = 0;
let lastHeight = 0;

export function runProgram(program: string, width: number, height: number): Image[] {
  console.log(`\n=== EXECUTION: ${width}x${height} ===`);
  
  if (width !== lastWidth || height !== lastHeight) {
    console.log(`Dimensions changed (${lastWidth}x${lastHeight} -> ${width}x${height}), clearing cache`);
    imageCache.clear();
    lastWidth = width;
    lastHeight = height;
  }

  const ops = parseProgram(program);
  
  if (ops.length === 0) {
    console.log('No operations, returning black image');
    return [createSolidImage(width, height, '#000000')];
  }

  const images: Image[] = [];
  let cacheHits = 0;
  let cacheMisses = 0;
  
  for (let opIdx = 0; opIdx < ops.length; opIdx++) {
    const op = ops[opIdx];
    console.log(`\n[Op ${opIdx}] identifier="${op.identifier}"`);
    
    const cached = imageCache.get(op.identifier);
    if (cached) {
      console.log(`  ✓ CACHE HIT`);
      images.push(cached);
      cacheHits++;
      continue;
    }

    console.log(`  ✗ CACHE MISS`);
    cacheMisses++;

    let result: Image;
    
    if (op.type === 'solid') {
      console.log(`  Creating solid image: ${op.color}`);
      result = createSolidImage(width, height, op.color);
    } else {
      console.log(`  Executing function: ${op.fnDef.functionName} with args:`, op.args);
      const ctx: FnContext = {
        width,
        height,
        images: [...images],
        currentIndex: images.length,
      };
      
      result = op.fnDef.fn(ctx, ...op.args);
    }
    
    images.push(result);
    imageCache.set(op.identifier, result);
    console.log(`  ✓ Cached result for "${op.identifier}"`);
  }

  console.log(`\n=== EXECUTION COMPLETE ===`);
  console.log(`Cache hits: ${cacheHits}, Cache misses: ${cacheMisses}`);
  console.log(`Total images: ${images.length}`);
  return images;
}

export function getFinalImage(program: string, width: number, height: number): Image {
  const images = runProgram(program, width, height);
  return images[images.length - 1];
}

export function getParsedOperations(program: string): ParsedOp[] {
  return parseProgram(program);
}
</eval-result-171933065784>}

---

# character-defs.ts:

${:sh cat character-defs.ts<eval-result-171933765404>export interface Image {
  width: number;
  height: number;
  data: Uint8ClampedArray;
}

export interface FnContext {
  width: number;
  height: number;
  images: Image[];
  currentIndex: number;
}

export interface CharDef {
  color: string;
  number: number;
  fn: (ctx: FnContext, ...args: any[]) => Image;
  arity: number;
  argTypes: ('int' | 'color')[];
  functionName: string;
  documentation: string;
}

let glCanvas: HTMLCanvasElement | null = null;
let gl: WebGLRenderingContext | null = null;
let glTexture: WebGLTexture | null = null;
let glFramebuffer: WebGLFramebuffer | null = null;

function initWebGL(width: number, height: number): WebGLRenderingContext {
  if (!glCanvas || glCanvas.width !== width || glCanvas.height !== height) {
    glCanvas = document.createElement('canvas');
    glCanvas.width = width;
    glCanvas.height = height;
    gl = glCanvas.getContext('webgl', { 
      premultipliedAlpha: false,
      preserveDrawingBuffer: true 
    });
    if (!gl) throw new Error('WebGL not supported');
    
    glTexture = gl.createTexture();
    glFramebuffer = gl.createFramebuffer();
  }
  return gl!;
}

function createShaderProgram(gl: WebGLRenderingContext, vertSource: string, fragSource: string): WebGLProgram {
  const vertShader = gl.createShader(gl.VERTEX_SHADER)!;
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);
  
  const fragShader = gl.createShader(gl.FRAGMENT_SHADER)!;
  gl.shaderSource(fragShader, fragSource);
  gl.compileShader(fragShader);
  
  const program = gl.createProgram()!;
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  
  return program;
}

export function createSolidImage(width: number, height: number, color: string): Image {
  const [r, g, b] = hexToRgb(color);
  const data = new Uint8ClampedArray(width * height * 4);
  for (let i = 0; i < width * height; i++) {
    data[i * 4] = r;
    data[i * 4 + 1] = g;
    data[i * 4 + 2] = b;
    data[i * 4 + 3] = 255;
  }
  return { width, height, data };
}

function hexToRgb(hex: string): [number, number, number] {
  const h = hex.replace('#', '');
  return [
    parseInt(h.substring(0, 2), 16),
    parseInt(h.substring(2, 4), 16),
    parseInt(h.substring(4, 6), 16),
  ];
}

function cloneImage(img: Image): Image {
  return {
    width: img.width,
    height: img.height,
    data: new Uint8ClampedArray(img.data),
  };
}

function getPrevImage(ctx: FnContext): Image {
  if (ctx.images.length === 0) {
    return createSolidImage(ctx.width, ctx.height, '#000000');
  }
  return ctx.images[ctx.images.length - 1];
}

function getOldImage(ctx: FnContext, j: number): Image {
  if (ctx.images.length <= 1) return getPrevImage(ctx);
  const idx = Math.abs(j) % (ctx.images.length - 1);
  return ctx.images[idx];
}

function getPixel(img: Image, x: number, y: number): [number, number, number, number] {
  const cx = Math.max(0, Math.min(img.width - 1, Math.floor(x)));
  const cy = Math.max(0, Math.min(img.height - 1, Math.floor(y)));
  const i = (cy * img.width + cx) * 4;
  return [img.data[i], img.data[i + 1], img.data[i + 2], img.data[i + 3]];
}

function setPixel(img: Image, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {
  if (x < 0 || x >= img.width || y < 0 || y >= img.height) return;
  const i = (y * img.width + x) * 4;
  img.data[i] = r;
  img.data[i + 1] = g;
  img.data[i + 2] = b;
  img.data[i + 3] = a;
}

function rgbToHsl(r: number, g: number, b: number): [number, number, number] {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0, s = 0;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
  }
  
  return [h * 360, s, l];
}

function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  h = h / 360;
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function fnA(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    vec3 renderSphere(vec2 uv, vec2 center, float radius, sampler2D tex) {
      vec2 p = (uv - center) / radius;
      float d = length(p);
      
      if (d > 1.0) return vec3(-1.0);
      
      float z = sqrt(1.0 - d * d);
      vec3 normal = normalize(vec3(p.x, -p.y, z));
      vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.0));
      
      float diffuse = max(dot(normal, lightDir), 0.0);
      float ambient = 0.3;
      float lighting = ambient + diffuse * 0.7;
      
      vec2 texCoord = vec2(
        atan(normal.x, normal.z) / (2.0 * 3.14159) + 0.5,
        acos(normal.y) / 3.14159
      );
      
      vec3 color = texture2D(tex, texCoord).rgb;
      return color * lighting;
    }
    
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;
      vec3 bg = texture2D(texture, uv).rgb;
      
      vec2 topRight = vec2(0.75, 0.75);
      vec2 bottomLeft = vec2(0.25, 0.25);
      float radius = 0.15;
      
      vec3 sphere1 = renderSphere(uv, topRight, radius, texture);
      vec3 sphere2 = renderSphere(uv, bottomLeft, radius, texture);
      
      vec3 color = bg;
      if (sphere1.x >= 0.0) color = sphere1;
      if (sphere2.x >= 0.0) color = sphere2;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  const textureLoc = gl.getUniformLocation(program, 'texture');
  const resolutionLoc = gl.getUniformLocation(program, 'resolution');
  
  gl.uniform1i(textureLoc, 0);
  gl.uniform2f(resolutionLoc, ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnB(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const seeds: [number, number][] = [];
  for (let i = 0; i < 36; i++) {
    seeds.push([
      (i * 47) % ctx.width,
      (i * 89) % ctx.height
    ]);
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let minDist = Infinity;
      let closestIdx = 0;
      
      for (let i = 0; i < seeds.length; i++) {
        const dx = x - seeds[i][0];
        const dy = y - seeds[i][1];
        const dist = dx * dx + dy * dy;
        if (dist < minDist) {
          minDist = dist;
          closestIdx = i;
        }
      }
      
      const src = closestIdx % 2 === 0 ? prev : old;
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnC(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const rings = Math.max(2, Math.min(n, 50));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxRadius = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const ringIdx = Math.floor((dist / maxRadius) * rings);
      const [r, g, b] = getPixel(prev, x, y);
      
      if (ringIdx % 2 === 0) {
        setPixel(out, x, y, r, g, b);
      } else {
        const hueShift = (360 / rings) * ringIdx;
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnD(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const divisions = Math.max(1, Math.min(n + 1, 10));
  const totalTriangles = divisions * divisions * 2;
  
  for (let row = 0; row < divisions; row++) {
    for (let col = 0; col < divisions; col++) {
      const x0 = Math.floor((col / divisions) * ctx.width);
      const y0 = Math.floor((row / divisions) * ctx.height);
      const x1 = Math.floor(((col + 1) / divisions) * ctx.width);
      const y1 = Math.floor(((row + 1) / divisions) * ctx.height);
      
      const triIndex = (row * divisions + col) * 2;
      const hue1 = ((triIndex * 137.5) % 360);
      const hue2 = (((triIndex + 1) * 137.5) % 360);
      
      const sat1 = 0.6 + (triIndex % 3) * 0.15;
      const sat2 = 0.6 + ((triIndex + 1) % 3) * 0.15;
      
      const light1 = 0.4 + (triIndex % 5) * 0.1;
      const light2 = 0.4 + ((triIndex + 1) % 5) * 0.1;
      
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const localX = (x - x0) / (x1 - x0);
          const localY = (y - y0) / (y1 - y0);
          
          const [r, g, b] = getPixel(prev, x, y);
          const [h, s, l] = rgbToHsl(r, g, b);
          
          const isUpperTriangle = localX + localY < 1;
          const hue = isUpperTriangle ? hue1 : hue2;
          const sat = isUpperTriangle ? sat1 : sat2;
          const light = isUpperTriangle ? light1 : light2;
          
          const avgLuminance = l;
          const finalLight = light * 0.7 + avgLuminance * 0.3;
          
          const [nr, ng, nb] = hslToRgb(hue, sat, finalLight);
          setPixel(out, x, y, nr, ng, nb);
        }
      }
    }
  }
  
  return out;
}

function fnE(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height);
  const sunRadius = scale * 0.25;
  const moonRadius = scale * 0.24;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const distFromCenter = Math.sqrt(dx * dx + dy * dy);
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (distFromCenter < moonRadius) {
        const [or, og, ob] = getPixel(old, x, y);
        setPixel(out, x, y, or, og, ob);
      } else {
        const coronaDist = distFromCenter - sunRadius;
        
        let intensity = 0;
        if (coronaDist > 0) {
          const coronaFalloff = Math.exp(-coronaDist / (scale * 0.25));
          const innerCorona = Math.exp(-coronaDist / (scale * 0.08)) * 3;
          
          const angle = Math.atan2(dy, dx);
          const rays = 0.5 + 0.5 * Math.sin(angle * 12) * Math.sin(angle * 5);
          const rayIntensity = rays * Math.exp(-coronaDist / (scale * 0.5)) * 2;
          
          intensity = innerCorona + coronaFalloff * 1.5 + rayIntensity;
        } else {
          intensity = 4.0;
        }
        
        if (distFromCenter < moonRadius + 8 && distFromCenter >= moonRadius) {
          const edgeGlow = 1 - (distFromCenter - moonRadius) / 8;
          intensity += edgeGlow * 5;
        }
        
        const tr = Math.min(1, (pr / 255) * intensity + intensity * 0.1);
        const tg = Math.min(1, (pg / 255) * intensity + intensity * 0.05);
        const tb = Math.min(1, (pb / 255) * intensity);
        
        setPixel(out, x, y,
          Math.floor(tr * 255),
          Math.floor(tg * 255),
          Math.floor(tb * 255)
        );
      }
    }
  }
  
  return out;
}

function fnF(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const maxIterations = Math.max(10, Math.min(n * 10, 100));
  
  const centerPixel = getPixel(prev, Math.floor(ctx.width / 2), Math.floor(ctx.height / 2));
  const cReal = (centerPixel[0] / 255) * 2 - 1;
  const cImag = (centerPixel[1] / 255) * 2 - 1;
  
  for (let py = 0; py < ctx.height; py++) {
    for (let px = 0; px < ctx.width; px++) {
      let zReal = (px / ctx.width) * 3 - 1.5;
      let zImag = (py / ctx.height) * 3 - 1.5;
      
      let iteration = 0;
      while (iteration < maxIterations && zReal * zReal + zImag * zImag < 4) {
        const zRealTemp = zReal * zReal - zImag * zImag + cReal;
        zImag = 2 * zReal * zImag + cImag;
        zReal = zRealTemp;
        iteration++;
      }
      
      const intensity = iteration / maxIterations;
      const idx = (py * ctx.width + px) * 4;
      
      out.data[idx] = Math.min(255, out.data[idx] + intensity * 255);
      out.data[idx + 1] = Math.min(255, out.data[idx + 1] + intensity * 200);
      out.data[idx + 2] = Math.min(255, out.data[idx + 2] + intensity * 150);
    }
  }
  
  return out;
}

function fnG(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const histogram = new Array(256).fill(0);
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = Math.round(out.data[i] * 0.299 + out.data[i + 1] * 0.587 + out.data[i + 2] * 0.114);
    out.data[i] = gray;
    out.data[i + 1] = gray;
    out.data[i + 2] = gray;
    histogram[gray]++;
  }
  
  const numColors = Math.max(2, Math.min(n, 16));
  const colors: [number, number, number][] = [];
  
  for (let i = 0; i < numColors; i++) {
    const hue = (i / numColors) * 360;
    colors.push(hslToRgb(hue, 0.7, 0.5));
  }
  
  for (let i = 0; i < out.data.length; i += 4) {
    const gray = out.data[i];
    const colorIndex = Math.floor((gray / 256) * numColors);
    const clampedIndex = Math.min(colorIndex, numColors - 1);
    
    out.data[i] = colors[clampedIndex][0];
    out.data[i + 1] = colors[clampedIndex][1];
    out.data[i + 2] = colors[clampedIndex][2];
  }
  
  return out;
}

function fnH(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    const stripHeight = 5 + Math.sin(y * 0.1) * 20;
    const stripIndex = Math.floor(y / stripHeight);
    const useOld = stripIndex % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const src = useOld ? old : prev;
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnI(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  for (let i = 0; i < out.data.length; i += 4) {
    out.data[i] = 255 - out.data[i];
    out.data[i + 1] = 255 - out.data[i + 1];
    out.data[i + 2] = 255 - out.data[i + 2];
  }
  
  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  for (let y = 1; y < ctx.height - 1; y++) {
    for (let x = 1; x < ctx.width - 1; x++) {
      let gx = 0, gy = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const px = getPixel(prev, x + kx, y + ky);
          const gray = px[0] * 0.299 + px[1] * 0.587 + px[2] * 0.114;
          const kernelIdx = (ky + 1) * 3 + (kx + 1);
          gx += gray * sobelX[kernelIdx];
          gy += gray * sobelY[kernelIdx];
        }
      }
      
      const magnitude = Math.sqrt(gx * gx + gy * gy);
      
      if (magnitude > 50) {
        setPixel(out, x, y, 255, 255, 255);
      }
    }
  }
  
  return out;
}

function fnJ(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = x / ctx.width;
      const ny = y / ctx.height;
      
      const squareSize = Math.max(2, Math.floor(2 + (nx + ny) * 50));
      
      const gridX = Math.floor(x / squareSize);
      const gridY = Math.floor(y / squareSize);
      
      const useOld = (gridX + gridY) % 2 === 0;
      const src = useOld ? old : prev;
      
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnK(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const segments = Math.max(1, Math.min(n + 2, 18));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const angleStep = (Math.PI * 2) / segments;
  const zoom = 1.1;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = (x - cx) * zoom;
      const dy = (y - cy) * zoom;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const segmentAngle = angle % angleStep;
      const mirroredAngle = segmentAngle > angleStep / 2 ? angleStep - segmentAngle : segmentAngle;
      
      const r = Math.sqrt(dx * dx + dy * dy);
      const sx = cx + r * Math.cos(mirroredAngle);
      const sy = cy + r * Math.sin(mirroredAngle);
      
      const [pr, pg, pb] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, pr, pg, pb);
    }
  }
  
  return out;
}

function fnL(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const complexity = 2;
  const thickness = Math.max(2, Math.floor(Math.min(ctx.width, ctx.height) / 80));
  const numCurves = Math.min(complexity, 5);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scaleX = cx * 0.9;
  const scaleY = cy * 0.9;
  
  const [bgR, bgG, bgB] = getPixel(prev, Math.floor(cx), Math.floor(cy));
  
  const mask = new Uint8Array(ctx.width * ctx.height);
  
  const drawThickLine = (x0: number, y0: number, x1: number, y1: number) => {
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    let x = x0, y = y0;
    
    while (true) {
      for (let ty = -thickness; ty <= thickness; ty++) {
        for (let tx = -thickness; tx <= thickness; tx++) {
          if (tx * tx + ty * ty <= thickness * thickness) {
            const px = x + tx;
            const py = y + ty;
            if (px >= 0 && px < ctx.width && py >= 0 && py < ctx.height) {
              mask[py * ctx.width + px] = 1;
            }
          }
        }
      }
      
      if (x === x1 && y === y1) break;
      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x += sx; }
      if (e2 < dx) { err += dx; y += sy; }
    }
  };
  
  for (let c = 0; c < numCurves; c++) {
    const a = complexity + c;
    const b = complexity + c + 1 + (c % 3);
    const delta = (c * Math.PI) / (numCurves + 1);
    
    const steps = 800;
    let prevX = Math.floor(cx + Math.sin(delta) * scaleX);
    let prevY = Math.floor(cy);
    
    for (let i = 1; i <= steps; i++) {
      const t = (i / steps) * Math.PI * 2;
      const currX = Math.floor(cx + Math.sin(a * t + delta) * scaleX);
      const currY = Math.floor(cy + Math.sin(b * t) * scaleY);
      
      drawThickLine(prevX, prevY, currX, currY);
      
      prevX = currX;
      prevY = currY;
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      if (mask[y * ctx.width + x]) {
        const nx = x / ctx.width;
        const ny = y / ctx.height;
        const gradientPos = (nx + ny) * 0.5;
        const v = Math.floor(gradientPos * 255);
        setPixel(out, x, y, v, v, v);
      }
    }
  }
  
  return out;
}

function fnM(ctx: FnContext, spiralEffect: number, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const blockSize = Math.max(2, Math.min(spiralEffect + 2, 50));
  const spiralTightness = Math.max(5, spiralEffect * 5);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let by = 0; by < ctx.height; by += blockSize) {
    for (let bx = 0; bx < ctx.width; bx += blockSize) {
      const centerX = bx + blockSize / 2;
      const centerY = by + blockSize / 2;
      
      const dx = centerX - cx;
      const dy = centerY - cy;
      const radius = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      const spiralValue = radius + angle * spiralTightness;
      const bandIndex = Math.floor(spiralValue / spiralTightness);
      const useOld = bandIndex % 2 === 0;
      
      if (useOld) {
        for (let y = by; y < by + blockSize && y < ctx.height; y++) {
          for (let x = bx; x < bx + blockSize && x < ctx.width; x++) {
            const [r, g, b] = getPixel(old, x, y);
            setPixel(out, x, y, r, g, b);
          }
        }
      } else {
        let sumR = 0, sumG = 0, sumB = 0, count = 0;
        for (let y = by; y < by + blockSize && y < ctx.height; y++) {
          for (let x = bx; x < bx + blockSize && x < ctx.width; x++) {
            const [r, g, b] = getPixel(prev, x, y);
            sumR += r;
            sumG += g;
            sumB += b;
            count++;
          }
        }
        
        const avgR = Math.round(sumR / count);
        const avgG = Math.round(sumG / count);
        const avgB = Math.round(sumB / count);
        
        for (let y = by; y < by + blockSize && y < ctx.height; y++) {
          for (let x = bx; x < bx + blockSize && x < ctx.width; x++) {
            setPixel(out, x, y, avgR, avgG, avgB);
          }
        }
      }
    }
  }
  
  return out;
}

function fnN(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const scale = Math.min(ctx.width, ctx.height);
  const numLights = 15;
  
  const seed = ctx.images.length * 137.5;
  const hash = (n: number) => {
    const x = Math.sin(n + seed) * 43758.5453;
    return x - Math.floor(x);
  };
  
  const lights: { x: number; y: number; r: number; g: number; b: number; size: number }[] = [];
  for (let i = 0; i < numLights; i++) {
    const px = hash(i * 127.1) * ctx.width;
    const py = hash(i * 311.7) * ctx.height;
    const colorAngle = hash(i * 74.3) * Math.PI * 2;
    const size = 0.03 + hash(i * 191.3) * 0.04;
    lights.push({
      x: px, y: py,
      r: Math.cos(colorAngle) * 0.5 + 0.5,
      g: Math.cos(colorAngle + Math.PI * 2 / 3) * 0.5 + 0.5,
      b: Math.cos(colorAngle + Math.PI * 4 / 3) * 0.5 + 0.5,
      size
    });
  }
  
  const glowRadius = 8;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / (255 * 3);
      
      let tr = (pr / 255) * 0.3;
      let tg = (pg / 255) * 0.3;
      let tb = (pb / 255) * 0.3;
      
      if (brightness > 0.3) {
        let glowSum = 0;
        let glowR = 0, glowG = 0, glowB = 0;
        for (let dy = -glowRadius; dy <= glowRadius; dy += 2) {
          for (let dx = -glowRadius; dx <= glowRadius; dx += 2) {
            const sx = Math.max(0, Math.min(ctx.width - 1, x + dx));
            const sy = Math.max(0, Math.min(ctx.height - 1, y + dy));
            const [sr, sg, sb] = getPixel(prev, sx, sy);
            const sBright = (sr + sg + sb) / (255 * 3);
            if (sBright > 0.3) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              const weight = Math.max(0, 1 - dist / glowRadius);
              glowR += (sr / 255) * weight * sBright;
              glowG += (sg / 255) * weight * sBright;
              glowB += (sb / 255) * weight * sBright;
              glowSum += weight;
            }
          }
        }
        if (glowSum > 0) {
          tr += (glowR / glowSum) * brightness * 1.5;
          tg += (glowG / glowSum) * brightness * 1.5;
          tb += (glowB / glowSum) * brightness * 1.5;
        }
      }
      
      for (const light of lights) {
        const dx = (x - light.x) / scale;
        const dy = (y - light.y) / scale;
        const distSq = dx * dx + dy * dy;
        const glow = (light.size * light.size) / Math.max(0.0001, distSq);
        const cappedGlow = Math.min(1, glow);
        tr += cappedGlow * light.r;
        tg += cappedGlow * light.g;
        tb += cappedGlow * light.b;
      }
      
      setPixel(out, x, y,
        Math.min(255, Math.floor(tr * 255)),
        Math.min(255, Math.floor(tg * 255)),
        Math.min(255, Math.floor(tb * 255))
      );
    }
  }
  
  return out;
}

function fnO(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.0001, Math.min(0.0002 + (n - 1) * 0.05, 8));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      
      const normX = dx / cx;
      const normY = dy / cy;
      const normR = Math.min(1, Math.sqrt(normX * normX + normY * normY));
      
      if (normR < 0.001) {
        const [pr, pg, pb] = getPixel(prev, Math.floor(cx), Math.floor(cy));
        setPixel(out, x, y, pr, pg, pb);
        continue;
      }
      
      const falloff = 1 - normR;
      const factor = 1 + (strength - 1) * falloff;
      
      const sx = cx + dx * factor;
      const sy = cy + dy * factor;
      
      const [pr, pg, pb] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, pr, pg, pb);
    }
  }
  
  return out;
}

function fnP(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(2, Math.min(n + 1, 50));
  
  for (let by = 0; by < ctx.height; by += cellSize) {
    for (let bx = 0; bx < ctx.width; bx += cellSize) {
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      let maxSat = 0;
      let mostSatR = 0, mostSatG = 0, mostSatB = 0;
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const [r, g, b] = getPixel(prev, x, y);
          sumR += r;
          sumG += g;
          sumB += b;
          count++;
          
          const [h, s, l] = rgbToHsl(r, g, b);
          if (s > maxSat) {
            maxSat = s;
            mostSatR = r;
            mostSatG = g;
            mostSatB = b;
          }
        }
      }
      
      const avgR = Math.round(sumR / count);
      const avgG = Math.round(sumG / count);
      const avgB = Math.round(sumB / count);
      
      for (let y = by; y < by + cellSize && y < ctx.height; y++) {
        for (let x = bx; x < bx + cellSize && x < ctx.width; x++) {
          const localX = x - bx;
          const localY = y - by;
          const isTopLeft = localX + localY < cellSize;
          
          if (isTopLeft) {
            setPixel(out, x, y, avgR, avgG, avgB);
          } else {
            setPixel(out, x, y, mostSatR, mostSatG, mostSatB);
          }
        }
      }
    }
  }
  
  return out;
}

function fnR(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision mediump float;
    uniform sampler2D texture;
    uniform vec2 resolution;
    varying vec2 vUV;
    
    void main() {
      vec2 uv = vUV;
      float wave = sin(uv.x * 20.0) * 0.1;
      float shade = 0.7 + 0.3 * cos(uv.x * 20.0);
      
      vec2 distortedUV = vec2(uv.x, uv.y + wave * (0.5 - abs(uv.y - 0.5)));
      vec3 color = texture2D(texture, distortedUV).rgb * shade;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnS(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const skewAmount = Math.tan(20 * Math.PI / 180) * ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    const rowSkew = skewAmount * (1 - 2 * y / ctx.height);
    for (let x = 0; x < ctx.width; x++) {
      const sx = ((x + rowSkew) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnT(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numDrawers = Math.max(1, n + 1);
  
  // Vertex shader with MVP transformation
  const vertexShader = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;
    
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec4 worldPos = uModel * vec4(aPosition, 1.0);
      vWorldPos = worldPos.xyz;
      vNormal = mat3(uModel) * aNormal;
      vTexCoord = aTexCoord;
      gl_Position = uProjection * uView * worldPos;
    }
  `;
  
  // Fragment shader with lighting
  const fragmentShader = `
    precision highp float;
    
    uniform sampler2D uTexture;
    uniform vec3 uLightDir;
    uniform int uFaceType; // 0 = front, 1 = side, 2 = top/bottom
    
    varying vec3 vNormal;
    varying vec2 vTexCoord;
    varying vec3 vWorldPos;
    
    void main() {
      vec3 normal = normalize(vNormal);
      vec3 lightDir = normalize(uLightDir);
      
      float ambient = 0.85;
      float diffuse = max(dot(normal, lightDir), 0.0) * 0.15;
      float lighting = ambient + diffuse;
      
      vec3 color = texture2D(uTexture, vTexCoord).rgb * lighting;
      gl_FragColor = vec4(color, 1.0);
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  
  // Create texture from prev image
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  // Helper to create box geometry
  function createBox(cx: number, cy: number, hw: number, hh: number, depth: number): { vertices: number[], normals: number[], texCoords: number[] } {
    const x0 = cx - hw, x1 = cx + hw;
    const y0 = cy - hh, y1 = cy + hh;
    const z0 = 0, z1 = depth;
    
    // Texture coords based on box position in image
    const u0 = cx - hw, u1 = cx + hw;
    const v0 = cy - hh, v1 = cy + hh;
    
    const vertices: number[] = [];
    const normals: number[] = [];
    const texCoords: number[] = [];
    
    // Front face (z = z1, facing +z towards camera)
    vertices.push(x0,y0,z1, x1,y0,z1, x1,y1,z1, x0,y0,z1, x1,y1,z1, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(0,0,1);
    texCoords.push(u0,v0, u1,v0, u1,v1, u0,v0, u1,v1, u0,v1);
    
    // Right face (+x)
    vertices.push(x1,y0,z0, x1,y0,z1, x1,y1,z1, x1,y0,z0, x1,y1,z1, x1,y1,z0);
    for(let i=0;i<6;i++) normals.push(1,0,0);
    texCoords.push(u1,v0, u1,v0, u1,v1, u1,v0, u1,v1, u1,v1);
    
    // Left face (-x)
    vertices.push(x0,y0,z1, x0,y0,z0, x0,y1,z0, x0,y0,z1, x0,y1,z0, x0,y1,z1);
    for(let i=0;i<6;i++) normals.push(-1,0,0);
    texCoords.push(u0,v0, u0,v0, u0,v1, u0,v0, u0,v1, u0,v1);
    
    // Top face (+y)
    vertices.push(x0,y1,z1, x1,y1,z1, x1,y1,z0, x0,y1,z1, x1,y1,z0, x0,y1,z0);
    for(let i=0;i<6;i++) normals.push(0,1,0);
    texCoords.push(u0,v1, u1,v1, u1,v1, u0,v1, u1,v1, u0,v1);
    
    // Bottom face (-y)
    vertices.push(x0,y0,z0, x1,y0,z0, x1,y0,z1, x0,y0,z0, x1,y0,z1, x0,y0,z1);
    for(let i=0;i<6;i++) normals.push(0,-1,0);
    texCoords.push(u0,v0, u1,v0, u1,v0, u0,v0, u1,v0, u0,v0);
    
    return { vertices, normals, texCoords };
  }
  
  // Seeded random
  const hash = (n: number) => {
    const x = Math.sin(n) * 43758.5453;
    return x - Math.floor(x);
  };
  
  // Generate all boxes
  const allVertices: number[] = [];
  const allNormals: number[] = [];
  const allTexCoords: number[] = [];
  
  for (let i = 0; i < numDrawers; i++) {
    const cx = hash(i * 127.1);
    const cy = hash(i * 311.7);
    const hw = 0.03 + hash(i * 74.3) * 0.08;
    const hh = 0.025 + hash(i * 183.9) * 0.06;
    const depth = 0.1 + hash(i * 271.3) * 0.2;
    
    const box = createBox(cx, cy, hw, hh, depth);
    allVertices.push(...box.vertices);
    allNormals.push(...box.normals);
    allTexCoords.push(...box.texCoords);
  }
  
  // First render the background quad
  gl.useProgram(program);
  gl.disable(gl.DEPTH_TEST);
  
  const bgVertices = new Float32Array([0,0,0, 1,0,0, 1,1,0, 0,0,0, 1,1,0, 0,1,0]);
  const bgNormals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]);
  const bgTexCoords = new Float32Array([0,0, 1,0, 1,1, 0,0, 1,1, 0,1]);
  
  const posLoc = gl.getAttribLocation(program, 'aPosition');
  const normLoc = gl.getAttribLocation(program, 'aNormal');
  const texLoc = gl.getAttribLocation(program, 'aTexCoord');
  
  // Identity matrices for background
  const identity = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  const ortho = new Float32Array([2,0,0,0, 0,2,0,0, 0,0,-1,0, -1,-1,0,1]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, ortho);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, identity);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uModel'), false, identity);
  gl.uniform3f(gl.getUniformLocation(program, 'uLightDir'), 0.3, 0.5, 1.0);
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  
  const bgPosBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgPosBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgNormBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgNormBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgNormals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const bgTexBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexBuf);
  gl.bufferData(gl.ARRAY_BUFFER, bgTexCoords, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  // Now render boxes with depth testing
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  // Perspective projection with wider FOV
  const aspect = ctx.width / ctx.height;
  const fov = Math.PI / 2.5;
  const near = 0.1, far = 10.0;
  const f = 1.0 / Math.tan(fov / 2);
  const perspective = new Float32Array([
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)/(near-far), -1,
    0, 0, (2*far*near)/(near-far), 0
  ]);
  
  // View matrix - camera positioned to see full 0-1 range
  const camZ = 0.5 / Math.tan(fov / 2);
  const view = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -0.5, -0.5, -camZ, 1
  ]);
  
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, perspective);
  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, view);
  
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  const normBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normLoc);
  gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);
  
  const texBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allTexCoords), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texLoc);
  gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, allVertices.length / 3);
  
  // Read pixels
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = (y * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  // Cleanup - disable vertex attributes before deleting buffers
  gl.disableVertexAttribArray(posLoc);
  gl.disableVertexAttribArray(normLoc);
  gl.disableVertexAttribArray(texLoc);
  gl.disable(gl.DEPTH_TEST);
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(bgPosBuf);
  gl.deleteBuffer(bgNormBuf);
  gl.deleteBuffer(bgTexBuf);
  gl.deleteBuffer(posBuf);
  gl.deleteBuffer(normBuf);
  gl.deleteBuffer(texBuf);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fnU(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const amplitude = n * 5;
  const frequency = Math.max(1, n);
  
  for (let y = 0; y < ctx.height; y++) {
    let rowLuminance = 0;
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      rowLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    rowLuminance /= ctx.width;
    const phase = (rowLuminance / 255) * Math.PI * 2;
    
    for (let x = 0; x < ctx.width; x++) {
      const wave = Math.sin((y / ctx.height) * Math.PI * 2 * frequency + phase) * amplitude;
      const sx = ((x + wave) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, Math.floor(sx), y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnV(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [tr, tg, tb] = hexToRgb(c);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy) * 0.7;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      const vignette = Math.max(0, 1 - Math.pow(dist / maxR, 2));
      const darken = vignette;
      const tint = 1 - vignette;
      
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * darken + tr * tint * 0.5);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * darken + tg * tint * 0.5);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * darken + tb * tint * 0.5);
    }
  }
  
  return out;
}

function fnW(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const maxRotation = (n * 45) * (Math.PI / 180);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const falloff = (1 - normDist) * (1 - normDist);
      const rotation = maxRotation * falloff;
      
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const sx = cx + dx * cos - dy * sin;
      const sy = cy + dx * sin + dy * cos;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnX(ctx: FnContext, k: number, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const shapes = [
    '★', '●', '■', '▲', '◆', '♥', '✦', '⬡', '✚', '◐', '☽', '⚡', '∞', '☀', '✿', '⬢',
    '◯', '△', '□', '◇', '♦', '♣', '♠', '⬟', '⬠', '▽', '◁', '▷', '⊕', '⊗', '⊛', '⊚',
    '▣', '▤', '▥', '▦', '▧', '▨', '▩', '⬣', '⬤', '◉', '◎', '◈', '◊', '○', '◌', '◍',
    '◢', '◣', '◤', '◥', '♯', '♮', '♩', '♪', '✶', '✴', '✳', '✲', '✱', '✰', '✯', '✮'
  ];
  
  const shapeIdx = Math.abs(k) % 64;
  const symbol = shapes[shapeIdx];
  
  const size = Math.min(ctx.width, ctx.height) * 0.9;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = ctx.width;
  tempCanvas.height = ctx.height;
  const tempCtx = tempCanvas.getContext('2d')!;
  
  tempCtx.fillStyle = 'black';
  tempCtx.fillRect(0, 0, ctx.width, ctx.height);
  
  tempCtx.fillStyle = 'white';
  tempCtx.font = `${size}px serif`;
  tempCtx.textAlign = 'center';
  tempCtx.textBaseline = 'alphabetic';
  
  const metrics = tempCtx.measureText(symbol);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const yOffset = metrics.actualBoundingBoxAscent - actualHeight / 2;
  
  tempCtx.fillText(symbol, ctx.width / 2, ctx.height / 2 + yOffset);
  
  const maskData = tempCtx.getImageData(0, 0, ctx.width, ctx.height);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const maskIdx = (y * ctx.width + x) * 4;
      if (maskData.data[maskIdx] > 128) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnY(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const sections = Math.max(2, Math.min(n, 36));
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const sectionIdx = Math.floor(angle / (Math.PI * 2) * sections);
      const hueShift = (sectionIdx / sections) * 360;
      
      const [r, g, b] = getPixel(prev, x, y);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb((h + hueShift) % 360, s, l);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnZ(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const blurAmount = n * 4;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const sharpRadius = 0.2;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      if (normDist < sharpRadius) {
        const [r, g, b] = getPixel(prev, x, y);
        setPixel(out, x, y, r, g, b);
      } else {
        const blurStrength = Math.min(1, (normDist - sharpRadius) / (1 - sharpRadius));
        const samples = Math.max(1, Math.floor(blurStrength * blurAmount / 2));
        
        let sumR = 0, sumG = 0, sumB = 0;
        for (let i = 0; i <= samples; i++) {
          const t = i / samples;
          const sx = cx + dx * (1 - t * blurStrength * 0.5);
          const sy = cy + dy * (1 - t * blurStrength * 0.5);
          const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
          sumR += r;
          sumG += g;
          sumB += b;
        }
        
        setPixel(out, x, y, 
          Math.round(sumR / (samples + 1)),
          Math.round(sumG / (samples + 1)),
          Math.round(sumB / (samples + 1))
        );
      }
    }
  }
  
  return out;
}

function fnQ(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const temp = createSolidImage(hw, hh, '#000000');
  
  for (let y = 0; y < hh; y++) {
    for (let x = 0; x < hw; x++) {
      const sx = (x / hw) * prev.width;
      const sy = (y / hh) * prev.height;
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      if (x / hw + y / hh > 1) {
        setPixel(temp, x, y, 255 - r, 255 - g, 255 - b);
      } else {
        setPixel(temp, x, y, r, g, b);
      }
    }
  }
  
  for (let qy = 0; qy < 2; qy++) {
    for (let qx = 0; qx < 2; qx++) {
      for (let y = 0; y < hh; y++) {
        for (let x = 0; x < hw; x++) {
          const outX = qx * hw + x;
          const outY = qy * hh + y;
          if (outX < ctx.width && outY < ctx.height) {
            const [r, g, b] = getPixel(temp, x, y);
            setPixel(out, outX, outY, r, g, b);
          }
        }
      }
    }
  }
  
  return out;
}

function fn0(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const opacity = Math.max(0.1, Math.min((n * 10) / 100, 1));
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const gradient = 1 - (dist / maxR);
      const gradientValue = gradient * 255;
      
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * (1 - opacity) + (out.data[idx] * gradientValue / 255) * opacity + gradientValue * opacity * 0.5));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * (1 - opacity) + (out.data[idx + 1] * gradientValue / 255) * opacity + gradientValue * opacity * 0.5));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * (1 - opacity) + (out.data[idx + 2] * gradientValue / 255) * opacity + gradientValue * opacity * 0.5));
    }
  }
  
  return out;
}

function fn1(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const barStart = Math.floor(ctx.width / 3);
  const barEnd = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (x >= barStart && x < barEnd) {
        let sr = 0, sg = 0, sb = 0;
        const kernel = [
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0]
        ];
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = kernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        sr = Math.max(0, Math.min(255, sr));
        sg = Math.max(0, Math.min(255, sg));
        sb = Math.max(0, Math.min(255, sb));
        
        const contrast = 1.3;
        sr = Math.max(0, Math.min(255, ((sr / 255 - 0.5) * contrast + 0.5) * 255));
        sg = Math.max(0, Math.min(255, ((sg / 255 - 0.5) * contrast + 0.5) * 255));
        sb = Math.max(0, Math.min(255, ((sb / 255 - 0.5) * contrast + 0.5) * 255));
        
        setPixel(out, x, y, Math.round(sr), Math.round(sg), Math.round(sb));
      } else {
        const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
        setPixel(out, x, y, gray, gray, gray);
      }
    }
  }
  
  return out;
}

function fn2(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const len = ctx.images.length;
  const img3 = len >= 3 ? ctx.images[len - 3] : (len >= 1 ? ctx.images[0] : prev);
  const img2 = len >= 2 ? ctx.images[len - 2] : prev;
  const img1 = prev;
  
  const third1 = Math.floor(ctx.width / 3);
  const third2 = Math.floor(ctx.width * 2 / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let src: Image;
      if (x < third1) {
        src = img3;
      } else if (x < third2) {
        src = img2;
      } else {
        src = img1;
      }
      const [r, g, b] = getPixel(src, x, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn3(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const stripWidth = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < stripWidth; x++) {
      const srcX = Math.floor((y / ctx.height) * stripWidth);
      const srcY = Math.floor(((stripWidth - 1 - x) / stripWidth) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth; x < stripWidth * 2; x++) {
      const srcX = Math.floor(((x - stripWidth) / stripWidth) * stripWidth + stripWidth);
      const srcY = y;
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = stripWidth * 2; x < ctx.width; x++) {
      const localX = x - stripWidth * 2;
      const srcX = Math.floor(((ctx.height - 1 - y) / ctx.height) * (ctx.width - stripWidth * 2) + stripWidth * 2);
      const srcY = Math.floor((localX / (ctx.width - stripWidth * 2)) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn4(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const rotatePoint = (x: number, y: number, cx: number, cy: number, angle: number): [number, number] => {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
  };
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const qx = x < hw ? 0 : 1;
      const qy = y < hh ? 0 : 1;
      const quadrant = qy * 2 + qx;
      const angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2];
      const angle = angles[quadrant];
      
      const localCx = qx === 0 ? hw / 2 : hw + hw / 2;
      const localCy = qy === 0 ? hh / 2 : hh + hh / 2;
      
      const [srcX, srcY] = rotatePoint(x, y, localCx, localCy, -angle);
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn5(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numDrips = Math.max(1, n * 3);
  const dripStrength = Math.max(0.5, Math.min(n * 0.2 + 0.8, 2.0));
  const seed = ctx.images.length * 137.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uStrength;
    uniform int uNumDrips;
    uniform float uSeed;
    varying vec2 vUV;
    
    #define MAX_DRIPS 100
    #define MAX_STEPS 64
    #define WALL_Z 0.0
    #define EPS 0.001
    
    float hash(float n) {
      return fract(sin(n) * 43758.5453123);
    }
    
    // Smooth min for organic blending
    float smin(float a, float b, float k) {
      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
      return mix(b, a, h) - k * h * (1.0 - h);
    }
    
    // Simple sphere SDF
    float sdSphere(vec3 p, vec3 center, float r) {
      return length(p - center) - r;
    }
    
    // Scene SDF - randomly distributed clusters of 4 metaballs each
    float sceneSDF(vec3 p, int numClusters, float strength) {
      float d = 1000.0;
      
      for (int i = 0; i < MAX_DRIPS; i++) {
        if (i >= numClusters) break;
        
        float fi = float(i);
        
        // Random cluster center position across full screen (seeded by image count)
        float clusterX = (hash(fi * 127.1 + uSeed) * 2.0 - 1.0) * 1.5;
        float clusterY = (hash(fi * 311.7 + uSeed) * 2.0 - 1.0) * 1.2;
        
        // Cluster size
        float clusterSize = 0.15 + hash(fi * 74.3 + uSeed) * 0.15;
        
        // 4 balls per cluster (fixed to avoid dynamic loop issues)
        for (int j = 0; j < 4; j++) {
          float fj = float(j);
          float localSeed = fi * 100.0 + fj + uSeed;
          
          // Random offset from cluster center
          float offX = (hash(localSeed * 123.4) - 0.5) * clusterSize;
          float offY = (hash(localSeed * 234.5) - 0.5) * clusterSize * 1.5; // More vertical spread
          
          float x = clusterX + offX;
          float y = clusterY + offY;
          
          // Varying ball sizes within cluster
          float r = (0.06 + hash(localSeed * 345.6) * 0.08) * strength * 0.6;
          
          float z = 0.05 + r * 0.3;
          
          vec3 center = vec3(x, y, z);
          float sphere = sdSphere(p, center, r);
          
          // Smooth blend to merge balls in cluster
          d = smin(d, sphere, 0.12);
        }
      }
      
      return d;
    }
    
    // Calculate normal via gradient
    vec3 calcNormal(vec3 p, int numDrips, float strength) {
      vec2 e = vec2(0.001, 0.0);
      return normalize(vec3(
        sceneSDF(p + e.xyy, numDrips, strength) - sceneSDF(p - e.xyy, numDrips, strength),
        sceneSDF(p + e.yxy, numDrips, strength) - sceneSDF(p - e.yxy, numDrips, strength),
        sceneSDF(p + e.yyx, numDrips, strength) - sceneSDF(p - e.yyx, numDrips, strength)
      ));
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Ray origin and direction (orthographic-ish camera)
      vec3 ro = vec3((uv.x * 2.0 - 1.0) * aspect, uv.y * 2.0 - 1.0, 2.0);
      vec3 rd = vec3(0.0, 0.0, -1.0);
      
      // Raymarch to find metaball surface
      float t = 0.0;
      float d = 0.0;
      bool hit = false;
      vec3 p;
      
      for (int i = 0; i < MAX_STEPS; i++) {
        p = ro + rd * t;
        d = sceneSDF(p, uNumDrips, uStrength);
        
        if (d < EPS) {
          hit = true;
          break;
        }
        if (t > 4.0) break;
        
        t += d * 0.8;
      }
      
      // Sample wall texture
      vec4 wallColor = texture2D(uTexture, uv);
      
      if (hit) {
        vec3 normal = calcNormal(p, uNumDrips, uStrength);
        
        // Light from top (Y is flipped in screen coords)
        vec3 lightDir = normalize(vec3(0.0, -1.0, 0.6));
        vec3 viewDir = -rd;
        
        // Fresnel - edges reflect more
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
        
        // Specular highlight - bright and sharp
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 120.0);
        
        // Refraction - water has IOR ~1.33, so ratio is 1.0/1.33 ≈ 0.75
        vec3 refracted = refract(rd, normal, 0.75);
        vec2 refractUV = uv + refracted.xy * 0.06;
        refractUV = clamp(refractUV, 0.0, 1.0);
        vec4 refractColor = texture2D(uTexture, refractUV);
        
        // Clear water droplet - mostly shows refracted background
        vec3 dropletColor = refractColor.rgb;
        
        // Slight caustic brightening where light focuses
        float caustic = max(dot(normal, lightDir), 0.0);
        dropletColor *= 1.0 + caustic * 0.15;
        
        // Add crisp specular highlight
        dropletColor += vec3(1.0) * spec * 1.5;
        
        // Subtle rim highlight from fresnel
        dropletColor += vec3(1.0) * fresnel * 0.2;
        
        // Very subtle shadow directly under droplet on wall
        vec2 shadowUV = uv + vec2(0.01, 0.02);
        float shadowMask = smoothstep(0.05, 0.0, d) * 0.15;
        vec3 wallWithShadow = wallColor.rgb * (1.0 - shadowMask);
        
        // Droplet is almost fully transparent, just refracts
        gl_FragColor = vec4(dropletColor, 1.0);
      } else {
        gl_FragColor = wallColor;
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uStrength'), dripStrength);
  gl.uniform1i(gl.getUniformLocation(program, 'uNumDrips'), numDrips);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fn6(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hexRadius = Math.max(3, n * 2 + 3);
  const hexWidth = hexRadius * 2;
  const hexHeight = hexRadius * Math.sqrt(3);
  
  const pixelToHex = (px: number, py: number): [number, number] => {
    const q = (2 / 3 * px) / hexRadius;
    const r = (-1 / 3 * px + Math.sqrt(3) / 3 * py) / hexRadius;
    return [q, r];
  };
  
  const hexRound = (q: number, r: number): [number, number] => {
    const s = -q - r;
    let rq = Math.round(q);
    let rr = Math.round(r);
    let rs = Math.round(s);
    
    const qDiff = Math.abs(rq - q);
    const rDiff = Math.abs(rr - r);
    const sDiff = Math.abs(rs - s);
    
    if (qDiff > rDiff && qDiff > sDiff) {
      rq = -rr - rs;
    } else if (rDiff > sDiff) {
      rr = -rq - rs;
    }
    
    return [rq, rr];
  };
  
  const hexToPixel = (q: number, r: number): [number, number] => {
    const x = hexRadius * (3 / 2 * q);
    const y = hexRadius * (Math.sqrt(3) / 2 * q + Math.sqrt(3) * r);
    return [x, y];
  };
  
  const hexAverages = new Map<string, [number, number, number, number]>();
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [q, r] = pixelToHex(x, y);
      const [hq, hr] = hexRound(q, r);
      const key = `${hq},${hr}`;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (!hexAverages.has(key)) {
        hexAverages.set(key, [0, 0, 0, 0]);
      }
      const avg = hexAverages.get(key)!;
      avg[0] += pr;
      avg[1] += pg;
      avg[2] += pb;
      avg[3]++;
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [q, r] = pixelToHex(x, y);
      const [hq, hr] = hexRound(q, r);
      const key = `${hq},${hr}`;
      
      const [centerX, centerY] = hexToPixel(hq, hr);
      const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
      
      const avg = hexAverages.get(key);
      if (avg && avg[3] > 0) {
        const ar = Math.round(avg[0] / avg[3]);
        const ag = Math.round(avg[1] / avg[3]);
        const ab = Math.round(avg[2] / avg[3]);
        
        if (dist > hexRadius - 1.5) {
          setPixel(out, x, y, Math.max(0, ar - 30), Math.max(0, ag - 30), Math.max(0, ab - 30));
        } else {
          setPixel(out, x, y, ar, ag, ab);
        }
      }
    }
  }
  
  return out;
}

function fn7(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRects = Math.max(1, Math.min(n, 20));
  
  for (let i = 1; i <= numRects; i++) {
    const rx = Math.floor(i * ctx.width / (numRects + 2));
    const ry = Math.floor(i * ctx.height / (numRects + 4));
    const rw = Math.floor(ctx.width / (numRects + 2));
    const rh = Math.floor(ctx.height / (numRects + 4));
    
    const hueRotation = (i * 360 / numRects);
    
    for (let y = ry; y < ry + rh && y < ctx.height; y++) {
      for (let x = rx; x < rx + rw && x < ctx.width; x++) {
        const [r, g, b] = getPixel(prev, x, y);
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueRotation) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fn8(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.1, n / 5);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height) / 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / scale;
      const ny = (y - cy) / scale;
      
      const r2 = nx * nx + ny * ny;
      const denom = r2 + 1;
      
      const lemnX = nx * (r2 - 1) / denom;
      const lemnY = ny * (r2 + 1) / denom;
      
      const sx = cx + (nx + (lemnX - nx) * strength * 0.3) * scale;
      const sy = cy + (ny + (lemnY - ny) * strength * 0.3) * scale;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn9(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r1, g1, b1] = getPixel(prev, x, y);
      const [r2, g2, b2] = getPixel(old, x, y);
      
      setPixel(out, x, y, r1 ^ r2, g1 ^ g2, b1 ^ b2);
    }
  }
  
  return out;
}

function fnLessThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = (x + shift) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnGreaterThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = ((x - shift) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnCaret(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.height / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcY = (y + shift) % ctx.height;
      const [r, g, b] = getPixel(prev, x, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnExclaim(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const opacity = 0.3;
  const factor = n + 17;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
    }
  }
  
  return out;
}

function fnDoubleQuote(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const bands = Math.max(2, n);
  const bandHeight = ctx.height / bands;
  
  for (let y = 0; y < ctx.height; y++) {
    const bandIdx = Math.floor(y / bandHeight);
    const isOdd = bandIdx % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (isOdd) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnHash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const gridSpacing = 20;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const thickness = 1 + Math.sin(x * y * 0.01) * 3;
      const nearHorizontal = (y % gridSpacing) < thickness;
      const nearVertical = (x % gridSpacing) < thickness;
      
      if (nearHorizontal || nearVertical) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnDollar(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const turns = Math.max(1, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.min(cx, cy) * 0.9;
  const phi = (1 + Math.sqrt(5)) / 2;
  const totalAngle = turns * Math.PI * 2;
  const steps = turns * 200;
  
  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const angle = t * totalAngle;
    const r = maxR * Math.pow(phi, angle / (Math.PI * 2) - turns + 1);
    
    if (r < 1 || r > maxR) continue;
    
    const x = Math.floor(cx + r * Math.cos(angle));
    const y = Math.floor(cy + r * Math.sin(angle));
    
    if (x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / 3;
      const invBrightness = 255 - brightness;
      
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          if (dx * dx + dy * dy <= 4) {
            setPixel(out, x + dx, y + dy, invBrightness, invBrightness, invBrightness);
          }
        }
      }
    }
  }
  
  return out;
}

function fnPercent(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(1, n + 1);
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  const palette = corners.map(([r, g, b]) => [r, g, b] as [number, number, number]);
  
  const findClosest = (r: number, g: number, b: number): [number, number, number] => {
    let minDist = Infinity;
    let closest = palette[0];
    for (const [pr, pg, pb] of palette) {
      const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
      if (dist < minDist) {
        minDist = dist;
        closest = [pr, pg, pb];
      }
    }
    return closest;
  };
  
  const tempData = new Float32Array(ctx.width * ctx.height * 3);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = (y * ctx.width + x) * 3;
      tempData[idx] = r;
      tempData[idx + 1] = g;
      tempData[idx + 2] = b;
    }
  }
  
  for (let y = 0; y < ctx.height; y += cellSize) {
    for (let x = 0; x < ctx.width; x += cellSize) {
      const idx = (y * ctx.width + x) * 3;
      const oldR = tempData[idx];
      const oldG = tempData[idx + 1];
      const oldB = tempData[idx + 2];
      
      const [newR, newG, newB] = findClosest(oldR, oldG, oldB);
      
      for (let cy = 0; cy < cellSize && y + cy < ctx.height; cy++) {
        for (let cx = 0; cx < cellSize && x + cx < ctx.width; cx++) {
          setPixel(out, x + cx, y + cy, newR, newG, newB);
        }
      }
      
      const errR = oldR - newR;
      const errG = oldG - newG;
      const errB = oldB - newB;
      
      const distribute = (dx: number, dy: number, factor: number) => {
        const nx = x + dx * cellSize;
        const ny = y + dy * cellSize;
        if (nx >= 0 && nx < ctx.width && ny >= 0 && ny < ctx.height) {
          const nidx = (ny * ctx.width + nx) * 3;
          tempData[nidx] += errR * factor;
          tempData[nidx + 1] += errG * factor;
          tempData[nidx + 2] += errB * factor;
        }
      };
      
      distribute(1, 0, 7 / 16);
      distribute(-1, 1, 3 / 16);
      distribute(0, 1, 5 / 16);
      distribute(1, 1, 1 / 16);
    }
  }
  
  return out;
}

function fnAmpersand(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const luminance = pr * 0.299 + pg * 0.587 + pb * 0.114;
      const [oh, os, ol] = rgbToHsl(or, og, ob);
      const [nr, ng, nb] = hslToRgb(oh, os, luminance / 255);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnApostrophe(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const spacing = n + 2;
  
  for (let x = 0; x < ctx.width; x++) {
    if (x % spacing !== 0) continue;
    
    let colLuminance = 0;
    for (let y = 0; y < ctx.height; y++) {
      const [r, g, b] = getPixel(prev, x, y);
      colLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    colLuminance /= ctx.height;
    
    const streakLength = Math.floor((colLuminance / 255) * 100);
    const startY = 0;
    
    for (let y = startY; y < startY + streakLength && y < ctx.height; y++) {
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * 0.5 + 127));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * 0.5 + 127));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * 0.5 + 127));
    }
  }
  
  return out;
}

function fnOpenParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const pinchFactor = 1 + strength * (1 - normDist);
      const sx = cx + dx * pinchFactor;
      const sy = cy + dy * pinchFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const brighten = (1 - normDist) * strength * 30;
      r = Math.min(255, r + brighten);
      g = Math.min(255, g + brighten);
      b = Math.min(255, b + brighten);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnCloseParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const bulgeFactor = 1 - strength * normDist * 0.5;
      const sx = cx + dx * bulgeFactor;
      const sy = cy + dy * bulgeFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const darken = normDist * strength * 50;
      r = Math.max(0, r - darken);
      g = Math.max(0, g - darken);
      b = Math.max(0, b - darken);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnAsterisk(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRays = Math.max(2, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const opacity = 0.6;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const rayAngle = (Math.PI * 2) / numRays;
      const nearestRay = Math.round(angle / rayAngle) * rayAngle;
      const angleDiff = Math.abs(angle - nearestRay);
      
      const rayWidth = 0.05;
      if (angleDiff < rayWidth) {
        const softness = 1 - angleDiff / rayWidth;
        const sampleX = Math.floor(cx + Math.cos(nearestRay) * (ctx.width / numRays));
        const [sr, sg, sb] = getPixel(prev, sampleX, Math.floor(cy));
        
        const idx = (y * ctx.width + x) * 4;
        const blend = softness * opacity;
        out.data[idx] = Math.round(out.data[idx] * (1 - blend) + sr * blend);
        out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - blend) + sg * blend);
        out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - blend) + sb * blend);
      }
    }
  }
  
  return out;
}

function fnPlus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = ctx.width / 2;
  const hh = ctx.height / 2;
  
  const sharpenKernel = [
    [0, -1, 0],
    [-1, 5, -1],
    [0, -1, 0]
  ];
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const inTopLeft = x < hw && y < hh;
      const inBottomRight = x >= hw && y >= hh;
      const shouldSharpen = inTopLeft || inBottomRight;
      
      if (shouldSharpen) {
        let sr = 0, sg = 0, sb = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = sharpenKernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        setPixel(out, x, y,
          Math.max(0, Math.min(255, Math.round(sr))),
          Math.max(0, Math.min(255, Math.round(sg))),
          Math.max(0, Math.min(255, Math.round(sb)))
        );
      } else {
        let sr = 0, sg = 0, sb = 0;
        const radius = 2;
        let count = 0;
        for (let ky = -radius; ky <= radius; ky++) {
          for (let kx = -radius; kx <= radius; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            sr += pr;
            sg += pg;
            sb += pb;
            count++;
          }
        }
        setPixel(out, x, y,
          Math.round(sr / count),
          Math.round(sg / count),
          Math.round(sb / count)
        );
      }
    }
  }
  
  return out;
}

function fnComma(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = Math.floor(r * 0.299 + g * 0.587 + b * 0.114);
      const divisor = 1 + Math.floor(luminance / 32);
      
      if ((x * 13 + y * 7) % divisor === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnMinus(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const spacing = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let [r, g, b] = getPixel(prev, x, y);
      
      if (y % spacing === 0) {
        r = Math.floor(r * 0.5);
        g = Math.floor(g * 0.5);
        b = Math.floor(b * 0.5);
      }
      
      if (y % (spacing * 2) === 0) {
        const srcY = Math.max(0, y - spacing);
        [r, g, b] = getPixel(prev, x, srcY);
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnDot(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const radius = (n % 8) + 2;
  const diameter = radius * 2;
  
  for (let cy = radius; cy < ctx.height; cy += diameter) {
    for (let cx = radius; cx < ctx.width; cx += diameter) {
      const [r, g, b] = getPixel(prev, cx, cy);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb(h, Math.min(1, s + 0.1), l);
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx * dx + dy * dy <= radius * radius) {
            setPixel(out, cx + dx, cy + dy, nr, ng, nb);
          }
        }
      }
    }
  }
  
  return out;
}

function fnSlash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = (x + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

export const characterDefs: Record<string, CharDef> = {
  'A': {
    color: '#78A10F',
    number: 1,
    fn: fnA,
    arity: 0,
    argTypes: [],
    functionName: "sphere-overlay",
    documentation: "Renders prev as texture on two 3D spheres with lighting in top-right and bottom-left quadrants"
  },
  
  'B': {
    color: '#8B4513',
    number: 2,
    fn: fnB,
    arity: 1,
    argTypes: ['int'],
    functionName: "voronoi-blend",
    documentation: "Breaks image into 36 voronoi cells, alternating between prev and old image"
  },
  
  'C': {
    color: '#FF6B35',
    number: 3,
    fn: fnC,
    arity: 1,
    argTypes: ['int'],
    functionName: "concentric-hue",
    documentation: "Creates n concentric circles alternating between original and hue-shifted versions"
  },
  
  'D': {
    color: '#FF1493',
    number: 4,
    fn: fn5,
    arity: 1,
    argTypes: ['int'],
    functionName: "drip",
    documentation: "Metaball-based dripping effect with blobby liquid drips, n controls number and strength"
  },
  
  'E': {
    color: '#00CED1',
    number: 5,
    fn: fnE,
    arity: 1,
    argTypes: ['int'],
    functionName: "eclipse",
    documentation: "Solar eclipse - corona color from prev, old_image shown in moon center"
  },
  
  'F': {
    color: '#FFD700',
    number: 6,
    fn: fnF,
    arity: 1,
    argTypes: ['int'],
    functionName: "julia-fractal",
    documentation: "Draws Julia set fractal using prev's center pixel as c parameter, screen blended"
  },
  
  'G': {
    color: '#9370DB',
    number: 7,
    fn: fnG,
    arity: 1,
    argTypes: ['int'],
    functionName: "grayscale-colorize",
    documentation: "Converts to grayscale then applies n-color rainbow palette based on brightness"
  },
  
  'H': {
    color: '#DC143C',
    number: 8,
    fn: fnH,
    arity: 1,
    argTypes: ['int'],
    functionName: "horizontal-strips",
    documentation: "Horizontal strips alternate between prev and old_image, strip height varies with sin"
  },
  
  'I': {
    color: '#00FF7F',
    number: 9,
    fn: fnI,
    arity: 0,
    argTypes: [],
    functionName: "invert-edges",
    documentation: "Inverts prev colors, then applies Sobel edge detection and draws edges in white"
  },
  
  'J': {
    color: '#FF8C00',
    number: 10,
    fn: fnJ,
    arity: 1,
    argTypes: ['int'],
    functionName: "variable-checkerboard",
    documentation: "Checkerboard blend where square size increases from top-left (2px) to bottom-right (52px)"
  },
  
  'K': {
    color: '#4B0082',
    number: 11,
    fn: fnK,
    arity: 1,
    argTypes: ['int'],
    functionName: "kaleidoscope",
    documentation: "Creates n-way kaleidoscope effect centered on image with 1.1x zoom"
  },
  
  'L': {
    color: '#20B2AA',
    number: 12,
    fn: fnL,
    arity: 0,
    argTypes: [],
    functionName: "lissajous",
    documentation: "Draws Lissajous curves spanning the image with black to white diagonal gradient"
  },
  
  'M': {
    color: '#FF69B4',
    number: 13,
    fn: fnM,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "spiral-interleave",
    documentation: "Interleaves prev and old_image in jagged pixelated spiral, spiral effect (5-100), old image index"
  },
  
  'N': {
    color: '#8A2BE2',
    number: 14,
    fn: fnN,
    arity: 0,
    argTypes: [],
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnO,
    arity: 1,
    argTypes: ['int'],
    functionName: "fisheye-morph",
    documentation: "Fisheye distortion that brightens center and darkens edges with strength n"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
    documentation: "Pixelates with cell size n+1, diagonal split: top-left = average, bottom-right = most saturated"
  },
  
  'Q': {
    color: '#32CD32',
    number: 17,
    fn: fnQ,
    arity: 0,
    argTypes: [],
    functionName: "inverted-tile",
    documentation: "Splits prev diagonally, inverts bottom-right half, then tiles in four quadrants"
  },
  
  'R': {
    color: '#DA70D6',
    number: 18,
    fn: fnR,
    arity: 0,
    argTypes: [],
    functionName: "corrugated",
    documentation: "Image transformed with sinusoidal shape in z dimension, looks vertically corrugated"
  },
  
  'S': {
    color: '#87CEEB',
    number: 19,
    fn: fnS,
    arity: 0,
    argTypes: [],
    functionName: "skew",
    documentation: "Skews image 20 degrees with wraparound"
  },
  
  'T': {
    color: '#F0E68C',
    number: 20,
    fn: fnT,
    arity: 1,
    argTypes: ['int'],
    functionName: "cubes",
    documentation: "3D cubes emerge from image in deterministic chaotic patterns, light from top-right"
  },
  
  'U': {
    color: '#DDA0DD',
    number: 21,
    fn: fnU,
    arity: 1,
    argTypes: ['int'],
    functionName: "undulate",
    documentation: "Vertical wave distortion with amplitude n*5px, frequency n cycles, phase based on luminance"
  },
  
  'V': {
    color: '#40E0D0',
    number: 22,
    fn: fnV,
    arity: 1,
    argTypes: ['color'],
    functionName: "vignette-tint",
    documentation: "Vignette with radius 0.7, darkened edges tinted toward color c"
  },
  
  'W': {
    color: '#EE82EE',
    number: 23,
    fn: fnW,
    arity: 1,
    argTypes: ['int'],
    functionName: "swirl",
    documentation: "Swirl distortion from center, rotation = n*45°, quadratic falloff"
  },
  
  'X': {
    color: '#F5DEB3',
    number: 24,
    fn: fnX,
    arity: 2,
    argTypes: ['int', 'color'],
    functionName: "shape-overlay",
    documentation: "Draws unicode shape k%64 at center in color c (★●■▲◆♥✦⬡✚◐☽⚡∞☀✿⬢...)"
  },
  
  'Y': {
    color: '#98FB98',
    number: 25,
    fn: fnY,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-hue",
    documentation: "Splits into n radial sections, each hue-rotated by i*(360/n)°"
  },
  
  'Z': {
    color: '#AFEEEE',
    number: 26,
    fn: fnZ,
    arity: 1,
    argTypes: ['int'],
    functionName: "zoom-blur",
    documentation: "Radial motion blur from center, blur amount n*4px, center 20% stays sharp"
  },
  
  '0': {
    color: '#E6E6FA',
    number: 27,
    fn: fn0,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-light",
    documentation: "Radial gradient from center (white) to edges (black) multiplied with prev at n*10% opacity, then added back"
  },
  
  '1': {
    color: '#FFA07A',
    number: 28,
    fn: fn1,
    arity: 0,
    argTypes: [],
    functionName: "center-bar",
    documentation: "Middle third of image shows prev sharpened and contrast-boosted, rest is desaturated"
  },
  
  '2': {
    color: '#98D8C8',
    number: 29,
    fn: fn2,
    arity: 0,
    argTypes: [],
    functionName: "time-echo",
    documentation: "Left third shows 3rd previous image, middle shows 2nd previous, right shows prev - recent history triptych"
  },
  
  '3': {
    color: '#F7DC6F',
    number: 30,
    fn: fn3,
    arity: 0,
    argTypes: [],
    functionName: "triple-rotate",
    documentation: "Divides into 3 vertical strips; left rotated 90° CW, middle unchanged, right rotated 90° CCW"
  },
  
  '4': {
    color: '#BB8FCE',
    number: 31,
    fn: fn4,
    arity: 0,
    argTypes: [],
    functionName: "quad-rotate",
    documentation: "Divides into 2x2 quadrants, each rotated (0°, 90°, 180°, 270°)"
  },
  
  '5': {
    color: '#85C1E9',
    number: 32,
    fn: fnD,
    arity: 1,
    argTypes: ['int'],
    functionName: "triangular-split",
    documentation: "Splits prev into (n+1)² triangles, each colorized with a hue based on its index"
  },
  
  '6': {
    color: '#F1948A',
    number: 33,
    fn: fn6,
    arity: 1,
    argTypes: ['int'],
    functionName: "hexagonal-pixelate",
    documentation: "Hexagonal pixelation with cell radius n*5, filled with region's average color, edges 1px darker"
  },
  
  '7': {
    color: '#82E0AA',
    number: 34,
    fn: fn7,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-rectangles",
    documentation: "n rectangles placed diagonally, each filled with prev hue-rotated by i*(360/n)°"
  },
  
  '8': {
    color: '#F8C471',
    number: 35,
    fn: fn8,
    arity: 1,
    argTypes: ['int'],
    functionName: "lemniscate",
    documentation: "Infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along curve"
  },
  
  '9': {
    color: '#D7BDE2',
    number: 36,
    fn: fn9,
    arity: 1,
    argTypes: ['int'],
    functionName: "xor-blend",
    documentation: "XORs prev with old_image at index j, creating glitchy digital artifacts"
  },
  
  '<': {
    color: '#E74C3C',
    number: 37,
    fn: fnLessThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-left",
    documentation: "Shifts prev 1/3 of the width to the left with wraparound"
  },
  
  '>': {
    color: '#3498DB',
    number: 38,
    fn: fnGreaterThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-right",
    documentation: "Shifts prev 1/3 of the width to the right with wraparound"
  },
  
  '^': {
    color: '#2ECC71',
    number: 39,
    fn: fnCaret,
    arity: 0,
    argTypes: [],
    functionName: "shift-up",
    documentation: "Shifts prev 1/3 of the height up with wraparound"
  },
  
  '!': {
    color: '#FF4500',
    number: 40,
    fn: fnExclaim,
    arity: 1,
    argTypes: ['int'],
    functionName: "hash-overlay",
    documentation: "Overlays deterministic hash pattern where brightness = ((x*(n+17)) ^ (y*31) ^ (x*y)) % 256 at 30% opacity"
  },
  
  '"': {
    color: '#9932CC',
    number: 41,
    fn: fnDoubleQuote,
    arity: 1,
    argTypes: ['int'],
    functionName: "band-transform",
    documentation: "Splits into n horizontal bands; odd bands hue-rotated 180°, even bands have saturation inverted"
  },
  
  '#': {
    color: '#228B22',
    number: 42,
    fn: fnHash,
    arity: 1,
    argTypes: ['color'],
    functionName: "grid-lines",
    documentation: "Draws grid of lines in color c with thickness = 1 + sin(x*y*0.01) * 3"
  },
  
  '$': {
    color: '#FFD700',
    number: 43,
    fn: fnDollar,
    arity: 1,
    argTypes: ['int'],
    functionName: "golden-spiral",
    documentation: "Draws golden spiral with n turns from center, spiral color is brightness-inverted sample of prev"
  },
  
  '%': {
    color: '#8B0000',
    number: 44,
    fn: fnPercent,
    arity: 1,
    argTypes: ['int'],
    functionName: "floyd-steinberg",
    documentation: "Floyd-Steinberg dithers prev to 4-corner color palette with cell size n+1"
  },
  
  '&': {
    color: '#4169E1',
    number: 45,
    fn: fnAmpersand,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-sat-transfer",
    documentation: "Output has prev's luminance but hue/saturation from old_image at index j"
  },
  
  "'": {
    color: '#FF1493',
    number: 46,
    fn: fnApostrophe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-streaks",
    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
  },
  
  '(': {
    color: '#00CED1',
    number: 47,
    fn: fnOpenParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "pinch",
    documentation: "Pinch distortion toward center with strength n/10, brightens pixels near center"
  },
  
  ')': {
    color: '#FF69B4',
    number: 48,
    fn: fnCloseParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "bulge",
    documentation: "Bulge distortion from center with strength n/10, darkens pixels near edge"
  },
  
  '*': {
    color: '#FFD700',
    number: 49,
    fn: fnAsterisk,
    arity: 1,
    argTypes: ['int'],
    functionName: "rays",
    documentation: "n rays emanate from center, color sampled from prev at angle*width/n, soft edges at 60% opacity"
  },
  
  '+': {
    color: '#32CD32',
    number: 50,
    fn: fnPlus,
    arity: 0,
    argTypes: [],
    functionName: "quad-sharpen-blur",
    documentation: "Cross divides into 4 quadrants; top-left/bottom-right sharpened, others blurred"
  },
  
  ',': {
    color: '#BA55D3',
    number: 51,
    fn: fnComma,
    arity: 1,
    argTypes: ['color'],
    functionName: "stipple",
    documentation: "Stipples prev with dots of color c at positions where (x*13+y*7) % (1+luminance/32) == 0"
  },
  
  '-': {
    color: '#708090',
    number: 52,
    fn: fnMinus,
    arity: 1,
    argTypes: ['int'],
    functionName: "scanlines",
    documentation: "Every nth row darkened 50%, every (n*2)th row samples from n pixels above"
  },
  
  '.': {
    color: '#20B2AA',
    number: 53,
    fn: fnDot,
    arity: 1,
    argTypes: ['int'],
    functionName: "pointillism",
    documentation: "Rebuilds prev from circles of radius (n%8)+2, color from center with +10% saturation"
  },
  
  '/': {
    color: '#CD853F',
    number: 54,
    fn: fnSlash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines",
    documentation: "Diagonal lines top-left to bottom-right in color c, spacing based on luminance (bright=sparse)"
  },
};
</eval-result-171933765404>}

---

# index.html:

${:sh cat index.html<eval-result-171933293249><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Esoteric Image Language</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: monospace;
    }
    
    #input-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      padding: 10px;
      background: rgba(0, 0, 0, 0.7);
    }
    
    #input-wrapper {
      position: relative;
      width: 100%;
    }
    
    #program-input {
      position: relative;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid #444;
      border-radius: 4px;
      background: transparent;
      color: #fff;
      outline: none;
      z-index: 2;
    }
    
    #program-input:focus {
      border-color: #888;
    }
    
    #input-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      font-size: 18px;
      font-family: monospace;
      border: 2px solid transparent;
      border-radius: 4px;
      background: #1a1a1a;
      color: transparent;
      pointer-events: none;
      white-space: pre;
      z-index: 1;
    }
    
    #input-background span {
      border-radius: 2px;
      padding: 1px 0;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #debug-pane {
      position: fixed;
      top: 60px;
      right: 10px;
      bottom: 10px;
      width: 400px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      z-index: 9;
      border: 1px solid #333;
      display: none;
    }
    
    #debug-pane.visible {
      display: block;
    }
    
    #debug-pane .op {
      margin-bottom: 3px;
      padding: 2px 5px;
      color: #0f0;
    }
    
    #debug-pane .op:hover {
      background: rgba(0, 255, 0, 0.1);
    }
    
    @keyframes bell-flash {
      0% { background-color: rgba(255, 0, 0, 0.3); }
      100% { background-color: transparent; }
    }
    
    #input-container.bell {
      animation: bell-flash 0.15s ease-out;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="input-container">
    <div id="input-wrapper">
      <div id="input-background"></div>
      <input type="text" id="program-input" placeholder="Enter program (e.g., ABC!*D)" autofocus autocomplete="off">
    </div>
  </div>
  <div id="debug-pane"></div>

  <script type="module">
    import { runProgram, getParsedOperations } from './runtime.ts';
    import { characterDefs } from './character-defs.ts';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('program-input');
    const inputContainer = document.getElementById('input-container');
    const inputBackground = document.getElementById('input-background');
    const debugPane = document.getElementById('debug-pane');

    const isDebugMode = window.location.search.includes('debug');
    if (isDebugMode) {
      debugPane.classList.add('visible');
    }
    
    function visualBell() {
      inputContainer.classList.remove('bell');
      void inputContainer.offsetWidth;
      inputContainer.classList.add('bell');
    }
    
    function isValidChar(char) {
      return char in characterDefs;
    }

    function getProgramFromURL() {
      const path = window.location.pathname;
      const encoded = path === '/' ? '' : path.substring(1);
      return decodeURIComponent(encoded);
    }

    function updateURL(program) {
      const search = window.location.search;
      const newPath = program ? `/${encodeURIComponent(program)}${search}` : `/${search}`;
      const currentPath = `/${encodeURIComponent(getProgramFromURL())}${search}`;
      if (currentPath !== newPath) {
        window.history.pushState({ program }, '', newPath);
      }
    }

    function updateDebugPane(program) {
      if (!isDebugMode) return;
      
      const ops = getParsedOperations(program);
      
      let html = '';
      
      for (let i = ops.length - 1; i >= 0; i--) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        
        if (op.type === 'solid') {
          html += `<div class="op">[${i}] "${opChars}" initial-color(${op.color})</div>`;
        } else {
          const argsStr = op.args.length > 0 ? op.args.join(', ') : '';
          html += `<div class="op">[${i}] "${opChars}" ${op.fnDef.functionName}(${argsStr})</div>`;
        }
      }
      
      debugPane.innerHTML = html;
    }

    function updateInputColors(program) {
      const ops = getParsedOperations(program);
      const chars = program.split('').filter(c => c.charCodeAt(0) > 32 && c.charCodeAt(0) < 127);
      
      let html = '';
      let charIdx = 0;
      
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const prevIdentifier = i > 0 ? ops[i - 1].identifier : '';
        const opChars = op.identifier.substring(prevIdentifier.length);
        const numChars = opChars.length;
        
        let color = '#ffffff';
        if (op.type === 'solid') {
          color = op.color;
        } else {
          color = op.fnDef.color;
        }
        
        const bgColor = color + '40';
        
        for (let j = 0; j < numChars; j++) {
          if (charIdx < chars.length) {
            html += `<span style="background-color: ${bgColor};">${chars[charIdx]}</span>`;
            charIdx++;
          }
        }
      }
      
      inputBackground.innerHTML = html;
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      render();
    }

    function render() {
      const program = input.value || '';
      const images = runProgram(program, canvas.width, canvas.height);
      const finalImage = images[images.length - 1];
      
      const imageData = new ImageData(finalImage.data, finalImage.width, finalImage.height);
      ctx.putImageData(imageData, 0, 0);
      
      updateDebugPane(program);
      updateInputColors(program);
    }

    function loadProgramFromURL() {
      const program = getProgramFromURL();
      input.value = program;
      render();
    }

    window.addEventListener('resize', resize);
    
    input.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertText' && e.data) {
        const transformed = e.data.toUpperCase();
        let hasInvalid = false;
        
        for (const char of transformed) {
          if (!isValidChar(char)) {
            hasInvalid = true;
            break;
          }
        }
        
        if (hasInvalid) {
          e.preventDefault();
          visualBell();
          return;
        }
        
        if (transformed !== e.data) {
          e.preventDefault();
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const before = input.value.substring(0, start);
          const after = input.value.substring(end);
          input.value = before + transformed + after;
          input.selectionStart = input.selectionEnd = start + transformed.length;
          updateURL(input.value);
          render();
        }
      }
    });
    
    input.addEventListener('input', () => {
      updateURL(input.value);
      render();
    });

    window.addEventListener('popstate', (event) => {
      loadProgramFromURL();
    });
    
    loadProgramFromURL();
    resize();
  </script>
</body>
</html>
</eval-result-171933293249>}


---

# NEXT TASK!

Implement all the currently unimplemented functions

# THINKING

Signature: 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

Looking at the character-defs.ts file, I need to identify which functions are defined in the spec but not yet implemented. Let me compare the spec with what's in the file.

From the spec, these are all the functions that need to be implemented:
- `!` - hash pattern overlay
- `"` - horizontal bands with hue rotation
- `#` - grid lines
- `$` - golden spiral
- `%` - Floyd-Steinberg dither
- `&` - luminance from prev, hue/sat from old
- `'` - vertical streaks
- `(` - pinch distortion
- `)` - bulge distortion
- `*` - rays from center
- `+` - cross divides into quadrants
- `,` - stipple
- `-` - scanlines
- `.` - pointillism
- `/` - diagonal lines
- `0` - radial gradient
- `1` - center bar sharpened
- `2` - posterize with gradient map
- `3` - triple rotate strips
- `4` - quad rotate
- `5` - triangular tiling
- `6` - hexagonal pixelation
- `7` - hue rectangles
- `8` - lemniscate distortion
- `9` - blend modes
- `:` - circular zoom regions
- `;` - semicircle with reflection
- `=` - horizontal stripes shifted
- `?` - effect based on corner pixels
- `@` - sphere (WebGL)
- `A` - sphere (WebGL) - same as @
- `B` - voronoi blend
- `C` - concentric circles
- `D` - triangles colorized
- `E` - sinusoidal waves
- `F` - Julia fractal
- `G` - grayscale gradient map
- `H` - horizontal strips alternate
- `I` - invert + edge detect


- `J` - checkerboard blend
- `K` - kaleidoscope
- `L` - Lichtenberg figures
- `M` - spiral interleave
- `N` - XOR blend
- `O` - fisheye
- `P` - diagonal pixelate
- `Q` - diagonal split tile
- `R` - corrugated (WebGL)
- `S` - skew
- `T` - 3D cubes (WebGL)
- `U` - undulating wave
- `V` - vignette tint
- `W` - swirl
- `X` - shape overlay
- `Y` - radial

I'll continue tracking the remaining visual effect implementations, noting their unique transformations and potential complexity. Each symbol represents a distinct image manipulation technique that needs careful coding and rendering.

The next set of effects includes zoom blur, torn paper variations, diagonal lines, shift transformations, reflections, and WebGL-based distortions. Some intriguing additions like glitch effects and chromatic aberration suggest sophisticated visual processing capabilities.

Identifying gaps in the current character definitions reveals opportunities for expanding the visual effect library, particularly around specialized transformations like circular zoom regions and corner-pixel-based effects.

I notice potential implementation discrepancies between specified behaviors and actual code, particularly around blend modes, wave patterns, and signature definitions. These variations could impact the intended visual rendering and require careful reconciliation with the original specifications.

The range of effects spans geometric manipulations, optical distortions, and computational image transformations, indicating a complex and nuanced approach to visual rendering techniques.

Specific function mappings between symbols and their implementations reveal unexpected routing and potential misalignments with original design intentions, suggesting a need for systematic review and potential refactoring.

The current configuration shows function assignments that deviate from expected specifications: D is linked to a drip function when it should generate triangular subdivisions, while 5 is connected to a triangle generation function when it's meant for triangular tiling.

Careful examination of the specification highlights nuanced requirements for each symbol's behavior, particularly around triangle generation, colorization strategies, and sampling techniques that aren't currently matching the implemented functions.

Documentation labels further complicate the picture, suggesting an intended mapping different from the actual implementation, with potential misalignments between function names, documentation, and actual code behavior.

I'll systematically address the implementation gaps by creating missing character functions. The list includes diverse visual effects like zoom regions, reflections, stripes, pixel-based transformations, and geometric manipulations across circular, linear, and distortion-based techniques.

Key priorities involve implementing these placeholder functions with precise visual characteristics, ensuring each character's transformation matches its intended graphical representation. The goal is a comprehensive set of visual effect generators that can be consistently applied across the system.

Critical corrections are needed for blend mode implementations, particularly for characters `9` and `N`, where current functions do not match their specified behaviors. The core issue involves swapped function meanings - `fn9` and `fnN` are currently misaligned with their intended specifications.

I'll need to carefully map each function's actual output against its documented behavior, especially focusing on XOR operations, blend modes, and specific visual transformations like sinusoidal waves and Lichtenberg figures.

Specific refactoring targets include:
- Correcting blend mode logic
- Implementing XOR operations accurately
- Developing wave and electrical discharge simulations
- Ensuring function signatures match specifications

The blend mode implementation for `9` requires supporting nine distinct blending techniques when combining an image with itself, which diverges significantly from the current XOR approach.

I'll focus on implementing the missing character functions systematically. These include `:`, `;`, `=`, `?`, `@`, `[`, `\`, and `]`. Each will need a carefully designed function matching the specification.

The priority is implementing the unaddressed characters while ensuring the existing code maintains its core functionality. I'll methodically work through each missing character, creating appropriate image manipulation functions that align with the expected behavior.

The current implementation needs careful review to confirm it matches the original specifications for characters like `9` and `N`. Precise alignment with the defined transformations is crucial for maintaining the integrity of the image processing system.

# ASSISTANT

Looking at the character-defs.ts file, I need to identify and implement the missing functions. Let me first check what's defined in the spec but not in the characterDefs object.

# TOOL USE

Name: ripgrep
ID: toolu_01JHo8bh9fWzKzQ19SXV3ThJ

## pattern

<tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>
^  '[:\;\=\?\@\[\\\]\`\_\{\|\}\~]':
</tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>

## path

<tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>
character-defs.ts
</tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>

# TOOL RESULT

ID: toolu_01JHo8bh9fWzKzQ19SXV3ThJ

<tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>
No matches found
</tool.toolu_01JHo8bh9fWzKzQ19SXV3ThJ>

# TOOL USE

Name: read-file
ID: toolu_01PD8ZB5Po3sz15EEzkSvYSX

## path

<tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>
character-defs.ts
</tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>

## start-line

<tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>
1700
</tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>

# TOOL RESULT

ID: toolu_01PD8ZB5Po3sz15EEzkSvYSX

<tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>
      const localX = x - stripWidth * 2;
      const srcX = Math.floor(((ctx.height - 1 - y) / ctx.height) * (ctx.width - stripWidth * 2) + stripWidth * 2);
      const srcY = Math.floor((localX / (ctx.width - stripWidth * 2)) * ctx.height);
      const [r, g, b] = getPixel(prev, srcX, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn4(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = Math.floor(ctx.width / 2);
  const hh = Math.floor(ctx.height / 2);
  
  const rotatePoint = (x: number, y: number, cx: number, cy: number, angle: number): [number, number] => {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
  };
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const qx = x < hw ? 0 : 1;
      const qy = y < hh ? 0 : 1;
      const quadrant = qy * 2 + qx;
      const angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2];
      const angle = angles[quadrant];
      
      const localCx = qx === 0 ? hw / 2 : hw + hw / 2;
      const localCy = qy === 0 ? hh / 2 : hh + hh / 2;
      
      const [srcX, srcY] = rotatePoint(x, y, localCx, localCy, -angle);
      const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn5(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const gl = initWebGL(ctx.width, ctx.height);
  
  const numDrips = Math.max(1, n * 3);
  const dripStrength = Math.max(0.5, Math.min(n * 0.2 + 0.8, 2.0));
  const seed = ctx.images.length * 137.5;
  
  const vertexShader = `
    attribute vec2 position;
    varying vec2 vUV;
    void main() {
      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;
  
  const fragmentShader = `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uResolution;
    uniform float uStrength;
    uniform int uNumDrips;
    uniform float uSeed;
    varying vec2 vUV;
    
    #define MAX_DRIPS 100
    #define MAX_STEPS 64
    #define WALL_Z 0.0
    #define EPS 0.001
    
    float hash(float n) {
      return fract(sin(n) * 43758.5453123);
    }
    
    // Smooth min for organic blending
    float smin(float a, float b, float k) {
      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
      return mix(b, a, h) - k * h * (1.0 - h);
    }
    
    // Simple sphere SDF
    float sdSphere(vec3 p, vec3 center, float r) {
      return length(p - center) - r;
    }
    
    // Scene SDF - randomly distributed clusters of 4 metaballs each
    float sceneSDF(vec3 p, int numClusters, float strength) {
      float d = 1000.0;
      
      for (int i = 0; i < MAX_DRIPS; i++) {
        if (i >= numClusters) break;
        
        float fi = float(i);
        
        // Random cluster center position across full screen (seeded by image count)
        float clusterX = (hash(fi * 127.1 + uSeed) * 2.0 - 1.0) * 1.5;
        float clusterY = (hash(fi * 311.7 + uSeed) * 2.0 - 1.0) * 1.2;
        
        // Cluster size
        float clusterSize = 0.15 + hash(fi * 74.3 + uSeed) * 0.15;
        
        // 4 balls per cluster (fixed to avoid dynamic loop issues)
        for (int j = 0; j < 4; j++) {
          float fj = float(j);
          float localSeed = fi * 100.0 + fj + uSeed;
          
          // Random offset from cluster center
          float offX = (hash(localSeed * 123.4) - 0.5) * clusterSize;
          float offY = (hash(localSeed * 234.5) - 0.5) * clusterSize * 1.5; // More vertical spread
          
          float x = clusterX + offX;
          float y = clusterY + offY;
          
          // Varying ball sizes within cluster
          float r = (0.06 + hash(localSeed * 345.6) * 0.08) * strength * 0.6;
          
          float z = 0.05 + r * 0.3;
          
          vec3 center = vec3(x, y, z);
          float sphere = sdSphere(p, center, r);
          
          // Smooth blend to merge balls in cluster
          d = smin(d, sphere, 0.12);
        }
      }
      
      return d;
    }
    
    // Calculate normal via gradient
    vec3 calcNormal(vec3 p, int numDrips, float strength) {
      vec2 e = vec2(0.001, 0.0);
      return normalize(vec3(
        sceneSDF(p + e.xyy, numDrips, strength) - sceneSDF(p - e.xyy, numDrips, strength),
        sceneSDF(p + e.yxy, numDrips, strength) - sceneSDF(p - e.yxy, numDrips, strength),
        sceneSDF(p + e.yyx, numDrips, strength) - sceneSDF(p - e.yyx, numDrips, strength)
      ));
    }
    
    void main() {
      vec2 uv = vUV;
      float aspect = uResolution.x / uResolution.y;
      
      // Ray origin and direction (orthographic-ish camera)
      vec3 ro = vec3((uv.x * 2.0 - 1.0) * aspect, uv.y * 2.0 - 1.0, 2.0);
      vec3 rd = vec3(0.0, 0.0, -1.0);
      
      // Raymarch to find metaball surface
      float t = 0.0;
      float d = 0.0;
      bool hit = false;
      vec3 p;
      
      for (int i = 0; i < MAX_STEPS; i++) {
        p = ro + rd * t;
        d = sceneSDF(p, uNumDrips, uStrength);
        
        if (d < EPS) {
          hit = true;
          break;
        }
        if (t > 4.0) break;
        
        t += d * 0.8;
      }
      
      // Sample wall texture
      vec4 wallColor = texture2D(uTexture, uv);
      
      if (hit) {
        vec3 normal = calcNormal(p, uNumDrips, uStrength);
        
        // Light from top (Y is flipped in screen coords)
        vec3 lightDir = normalize(vec3(0.0, -1.0, 0.6));
        vec3 viewDir = -rd;
        
        // Fresnel - edges reflect more
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
        
        // Specular highlight - bright and sharp
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 120.0);
        
        // Refraction - water has IOR ~1.33, so ratio is 1.0/1.33 ≈ 0.75
        vec3 refracted = refract(rd, normal, 0.75);
        vec2 refractUV = uv + refracted.xy * 0.06;
        refractUV = clamp(refractUV, 0.0, 1.0);
        vec4 refractColor = texture2D(uTexture, refractUV);
        
        // Clear water droplet - mostly shows refracted background
        vec3 dropletColor = refractColor.rgb;
        
        // Slight caustic brightening where light focuses
        float caustic = max(dot(normal, lightDir), 0.0);
        dropletColor *= 1.0 + caustic * 0.15;
        
        // Add crisp specular highlight
        dropletColor += vec3(1.0) * spec * 1.5;
        
        // Subtle rim highlight from fresnel
        dropletColor += vec3(1.0) * fresnel * 0.2;
        
        // Very subtle shadow directly under droplet on wall
        vec2 shadowUV = uv + vec2(0.01, 0.02);
        float shadowMask = smoothstep(0.05, 0.0, d) * 0.15;
        vec3 wallWithShadow = wallColor.rgb * (1.0 - shadowMask);
        
        // Droplet is almost fully transparent, just refracts
        gl_FragColor = vec4(dropletColor, 1.0);
      } else {
        gl_FragColor = wallColor;
      }
    }
  `;
  
  const program = createShaderProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  
  const positionLoc = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uStrength'), dripStrength);
  gl.uniform1i(gl.getUniformLocation(program, 'uNumDrips'), numDrips);
  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
  
  gl.viewport(0, 0, ctx.width, ctx.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  
  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
      const dstIdx = (y * ctx.width + x) * 4;
      flipped[dstIdx] = pixels[srcIdx];
      flipped[dstIdx + 1] = pixels[srcIdx + 1];
      flipped[dstIdx + 2] = pixels[srcIdx + 2];
      flipped[dstIdx + 3] = pixels[srcIdx + 3];
    }
  }
  
  gl.deleteTexture(texture);
  gl.deleteBuffer(buffer);
  gl.deleteProgram(program);
  
  return { width: ctx.width, height: ctx.height, data: flipped };
}

function fn6(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hexRadius = Math.max(3, n * 2 + 3);
  const hexWidth = hexRadius * 2;
  const hexHeight = hexRadius * Math.sqrt(3);
  
  const pixelToHex = (px: number, py: number): [number, number] => {
    const q = (2 / 3 * px) / hexRadius;
    const r = (-1 / 3 * px + Math.sqrt(3) / 3 * py) / hexRadius;
    return [q, r];
  };
  
  const hexRound = (q: number, r: number): [number, number] => {
    const s = -q - r;
    let rq = Math.round(q);
    let rr = Math.round(r);
    let rs = Math.round(s);
    
    const qDiff = Math.abs(rq - q);
    const rDiff = Math.abs(rr - r);
    const sDiff = Math.abs(rs - s);
    
    if (qDiff > rDiff && qDiff > sDiff) {
      rq = -rr - rs;
    } else if (rDiff > sDiff) {
      rr = -rq - rs;
    }
    
    return [rq, rr];
  };
  
  const hexToPixel = (q: number, r: number): [number, number] => {
    const x = hexRadius * (3 / 2 * q);
    const y = hexRadius * (Math.sqrt(3) / 2 * q + Math.sqrt(3) * r);
    return [x, y];
  };
  
  const hexAverages = new Map<string, [number, number, number, number]>();
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [q, r] = pixelToHex(x, y);
      const [hq, hr] = hexRound(q, r);
      const key = `${hq},${hr}`;
      
      const [pr, pg, pb] = getPixel(prev, x, y);
      
      if (!hexAverages.has(key)) {
        hexAverages.set(key, [0, 0, 0, 0]);
      }
      const avg = hexAverages.get(key)!;
      avg[0] += pr;
      avg[1] += pg;
      avg[2] += pb;
      avg[3]++;
    }
  }
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [q, r] = pixelToHex(x, y);
      const [hq, hr] = hexRound(q, r);
      const key = `${hq},${hr}`;
      
      const [centerX, centerY] = hexToPixel(hq, hr);
      const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
      
      const avg = hexAverages.get(key);
      if (avg && avg[3] > 0) {
        const ar = Math.round(avg[0] / avg[3]);
        const ag = Math.round(avg[1] / avg[3]);
        const ab = Math.round(avg[2] / avg[3]);
        
        if (dist > hexRadius - 1.5) {
          setPixel(out, x, y, Math.max(0, ar - 30), Math.max(0, ag - 30), Math.max(0, ab - 30));
        } else {
          setPixel(out, x, y, ar, ag, ab);
        }
      }
    }
  }
  
  return out;
}

function fn7(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRects = Math.max(1, Math.min(n, 20));
  
  for (let i = 1; i <= numRects; i++) {
    const rx = Math.floor(i * ctx.width / (numRects + 2));
    const ry = Math.floor(i * ctx.height / (numRects + 4));
    const rw = Math.floor(ctx.width / (numRects + 2));
    const rh = Math.floor(ctx.height / (numRects + 4));
    
    const hueRotation = (i * 360 / numRects);
    
    for (let y = ry; y < ry + rh && y < ctx.height; y++) {
      for (let x = rx; x < rx + rw && x < ctx.width; x++) {
        const [r, g, b] = getPixel(prev, x, y);
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + hueRotation) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fn8(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = Math.max(0.1, n / 5);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const scale = Math.min(ctx.width, ctx.height) / 4;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const nx = (x - cx) / scale;
      const ny = (y - cy) / scale;
      
      const r2 = nx * nx + ny * ny;
      const denom = r2 + 1;
      
      const lemnX = nx * (r2 - 1) / denom;
      const lemnY = ny * (r2 + 1) / denom;
      
      const sx = cx + (nx + (lemnX - nx) * strength * 0.3) * scale;
      const sy = cy + (ny + (lemnY - ny) * strength * 0.3) * scale;
      
      const [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fn9(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r1, g1, b1] = getPixel(prev, x, y);
      const [r2, g2, b2] = getPixel(old, x, y);
      
      setPixel(out, x, y, r1 ^ r2, g1 ^ g2, b1 ^ b2);
    }
  }
  
  return out;
}

function fnLessThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = (x + shift) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnGreaterThan(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.width / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcX = ((x - shift) % ctx.width + ctx.width) % ctx.width;
      const [r, g, b] = getPixel(prev, srcX, y);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnCaret(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const shift = Math.floor(ctx.height / 3);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const srcY = (y + shift) % ctx.height;
      const [r, g, b] = getPixel(prev, x, srcY);
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnExclaim(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const opacity = 0.3;
  const factor = n + 17;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
      out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
      out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
    }
  }
  
  return out;
}

function fnDoubleQuote(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const bands = Math.max(2, n);
  const bandHeight = ctx.height / bands;
  
  for (let y = 0; y < ctx.height; y++) {
    const bandIdx = Math.floor(y / bandHeight);
    const isOdd = bandIdx % 2 === 1;
    
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      
      if (isOdd) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
        setPixel(out, x, y, nr, ng, nb);
      } else {
        const [h, s, l] = rgbToHsl(r, g, b);
        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
        setPixel(out, x, y, nr, ng, nb);
      }
    }
  }
  
  return out;
}

function fnHash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  const gridSpacing = 20;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const thickness = 1 + Math.sin(x * y * 0.01) * 3;
      const nearHorizontal = (y % gridSpacing) < thickness;
      const nearVertical = (x % gridSpacing) < thickness;
      
      if (nearHorizontal || nearVertical) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnDollar(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const turns = Math.max(1, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.min(cx, cy) * 0.9;
  const phi = (1 + Math.sqrt(5)) / 2;
  const totalAngle = turns * Math.PI * 2;
  const steps = turns * 200;
  
  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const angle = t * totalAngle;
    const r = maxR * Math.pow(phi, angle / (Math.PI * 2) - turns + 1);
    
    if (r < 1 || r > maxR) continue;
    
    const x = Math.floor(cx + r * Math.cos(angle));
    const y = Math.floor(cy + r * Math.sin(angle));
    
    if (x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const brightness = (pr + pg + pb) / 3;
      const invBrightness = 255 - brightness;
      
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          if (dx * dx + dy * dy <= 4) {
            setPixel(out, x + dx, y + dy, invBrightness, invBrightness, invBrightness);
          }
        }
      }
    }
  }
  
  return out;
}

function fnPercent(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const cellSize = Math.max(1, n + 1);
  const corners = [
    getPixel(prev, 0, 0),
    getPixel(prev, ctx.width - 1, 0),
    getPixel(prev, 0, ctx.height - 1),
    getPixel(prev, ctx.width - 1, ctx.height - 1)
  ];
  const palette = corners.map(([r, g, b]) => [r, g, b] as [number, number, number]);
  
  const findClosest = (r: number, g: number, b: number): [number, number, number] => {
    let minDist = Infinity;
    let closest = palette[0];
    for (const [pr, pg, pb] of palette) {
      const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
      if (dist < minDist) {
        minDist = dist;
        closest = [pr, pg, pb];
      }
    }
    return closest;
  };
  
  const tempData = new Float32Array(ctx.width * ctx.height * 3);
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const idx = (y * ctx.width + x) * 3;
      tempData[idx] = r;
      tempData[idx + 1] = g;
      tempData[idx + 2] = b;
    }
  }
  
  for (let y = 0; y < ctx.height; y += cellSize) {
    for (let x = 0; x < ctx.width; x += cellSize) {
      const idx = (y * ctx.width + x) * 3;
      const oldR = tempData[idx];
      const oldG = tempData[idx + 1];
      const oldB = tempData[idx + 2];
      
      const [newR, newG, newB] = findClosest(oldR, oldG, oldB);
      
      for (let cy = 0; cy < cellSize && y + cy < ctx.height; cy++) {
        for (let cx = 0; cx < cellSize && x + cx < ctx.width; cx++) {
          setPixel(out, x + cx, y + cy, newR, newG, newB);
        }
      }
      
      const errR = oldR - newR;
      const errG = oldG - newG;
      const errB = oldB - newB;
      
      const distribute = (dx: number, dy: number, factor: number) => {
        const nx = x + dx * cellSize;
        const ny = y + dy * cellSize;
        if (nx >= 0 && nx < ctx.width && ny >= 0 && ny < ctx.height) {
          const nidx = (ny * ctx.width + nx) * 3;
          tempData[nidx] += errR * factor;
          tempData[nidx + 1] += errG * factor;
          tempData[nidx + 2] += errB * factor;
        }
      };
      
      distribute(1, 0, 7 / 16);
      distribute(-1, 1, 3 / 16);
      distribute(0, 1, 5 / 16);
      distribute(1, 1, 1 / 16);
    }
  }
  
  return out;
}

function fnAmpersand(ctx: FnContext, j: number): Image {
  const prev = getPrevImage(ctx);
  const old = getOldImage(ctx, j);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [pr, pg, pb] = getPixel(prev, x, y);
      const [or, og, ob] = getPixel(old, x, y);
      
      const luminance = pr * 0.299 + pg * 0.587 + pb * 0.114;
      const [oh, os, ol] = rgbToHsl(or, og, ob);
      const [nr, ng, nb] = hslToRgb(oh, os, luminance / 255);
      
      setPixel(out, x, y, nr, ng, nb);
    }
  }
  
  return out;
}

function fnApostrophe(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const spacing = n + 2;
  
  for (let x = 0; x < ctx.width; x++) {
    if (x % spacing !== 0) continue;
    
    let colLuminance = 0;
    for (let y = 0; y < ctx.height; y++) {
      const [r, g, b] = getPixel(prev, x, y);
      colLuminance += r * 0.299 + g * 0.587 + b * 0.114;
    }
    colLuminance /= ctx.height;
    
    const streakLength = Math.floor((colLuminance / 255) * 100);
    const startY = 0;
    
    for (let y = startY; y < startY + streakLength && y < ctx.height; y++) {
      const idx = (y * ctx.width + x) * 4;
      out.data[idx] = Math.min(255, Math.round(out.data[idx] * 0.5 + 127));
      out.data[idx + 1] = Math.min(255, Math.round(out.data[idx + 1] * 0.5 + 127));
      out.data[idx + 2] = Math.min(255, Math.round(out.data[idx + 2] * 0.5 + 127));
    }
  }
  
  return out;
}

function fnOpenParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const pinchFactor = 1 + strength * (1 - normDist);
      const sx = cx + dx * pinchFactor;
      const sy = cy + dy * pinchFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const brighten = (1 - normDist) * strength * 30;
      r = Math.min(255, r + brighten);
      g = Math.min(255, g + brighten);
      b = Math.min(255, b + brighten);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnCloseParen(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const strength = n / 10;
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const normDist = dist / maxR;
      
      const bulgeFactor = 1 - strength * normDist * 0.5;
      const sx = cx + dx * bulgeFactor;
      const sy = cy + dy * bulgeFactor;
      
      let [r, g, b] = getPixel(prev, Math.floor(sx), Math.floor(sy));
      
      const darken = normDist * strength * 50;
      r = Math.max(0, r - darken);
      g = Math.max(0, g - darken);
      b = Math.max(0, b - darken);
      
      setPixel(out, x, y, Math.round(r), Math.round(g), Math.round(b));
    }
  }
  
  return out;
}

function fnAsterisk(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  
  const numRays = Math.max(2, n);
  const cx = ctx.width / 2;
  const cy = ctx.height / 2;
  const maxR = Math.sqrt(cx * cx + cy * cy);
  const opacity = 0.6;
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;
      
      const rayAngle = (Math.PI * 2) / numRays;
      const nearestRay = Math.round(angle / rayAngle) * rayAngle;
      const angleDiff = Math.abs(angle - nearestRay);
      
      const rayWidth = 0.05;
      if (angleDiff < rayWidth) {
        const softness = 1 - angleDiff / rayWidth;
        const sampleX = Math.floor(cx + Math.cos(nearestRay) * (ctx.width / numRays));
        const [sr, sg, sb] = getPixel(prev, sampleX, Math.floor(cy));
        
        const idx = (y * ctx.width + x) * 4;
        const blend = softness * opacity;
        out.data[idx] = Math.round(out.data[idx] * (1 - blend) + sr * blend);
        out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - blend) + sg * blend);
        out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - blend) + sb * blend);
      }
    }
  }
  
  return out;
}

function fnPlus(ctx: FnContext): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  
  const hw = ctx.width / 2;
  const hh = ctx.height / 2;
  
  const sharpenKernel = [
    [0, -1, 0],
    [-1, 5, -1],
    [0, -1, 0]
  ];
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const inTopLeft = x < hw && y < hh;
      const inBottomRight = x >= hw && y >= hh;
      const shouldSharpen = inTopLeft || inBottomRight;
      
      if (shouldSharpen) {
        let sr = 0, sg = 0, sb = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            const weight = sharpenKernel[ky + 1][kx + 1];
            sr += pr * weight;
            sg += pg * weight;
            sb += pb * weight;
          }
        }
        setPixel(out, x, y,
          Math.max(0, Math.min(255, Math.round(sr))),
          Math.max(0, Math.min(255, Math.round(sg))),
          Math.max(0, Math.min(255, Math.round(sb)))
        );
      } else {
        let sr = 0, sg = 0, sb = 0;
        const radius = 2;
        let count = 0;
        for (let ky = -radius; ky <= radius; ky++) {
          for (let kx = -radius; kx <= radius; kx++) {
            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
            sr += pr;
            sg += pg;
            sb += pb;
            count++;
          }
        }
        setPixel(out, x, y,
          Math.round(sr / count),
          Math.round(sg / count),
          Math.round(sb / count)
        );
      }
    }
  }
  
  return out;
}

function fnComma(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = Math.floor(r * 0.299 + g * 0.587 + b * 0.114);
      const divisor = 1 + Math.floor(luminance / 32);
      
      if ((x * 13 + y * 7) % divisor === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

function fnMinus(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const spacing = Math.max(2, n);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      let [r, g, b] = getPixel(prev, x, y);
      
      if (y % spacing === 0) {
        r = Math.floor(r * 0.5);
        g = Math.floor(g * 0.5);
        b = Math.floor(b * 0.5);
      }
      
      if (y % (spacing * 2) === 0) {
        const srcY = Math.max(0, y - spacing);
        [r, g, b] = getPixel(prev, x, srcY);
      }
      
      setPixel(out, x, y, r, g, b);
    }
  }
  
  return out;
}

function fnDot(ctx: FnContext, n: number): Image {
  const prev = getPrevImage(ctx);
  const out = createSolidImage(ctx.width, ctx.height, '#000000');
  const radius = (n % 8) + 2;
  const diameter = radius * 2;
  
  for (let cy = radius; cy < ctx.height; cy += diameter) {
    for (let cx = radius; cx < ctx.width; cx += diameter) {
      const [r, g, b] = getPixel(prev, cx, cy);
      const [h, s, l] = rgbToHsl(r, g, b);
      const [nr, ng, nb] = hslToRgb(h, Math.min(1, s + 0.1), l);
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx * dx + dy * dy <= radius * radius) {
            setPixel(out, cx + dx, cy + dy, nr, ng, nb);
          }
        }
      }
    }
  }
  
  return out;
}

function fnSlash(ctx: FnContext, c: string): Image {
  const prev = getPrevImage(ctx);
  const out = cloneImage(prev);
  const [cr, cg, cb] = hexToRgb(c);
  
  for (let y = 0; y < ctx.height; y++) {
    for (let x = 0; x < ctx.width; x++) {
      const [r, g, b] = getPixel(prev, x, y);
      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
      
      const diag = (x + y) % spacing;
      if (diag === 0) {
        setPixel(out, x, y, cr, cg, cb);
      }
    }
  }
  
  return out;
}

export const characterDefs: Record<string, CharDef> = {
  'A': {
    color: '#78A10F',
    number: 1,
    fn: fnA,
    arity: 0,
    argTypes: [],
    functionName: "sphere-overlay",
    documentation: "Renders prev as texture on two 3D spheres with lighting in top-right and bottom-left quadrants"
  },
  
  'B': {
    color: '#8B4513',
    number: 2,
    fn: fnB,
    arity: 1,
    argTypes: ['int'],
    functionName: "voronoi-blend",
    documentation: "Breaks image into 36 voronoi cells, alternating between prev and old image"
  },
  
  'C': {
    color: '#FF6B35',
    number: 3,
    fn: fnC,
    arity: 1,
    argTypes: ['int'],
    functionName: "concentric-hue",
    documentation: "Creates n concentric circles alternating between original and hue-shifted versions"
  },
  
  'D': {
    color: '#FF1493',
    number: 4,
    fn: fn5,
    arity: 1,
    argTypes: ['int'],
    functionName: "drip",
    documentation: "Metaball-based dripping effect with blobby liquid drips, n controls number and strength"
  },
  
  'E': {
    color: '#00CED1',
    number: 5,
    fn: fnE,
    arity: 1,
    argTypes: ['int'],
    functionName: "eclipse",
    documentation: "Solar eclipse - corona color from prev, old_image shown in moon center"
  },
  
  'F': {
    color: '#FFD700',
    number: 6,
    fn: fnF,
    arity: 1,
    argTypes: ['int'],
    functionName: "julia-fractal",
    documentation: "Draws Julia set fractal using prev's center pixel as c parameter, screen blended"
  },
  
  'G': {
    color: '#9370DB',
    number: 7,
    fn: fnG,
    arity: 1,
    argTypes: ['int'],
    functionName: "grayscale-colorize",
    documentation: "Converts to grayscale then applies n-color rainbow palette based on brightness"
  },
  
  'H': {
    color: '#DC143C',
    number: 8,
    fn: fnH,
    arity: 1,
    argTypes: ['int'],
    functionName: "horizontal-strips",
    documentation: "Horizontal strips alternate between prev and old_image, strip height varies with sin"
  },
  
  'I': {
    color: '#00FF7F',
    number: 9,
    fn: fnI,
    arity: 0,
    argTypes: [],
    functionName: "invert-edges",
    documentation: "Inverts prev colors, then applies Sobel edge detection and draws edges in white"
  },
  
  'J': {
    color: '#FF8C00',
    number: 10,
    fn: fnJ,
    arity: 1,
    argTypes: ['int'],
    functionName: "variable-checkerboard",
    documentation: "Checkerboard blend where square size increases from top-left (2px) to bottom-right (52px)"
  },
  
  'K': {
    color: '#4B0082',
    number: 11,
    fn: fnK,
    arity: 1,
    argTypes: ['int'],
    functionName: "kaleidoscope",
    documentation: "Creates n-way kaleidoscope effect centered on image with 1.1x zoom"
  },
  
  'L': {
    color: '#20B2AA',
    number: 12,
    fn: fnL,
    arity: 0,
    argTypes: [],
    functionName: "lissajous",
    documentation: "Draws Lissajous curves spanning the image with black to white diagonal gradient"
  },
  
  'M': {
    color: '#FF69B4',
    number: 13,
    fn: fnM,
    arity: 2,
    argTypes: ['int', 'int'],
    functionName: "spiral-interleave",
    documentation: "Interleaves prev and old_image in jagged pixelated spiral, spiral effect (5-100), old image index"
  },
  
  'N': {
    color: '#8A2BE2',
    number: 14,
    fn: fnN,
    arity: 0,
    argTypes: [],
    functionName: "neon",
    documentation: "Neon glow effect - edges glow in their original hue, scattered light points add ambiance"
  },
  
  'O': {
    color: '#FF6347',
    number: 15,
    fn: fnO,
    arity: 1,
    argTypes: ['int'],
    functionName: "fisheye-morph",
    documentation: "Fisheye distortion that brightens center and darkens edges with strength n"
  },
  
  'P': {
    color: '#4682B4',
    number: 16,
    fn: fnP,
    arity: 1,
    argTypes: ['int'],
    functionName: "diagonal-pixelate",
    documentation: "Pixelates with cell size n+1, diagonal split: top-left = average, bottom-right = most saturated"
  },
  
  'Q': {
    color: '#32CD32',
    number: 17,
    fn: fnQ,
    arity: 0,
    argTypes: [],
    functionName: "inverted-tile",
    documentation: "Splits prev diagonally, inverts bottom-right half, then tiles in four quadrants"
  },
  
  'R': {
    color: '#DA70D6',
    number: 18,
    fn: fnR,
    arity: 0,
    argTypes: [],
    functionName: "corrugated",
    documentation: "Image transformed with sinusoidal shape in z dimension, looks vertically corrugated"
  },
  
  'S': {
    color: '#87CEEB',
    number: 19,
    fn: fnS,
    arity: 0,
    argTypes: [],
    functionName: "skew",
    documentation: "Skews image 20 degrees with wraparound"
  },
  
  'T': {
    color: '#F0E68C',
    number: 20,
    fn: fnT,
    arity: 1,
    argTypes: ['int'],
    functionName: "cubes",
    documentation: "3D cubes emerge from image in deterministic chaotic patterns, light from top-right"
  },
  
  'U': {
    color: '#DDA0DD',
    number: 21,
    fn: fnU,
    arity: 1,
    argTypes: ['int'],
    functionName: "undulate",
    documentation: "Vertical wave distortion with amplitude n*5px, frequency n cycles, phase based on luminance"
  },
  
  'V': {
    color: '#40E0D0',
    number: 22,
    fn: fnV,
    arity: 1,
    argTypes: ['color'],
    functionName: "vignette-tint",
    documentation: "Vignette with radius 0.7, darkened edges tinted toward color c"
  },
  
  'W': {
    color: '#EE82EE',
    number: 23,
    fn: fnW,
    arity: 1,
    argTypes: ['int'],
    functionName: "swirl",
    documentation: "Swirl distortion from center, rotation = n*45°, quadratic falloff"
  },
  
  'X': {
    color: '#F5DEB3',
    number: 24,
    fn: fnX,
    arity: 2,
    argTypes: ['int', 'color'],
    functionName: "shape-overlay",
    documentation: "Draws unicode shape k%64 at center in color c (★●■▲◆♥✦⬡✚◐☽⚡∞☀✿⬢...)"
  },
  
  'Y': {
    color: '#98FB98',
    number: 25,
    fn: fnY,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-hue",
    documentation: "Splits into n radial sections, each hue-rotated by i*(360/n)°"
  },
  
  'Z': {
    color: '#AFEEEE',
    number: 26,
    fn: fnZ,
    arity: 1,
    argTypes: ['int'],
    functionName: "zoom-blur",
    documentation: "Radial motion blur from center, blur amount n*4px, center 20% stays sharp"
  },
  
  '0': {
    color: '#E6E6FA',
    number: 27,
    fn: fn0,
    arity: 1,
    argTypes: ['int'],
    functionName: "radial-light",
    documentation: "Radial gradient from center (white) to edges (black) multiplied with prev at n*10% opacity, then added back"
  },
  
  '1': {
    color: '#FFA07A',
    number: 28,
    fn: fn1,
    arity: 0,
    argTypes: [],
    functionName: "center-bar",
    documentation: "Middle third of image shows prev sharpened and contrast-boosted, rest is desaturated"
  },
  
  '2': {
    color: '#98D8C8',
    number: 29,
    fn: fn2,
    arity: 0,
    argTypes: [],
    functionName: "time-echo",
    documentation: "Left third shows 3rd previous image, middle shows 2nd previous, right shows prev - recent history triptych"
  },
  
  '3': {
    color: '#F7DC6F',
    number: 30,
    fn: fn3,
    arity: 0,
    argTypes: [],
    functionName: "triple-rotate",
    documentation: "Divides into 3 vertical strips; left rotated 90° CW, middle unchanged, right rotated 90° CCW"
  },
  
  '4': {
    color: '#BB8FCE',
    number: 31,
    fn: fn4,
    arity: 0,
    argTypes: [],
    functionName: "quad-rotate",
    documentation: "Divides into 2x2 quadrants, each rotated (0°, 90°, 180°, 270°)"
  },
  
  '5': {
    color: '#85C1E9',
    number: 32,
    fn: fnD,
    arity: 1,
    argTypes: ['int'],
    functionName: "triangular-split",
    documentation: "Splits prev into (n+1)² triangles, each colorized with a hue based on its index"
  },
  
  '6': {
    color: '#F1948A',
    number: 33,
    fn: fn6,
    arity: 1,
    argTypes: ['int'],
    functionName: "hexagonal-pixelate",
    documentation: "Hexagonal pixelation with cell radius n*5, filled with region's average color, edges 1px darker"
  },
  
  '7': {
    color: '#82E0AA',
    number: 34,
    fn: fn7,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-rectangles",
    documentation: "n rectangles placed diagonally, each filled with prev hue-rotated by i*(360/n)°"
  },
  
  '8': {
    color: '#F8C471',
    number: 35,
    fn: fn8,
    arity: 1,
    argTypes: ['int'],
    functionName: "lemniscate",
    documentation: "Infinity-loop/lemniscate distortion centered on image with strength n/5, pixels flow along curve"
  },
  
  '9': {
    color: '#D7BDE2',
    number: 36,
    fn: fn9,
    arity: 1,
    argTypes: ['int'],
    functionName: "xor-blend",
    documentation: "XORs prev with old_image at index j, creating glitchy digital artifacts"
  },
  
  '<': {
    color: '#E74C3C',
    number: 37,
    fn: fnLessThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-left",
    documentation: "Shifts prev 1/3 of the width to the left with wraparound"
  },
  
  '>': {
    color: '#3498DB',
    number: 38,
    fn: fnGreaterThan,
    arity: 0,
    argTypes: [],
    functionName: "shift-right",
    documentation: "Shifts prev 1/3 of the width to the right with wraparound"
  },
  
  '^': {
    color: '#2ECC71',
    number: 39,
    fn: fnCaret,
    arity: 0,
    argTypes: [],
    functionName: "shift-up",
    documentation: "Shifts prev 1/3 of the height up with wraparound"
  },
  
  '!': {
    color: '#FF4500',
    number: 40,
    fn: fnExclaim,
    arity: 1,
    argTypes: ['int'],
    functionName: "hash-overlay",
    documentation: "Overlays deterministic hash pattern where brightness = ((x*(n+17)) ^ (y*31) ^ (x*y)) % 256 at 30% opacity"
  },
  
  '"': {
    color: '#9932CC',
    number: 41,
    fn: fnDoubleQuote,
    arity: 1,
    argTypes: ['int'],
    functionName: "band-transform",
    documentation: "Splits into n horizontal bands; odd bands hue-rotated 180°, even bands have saturation inverted"
  },
  
  '#': {
    color: '#228B22',
    number: 42,
    fn: fnHash,
    arity: 1,
    argTypes: ['color'],
    functionName: "grid-lines",
    documentation: "Draws grid of lines in color c with thickness = 1 + sin(x*y*0.01) * 3"
  },
  
  '$': {
    color: '#FFD700',
    number: 43,
    fn: fnDollar,
    arity: 1,
    argTypes: ['int'],
    functionName: "golden-spiral",
    documentation: "Draws golden spiral with n turns from center, spiral color is brightness-inverted sample of prev"
  },
  
  '%': {
    color: '#8B0000',
    number: 44,
    fn: fnPercent,
    arity: 1,
    argTypes: ['int'],
    functionName: "floyd-steinberg",
    documentation: "Floyd-Steinberg dithers prev to 4-corner color palette with cell size n+1"
  },
  
  '&': {
    color: '#4169E1',
    number: 45,
    fn: fnAmpersand,
    arity: 1,
    argTypes: ['int'],
    functionName: "hue-sat-transfer",
    documentation: "Output has prev's luminance but hue/saturation from old_image at index j"
  },
  
  "'": {
    color: '#FF1493',
    number: 46,
    fn: fnApostrophe,
    arity: 1,
    argTypes: ['int'],
    functionName: "vertical-streaks",
    documentation: "Vertical streaks at x positions where x % (n+2) == 0, length based on column luminance, 50% white"
  },
  
  '(': {
    color: '#00CED1',
    number: 47,
    fn: fnOpenParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "pinch",
    documentation: "Pinch distortion toward center with strength n/10, brightens pixels near center"
  },
  
  ')': {
    color: '#FF69B4',
    number: 48,
    fn: fnCloseParen,
    arity: 1,
    argTypes: ['int'],
    functionName: "bulge",
    documentation: "Bulge distortion from center with strength n/10, darkens pixels near edge"
  },
  
  '*': {
    color: '#FFD700',
    number: 49,
    fn: fnAsterisk,
    arity: 1,
    argTypes: ['int'],
    functionName: "rays",
    documentation: "n rays emanate from center, color sampled from prev at angle*width/n, soft edges at 60% opacity"
  },
  
  '+': {
    color: '#32CD32',
    number: 50,
    fn: fnPlus,
    arity: 0,
    argTypes: [],
    functionName: "quad-sharpen-blur",
    documentation: "Cross divides into 4 quadrants; top-left/bottom-right sharpened, others blurred"
  },
  
  ',': {
    color: '#BA55D3',
    number: 51,
    fn: fnComma,
    arity: 1,
    argTypes: ['color'],
    functionName: "stipple",
    documentation: "Stipples prev with dots of color c at positions where (x*13+y*7) % (1+luminance/32) == 0"
  },
  
  '-': {
    color: '#708090',
    number: 52,
    fn: fnMinus,
    arity: 1,
    argTypes: ['int'],
    functionName: "scanlines",
    documentation: "Every nth row darkened 50%, every (n*2)th row samples from n pixels above"
  },
  
  '.': {
    color: '#20B2AA',
    number: 53,
    fn: fnDot,
    arity: 1,
    argTypes: ['int'],
    functionName: "pointillism",
    documentation: "Rebuilds prev from circles of radius (n%8)+2, color from center with +10% saturation"
  },
  
  '/': {
    color: '#CD853F',
    number: 54,
    fn: fnSlash,
    arity: 1,
    argTypes: ['color'],
    functionName: "diagonal-lines",
    documentation: "Diagonal lines top-left to bottom-right in color c, spacing based on luminance (bright=sparse)"
  },
};
</tool.toolu_01PD8ZB5Po3sz15EEzkSvYSX>

# ASSISTANT

Now I can see the characterDefs object ends at `/`. I need to implement the missing characters. Let me check what characters are missing according to the spec:

Missing characters:
- `:` - circular zoom regions
- `;` - semicircle with reflection
- `=` - horizontal stripes shifted
- `?` - effect based on corner pixels
- `@` - sphere (same as A)
- `[` - torn paper left
- `\` - diagonal lines opposite direction
- `]` - torn paper right
- `_` - bottom reflection
- `` ` `` - glitch effect
- `{` - left cylinder (WebGL)
- `|` - vertical split blend
- `}` - right cylinder (WebGL)
- `~` - horizontal wave with chromatic aberration

Let me implement all these missing functions:

# TOOL USE

Name: str-replace
ID: toolu_01UD7CKsf9MnhZGUXjRzfGqk

## path

<tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>
character-defs.ts
</tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>

## diff

<tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>
   '/': {
     color: '#CD853F',
     number: 54,
     fn: fnSlash,
     arity: 1,
     argTypes: ['color'],
     functionName: "diagonal-lines",
     documentation: "Diagonal lines top-left to bottom-right in color c, spacing based on luminance (bright=sparse)"
   },
+  
+  ':': {
+    color: '#6B8E23',
+    number: 55,
+    fn: fnColon,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "circular-zoom",
+    documentation: "n circular regions evenly spaced horizontally show prev at 2x zoom, rest box-blurred with radius 5"
+  },
+  
+  ';': {
+    color: '#DB7093',
+    number: 56,
+    fn: fnSemicolon,
+    arity: 0,
+    argTypes: [],
+    functionName: "semicircle-reflect",
+    documentation: "Semicircle arc (top half) crops prev, bottom half is reflection with wave distortion"
+  },
+  
+  '=': {
+    color: '#5F9EA0',
+    number: 57,
+    fn: fnEquals,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "shifted-stripes",
+    documentation: "Horizontal stripes of height n, even stripes are prev, odd stripes shifted left by stripe_index*5 pixels"
+  },
+  
+  '?': {
+    color: '#D2691E',
+    number: 58,
+    fn: fnQuestion,
+    arity: 0,
+    argTypes: [],
+    functionName: "corner-effect",
+    documentation: "Effect selected by (sum of corner pixel values) % 4: [solarize, emboss, edge-detect, posterize]"
+  },
+  
+  '@': {
+    color: '#7B68EE',
+    number: 59,
+    fn: fnA,
+    arity: 0,
+    argTypes: [],
+    functionName: "sphere-overlay-alt",
+    documentation: "Same as A: prev rendered on two 3D spheres with lighting in top-right and bottom-left quadrants"
+  },
+  
+  '[': {
+    color: '#48D1CC',
+    number: 60,
+    fn: fnOpenBracket,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "torn-left",
+    documentation: "Left third shows old_image, right two-thirds show prev, torn-paper edge using sin waves"
+  },
+  
+  '\\': {
+    color: '#C71585',
+    number: 61,
+    fn: fnBackslash,
+    arity: 1,
+    argTypes: ['color'],
+    functionName: "diagonal-lines-reverse",
+    documentation: "Diagonal lines from top-right to bottom-left in color c, spacing based on luminance"
+  },
+  
+  ']': {
+    color: '#00FA9A',
+    number: 62,
+    fn: fnCloseBracket,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "torn-right",
+    documentation: "Right third shows old_image, left two-thirds show prev, with torn-paper edge"
+  },
+  
+  '_': {
+    color: '#FF7F50',
+    number: 63,
+    fn: fnUnderscore,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "bottom-reflect",
+    documentation: "Bottom n*5% of image is reflected and overlaid with 50% opacity, with horizontal wave distortion"
+  },
+  
+  '`': {
+    color: '#6495ED',
+    number: 64,
+    fn: fnBacktick,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "glitch",
+    documentation: "Glitch effect: horizontal strips shifted right with RGB separation of n pixels"
+  },
+  
+  '{': {
+    color: '#DC143C',
+    number: 65,
+    fn: fnOpenBrace,
+    arity: 0,
+    argTypes: [],
+    functionName: "cylinder-left",
+    documentation: "Left half of image wrapped onto vertical cylinder (WebGL), curved-page effect turning left"
+  },
+  
+  '|': {
+    color: '#00BFFF',
+    number: 66,
+    fn: fnPipe,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "vertical-split",
+    documentation: "Left half is prev, right half is old_image, center column is 10px blend"
+  },
+  
+  '}': {
+    color: '#9400D3',
+    number: 67,
+    fn: fnCloseBrace,
+    arity: 0,
+    argTypes: [],
+    functionName: "cylinder-right",
+    documentation: "Right half of image wrapped onto vertical cylinder (WebGL), curved-page effect turning right"
+  },
+  
+  '~': {
+    color: '#FF6347',
+    number: 68,
+    fn: fnTilde,
+    arity: 1,
+    argTypes: ['int'],
+    functionName: "wave-chromatic",
+    documentation: "Horizontal wave distortion with amplitude = sin(y*0.05)*n*8, chromatic aberration (R +n px, B -n px)"
+  },
 };
\ No newline at end of file

</tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>

## git-commit-message

<tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>
Add missing character definitions to characterDefs object
</tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>

# TOOL RESULT

ID: toolu_01UD7CKsf9MnhZGUXjRzfGqk

<tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Add missing character definitions to characterDefs object
</tool.toolu_01UD7CKsf9MnhZGUXjRzfGqk>

# ASSISTANT

Now I need to implement all the function bodies for these new characters. Let me add them before the `export const characterDefs` line:

# TOOL USE

Name: str-replace
ID: toolu_01CRrP5sqhT8zAZropeTvE1F

## path

<tool.toolu_01CRrP5sqhT8zAZropeTvE1F>
character-defs.ts
</tool.toolu_01CRrP5sqhT8zAZropeTvE1F>

## git-commit-message

<tool.toolu_01CRrP5sqhT8zAZropeTvE1F>
Implement missing function bodies for new characters
</tool.toolu_01CRrP5sqhT8zAZropeTvE1F>

## diff

<tool.toolu_01CRrP5sqhT8zAZropeTvE1F>
 function fnSlash(ctx: FnContext, c: string): Image {
   const prev = getPrevImage(ctx);
   const out = cloneImage(prev);
   const [cr, cg, cb] = hexToRgb(c);
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
       const [r, g, b] = getPixel(prev, x, y);
       const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
       const spacing = Math.max(2, Math.floor(2 + luminance * 15));
       
       const diag = (x + y) % spacing;
       if (diag === 0) {
         setPixel(out, x, y, cr, cg, cb);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnColon(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const numCircles = Math.max(1, Math.min(n, 10));
+  const circleRadius = Math.min(ctx.width / (numCircles * 3), ctx.height / 4);
+  const blurRadius = 5;
+  
+  const blurred = createSolidImage(ctx.width, ctx.height, '#000000');
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      let sr = 0, sg = 0, sb = 0, count = 0;
+      for (let ky = -blurRadius; ky <= blurRadius; ky++) {
+        for (let kx = -blurRadius; kx <= blurRadius; kx++) {
+          const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
+          sr += pr;
+          sg += pg;
+          sb += pb;
+          count++;
+        }
+      }
+      setPixel(blurred, x, y, Math.round(sr / count), Math.round(sg / count), Math.round(sb / count));
+    }
+  }
+  
+  const circleCenters: [number, number][] = [];
+  for (let i = 0; i < numCircles; i++) {
+    const cx = Math.floor((i + 0.5) * ctx.width / numCircles);
+    const cy = Math.floor(ctx.height / 2);
+    circleCenters.push([cx, cy]);
+  }
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      let inCircle = false;
+      for (const [cx, cy] of circleCenters) {
+        const dx = x - cx;
+        const dy = y - cy;
+        if (dx * dx + dy * dy < circleRadius * circleRadius) {
+          const srcX = cx + dx * 0.5;
+          const srcY = cy + dy * 0.5;
+          const [r, g, b] = getPixel(prev, Math.floor(srcX), Math.floor(srcY));
+          setPixel(out, x, y, r, g, b);
+          inCircle = true;
+          break;
+        }
+      }
+      if (!inCircle) {
+        const [r, g, b] = getPixel(blurred, x, y);
+        setPixel(out, x, y, r, g, b);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnSemicolon(ctx: FnContext): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const cx = ctx.width / 2;
+  const cy = ctx.height / 2;
+  const radius = Math.min(cx, cy) * 0.9;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const dx = x - cx;
+      const dy = y - cy;
+      const dist = Math.sqrt(dx * dx + dy * dy);
+      
+      if (y < cy && dist < radius) {
+        const [r, g, b] = getPixel(prev, x, y);
+        setPixel(out, x, y, r, g, b);
+      } else if (y >= cy) {
+        const mirrorY = 2 * cy - y;
+        const mirrorDx = x - cx;
+        const mirrorDy = mirrorY - cy;
+        const mirrorDist = Math.sqrt(mirrorDx * mirrorDx + mirrorDy * mirrorDy);
+        
+        if (mirrorDist < radius) {
+          const wave = Math.sin(x * 0.1) * 10;
+          const srcY = Math.floor(mirrorY + wave);
+          const [r, g, b] = getPixel(prev, x, Math.max(0, Math.min(ctx.height - 1, srcY)));
+          setPixel(out, x, y, r, g, b);
+        }
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnEquals(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const stripeHeight = Math.max(2, n);
+  
+  for (let y = 0; y < ctx.height; y++) {
+    const stripeIdx = Math.floor(y / stripeHeight);
+    const isOdd = stripeIdx % 2 === 1;
+    const shift = isOdd ? stripeIdx * 5 : 0;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      const srcX = ((x + shift) % ctx.width + ctx.width) % ctx.width;
+      const [r, g, b] = getPixel(prev, srcX, y);
+      setPixel(out, x, y, r, g, b);
+    }
+  }
+  
+  return out;
+}
+
+function fnQuestion(ctx: FnContext): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const corners = [
+    getPixel(prev, 0, 0),
+    getPixel(prev, ctx.width - 1, 0),
+    getPixel(prev, 0, ctx.height - 1),
+    getPixel(prev, ctx.width - 1, ctx.height - 1)
+  ];
+  
+  let sum = 0;
+  for (const [r, g, b] of corners) {
+    sum += r + g + b;
+  }
+  const effect = sum % 4;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const [r, g, b] = getPixel(prev, x, y);
+      
+      if (effect === 0) {
+        const sr = r < 128 ? r : 255 - r;
+        const sg = g < 128 ? g : 255 - g;
+        const sb = b < 128 ? b : 255 - b;
+        setPixel(out, x, y, sr * 2, sg * 2, sb * 2);
+      } else if (effect === 1) {
+        let gx = 0, gy = 0;
+        for (let ky = -1; ky <= 1; ky++) {
+          for (let kx = -1; kx <= 1; kx++) {
+            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
+            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
+            const weight = (kx === 0 && ky === 0) ? 8 : -1;
+            gx += gray * weight;
+          }
+        }
+        const embossVal = Math.max(0, Math.min(255, 128 + gx / 4));
+        setPixel(out, x, y, embossVal, embossVal, embossVal);
+      } else if (effect === 2) {
+        const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
+        const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
+        let gx = 0, gy = 0;
+        for (let ky = -1; ky <= 1; ky++) {
+          for (let kx = -1; kx <= 1; kx++) {
+            const [pr, pg, pb] = getPixel(prev, x + kx, y + ky);
+            const gray = pr * 0.299 + pg * 0.587 + pb * 0.114;
+            const kidx = (ky + 1) * 3 + (kx + 1);
+            gx += gray * sobelX[kidx];
+            gy += gray * sobelY[kidx];
+          }
+        }
+        const mag = Math.min(255, Math.sqrt(gx * gx + gy * gy));
+        setPixel(out, x, y, mag, mag, mag);
+      } else {
+        const levels = 4;
+        const pr = Math.floor(r / 256 * levels) * (255 / (levels - 1));
+        const pg = Math.floor(g / 256 * levels) * (255 / (levels - 1));
+        const pb = Math.floor(b / 256 * levels) * (255 / (levels - 1));
+        setPixel(out, x, y, pr, pg, pb);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnOpenBracket(ctx: FnContext, j: number): Image {
+  const prev = getPrevImage(ctx);
+  const old = getOldImage(ctx, j);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const boundary = ctx.width / 3;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    const tear = boundary + Math.sin(y * 0.3) * 20 + Math.sin(y * 0.7) * 10;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      if (x < tear) {
+        const [r, g, b] = getPixel(old, x, y);
+        setPixel(out, x, y, r, g, b);
+      } else {
+        const [r, g, b] = getPixel(prev, x, y);
+        setPixel(out, x, y, r, g, b);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnBackslash(ctx: FnContext, c: string): Image {
+  const prev = getPrevImage(ctx);
+  const out = cloneImage(prev);
+  const [cr, cg, cb] = hexToRgb(c);
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const [r, g, b] = getPixel(prev, x, y);
+      const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
+      const spacing = Math.max(2, Math.floor(2 + luminance * 15));
+      
+      const diag = ((ctx.width - 1 - x) + y) % spacing;
+      if (diag === 0) {
+        setPixel(out, x, y, cr, cg, cb);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnCloseBracket(ctx: FnContext, j: number): Image {
+  const prev = getPrevImage(ctx);
+  const old = getOldImage(ctx, j);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const boundary = ctx.width * 2 / 3;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    const tear = boundary + Math.sin(y * 0.3) * 20 + Math.sin(y * 0.7) * 10;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      if (x > tear) {
+        const [r, g, b] = getPixel(old, x, y);
+        setPixel(out, x, y, r, g, b);
+      } else {
+        const [r, g, b] = getPixel(prev, x, y);
+        setPixel(out, x, y, r, g, b);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnUnderscore(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = cloneImage(prev);
+  
+  const reflectHeight = Math.floor(ctx.height * n * 0.05);
+  const startY = ctx.height - reflectHeight;
+  
+  for (let y = startY; y < ctx.height; y++) {
+    const mirrorY = 2 * startY - y - 1;
+    const wave = Math.sin(y * 0.1) * 5;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      if (mirrorY >= 0 && mirrorY < ctx.height) {
+        const srcX = Math.floor(((x + wave) % ctx.width + ctx.width) % ctx.width);
+        const [r, g, b] = getPixel(prev, srcX, mirrorY);
+        const idx = (y * ctx.width + x) * 4;
+        out.data[idx] = Math.round(out.data[idx] * 0.5 + r * 0.5);
+        out.data[idx + 1] = Math.round(out.data[idx + 1] * 0.5 + g * 0.5);
+        out.data[idx + 2] = Math.round(out.data[idx + 2] * 0.5 + b * 0.5);
       }
     }
   }
   
   return out;
 }
 
+function fnBacktick(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const glitchN = Math.max(1, n);
+  
+  for (let y = 0; y < ctx.height; y++) {
+    const shouldGlitch = (y * 17) % 23 < glitchN;
+    const shiftAmount = shouldGlitch ? ((y * 31) % (glitchN * 20)) : 0;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      if (shouldGlitch) {
+        const srcXR = ((x - shiftAmount - glitchN) % ctx.width + ctx.width) % ctx.width;
+        const srcXG = ((x - shiftAmount) % ctx.width + ctx.width) % ctx.width;
+        const srcXB = ((x - shiftAmount + glitchN) % ctx.width + ctx.width) % ctx.width;
+        
+        const [rr] = getPixel(prev, srcXR, y);
+        const [, gg] = getPixel(prev, srcXG, y);
+        const [, , bb] = getPixel(prev, srcXB, y);
+        
+        setPixel(out, x, y, rr, gg, bb);
+      } else {
+        const [r, g, b] = getPixel(prev, x, y);
+        setPixel(out, x, y, r, g, b);
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnOpenBrace(ctx: FnContext): Image {
+  const prev = getPrevImage(ctx);
+  const gl = initWebGL(ctx.width, ctx.height);
+  
+  const vertexShader = `
+    attribute vec2 position;
+    varying vec2 vUV;
+    void main() {
+      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
+      gl_Position = vec4(position, 0.0, 1.0);
+    }
+  `;
+  
+  const fragmentShader = `
+    precision mediump float;
+    uniform sampler2D texture;
+    uniform vec2 resolution;
+    varying vec2 vUV;
+    
+    void main() {
+      vec2 uv = vUV;
+      
+      if (uv.x < 0.5) {
+        float localX = uv.x * 2.0;
+        float angle = (localX - 0.5) * 3.14159 * 0.4;
+        float z = cos(angle);
+        float newX = 0.5 + sin(angle) * 0.4;
+        
+        float shade = 0.6 + 0.4 * z;
+        vec2 sampleUV = vec2(newX * 0.5, uv.y);
+        vec3 color = texture2D(texture, sampleUV).rgb * shade;
+        gl_FragColor = vec4(color, 1.0);
+      } else {
+        vec3 color = texture2D(texture, uv).rgb;
+        gl_FragColor = vec4(color, 1.0);
+      }
+    }
+  `;
+  
+  const program = createShaderProgram(gl, vertexShader, fragmentShader);
+  gl.useProgram(program);
+  
+  const texture = gl.createTexture();
+  gl.bindTexture(gl.TEXTURE_2D, texture);
+  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
+  
+  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
+  const buffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
+  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
+  
+  const positionLoc = gl.getAttribLocation(program, 'position');
+  gl.enableVertexAttribArray(positionLoc);
+  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
+  
+  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
+  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
+  
+  gl.viewport(0, 0, ctx.width, ctx.height);
+  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
+  
+  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
+  
+  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
+      const dstIdx = (y * ctx.width + x) * 4;
+      flipped[dstIdx] = pixels[srcIdx];
+      flipped[dstIdx + 1] = pixels[srcIdx + 1];
+      flipped[dstIdx + 2] = pixels[srcIdx + 2];
+      flipped[dstIdx + 3] = pixels[srcIdx + 3];
+    }
+  }
+  
+  gl.deleteTexture(texture);
+  gl.deleteBuffer(buffer);
+  gl.deleteProgram(program);
+  
+  return { width: ctx.width, height: ctx.height, data: flipped };
+}
+
+function fnPipe(ctx: FnContext, j: number): Image {
+  const prev = getPrevImage(ctx);
+  const old = getOldImage(ctx, j);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const midX = Math.floor(ctx.width / 2);
+  const blendWidth = 5;
+  
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      if (x < midX - blendWidth) {
+        const [r, g, b] = getPixel(prev, x, y);
+        setPixel(out, x, y, r, g, b);
+      } else if (x > midX + blendWidth) {
+        const [r, g, b] = getPixel(old, x, y);
+        setPixel(out, x, y, r, g, b);
+      } else {
+        const t = (x - (midX - blendWidth)) / (blendWidth * 2);
+        const [pr, pg, pb] = getPixel(prev, x, y);
+        const [or, og, ob] = getPixel(old, x, y);
+        setPixel(out, x, y,
+          Math.round(pr * (1 - t) + or * t),
+          Math.round(pg * (1 - t) + og * t),
+          Math.round(pb * (1 - t) + ob * t)
+        );
+      }
+    }
+  }
+  
+  return out;
+}
+
+function fnCloseBrace(ctx: FnContext): Image {
+  const prev = getPrevImage(ctx);
+  const gl = initWebGL(ctx.width, ctx.height);
+  
+  const vertexShader = `
+    attribute vec2 position;
+    varying vec2 vUV;
+    void main() {
+      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
+      gl_Position = vec4(position, 0.0, 1.0);
+    }
+  `;
+  
+  const fragmentShader = `
+    precision mediump float;
+    uniform sampler2D texture;
+    uniform vec2 resolution;
+    varying vec2 vUV;
+    
+    void main() {
+      vec2 uv = vUV;
+      
+      if (uv.x > 0.5) {
+        float localX = (uv.x - 0.5) * 2.0;
+        float angle = (localX - 0.5) * 3.14159 * 0.4;
+        float z = cos(angle);
+        float newX = 0.5 + sin(angle) * 0.4;
+        
+        float shade = 0.6 + 0.4 * z;
+        vec2 sampleUV = vec2(0.5 + newX * 0.5, uv.y);
+        vec3 color = texture2D(texture, sampleUV).rgb * shade;
+        gl_FragColor = vec4(color, 1.0);
+      } else {
+        vec3 color = texture2D(texture, uv).rgb;
+        gl_FragColor = vec4(color, 1.0);
+      }
+    }
+  `;
+  
+  const program = createShaderProgram(gl, vertexShader, fragmentShader);
+  gl.useProgram(program);
+  
+  const texture = gl.createTexture();
+  gl.bindTexture(gl.TEXTURE_2D, texture);
+  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
+  
+  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
+  const buffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
+  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
+  
+  const positionLoc = gl.getAttribLocation(program, 'position');
+  gl.enableVertexAttribArray(positionLoc);
+  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
+  
+  gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
+  gl.uniform2f(gl.getUniformLocation(program, 'resolution'), ctx.width, ctx.height);
+  
+  gl.viewport(0, 0, ctx.width, ctx.height);
+  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
+  
+  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
+  
+  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
+      const dstIdx = (y * ctx.width + x) * 4;
+      flipped[dstIdx] = pixels[srcIdx];
+      flipped[dstIdx + 1] = pixels[srcIdx + 1];
+      flipped[dstIdx + 2] = pixels[srcIdx + 2];
+      flipped[dstIdx + 3] = pixels[srcIdx + 3];
+    }
+  }
+  
+  gl.deleteTexture(texture);
+  gl.deleteBuffer(buffer);
+  gl.deleteProgram(program);
+  
+  return { width: ctx.width, height: ctx.height, data: flipped };
+}
+
+function fnTilde(ctx: FnContext, n: number): Image {
+  const prev = getPrevImage(ctx);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
+  
+  const waveN = Math.max(1, n);
+  
+  for (let y = 0; y < ctx.height; y++) {
+    const amplitude = Math.sin(y * 0.05) * waveN * 8;
+    
+    for (let x = 0; x < ctx.width; x++) {
+      const srcX = Math.floor(((x + amplitude) % ctx.width + ctx.width) % ctx.width);
+      
+      const srcXR = Math.floor(((x + amplitude + waveN) % ctx.width + ctx.width) % ctx.width);
+      const srcXB = Math.floor(((x + amplitude - waveN) % ctx.width + ctx.width) % ctx.width);
+      
+      const [rr] = getPixel(prev, srcXR, y);
+      const [, gg] = getPixel(prev, srcX, y);
+      const [, , bb] = getPixel(prev, srcXB, y);
+      
+      setPixel(out, x, y, rr, gg, bb);
+    }
+  }
+  
+  return out;
+}
+
 export const characterDefs
\ No newline at end of file

</tool.toolu_01CRrP5sqhT8zAZropeTvE1F>

# TOOL RESULT

ID: toolu_01CRrP5sqhT8zAZropeTvE1F

<tool.toolu_01CRrP5sqhT8zAZropeTvE1F>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Implement missing function bodies for new characters
</tool.toolu_01CRrP5sqhT8zAZropeTvE1F>

# ASSISTANT

Now let me verify the code compiles correctly by checking for any syntax issues:

# TOOL USE

Name: shell-command
ID: toolu_01JjC8eN8jt4WMBUcfhe6nwq

## command

<tool.toolu_01JjC8eN8jt4WMBUcfhe6nwq>
cd /Users/ajansson/projects/ascii-language && npx tsc --noEmit character-defs.ts 2>&1 || true
</tool.toolu_01JjC8eN8jt4WMBUcfhe6nwq>

# TOOL RESULT

ID: toolu_01JjC8eN8jt4WMBUcfhe6nwq

<tool.toolu_01JjC8eN8jt4WMBUcfhe6nwq>

</tool.toolu_01JjC8eN8jt4WMBUcfhe6nwq>
# USER

Change ! to be more pronounced and larger patterns

# THINKING

Signature: ErYCCkYIChgCKkA15Y5vgPQRiN+acGNq01LDuDeELW9KxEGnalTOL42Eq0QYylV0/fKXj5m/9TBBsH4rBZXjtkzdqq1UokEJEsDIEgx+z2PsySuE++JT/jMaDFQvSakQZwXdARIxJyIwDSp8VwAtaMT30M1Bj+UaQPl+GZjf+k0bJOWJAfW/UzPl2hAFLCJ6utjAIAM5vfTsKp0BRVM3LYzrpN5bFp8NAg48Hz2p1NZfHSxFExb+OLPGbKPWbiYQGeM/mPKt+hxMg9RAGLqAnJTKTEPUqSlYC35NGQH6ifTWdJWsUprH24pnb4LO6Ie+1+w3y6Qf0MJ8zy8LrpTwGwJRUrROL7ngNyzMv1ndZ2y2dm6lcY+BZfBszxu5qcfWPmhxS6RTmh48P0OywtzC3s0z+U86j3RiDxgB

The user wants to modify the `!` function (fnExclaim) to have more pronounced and larger patterns. Let me look at the current implementation.

# TOOL USE

Name: ripgrep
ID: toolu_01AES3DF16BpGk1bXZ5MNt5k

## pattern

<tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>
function fnExclaim
</tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>

## path

<tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>
character-defs.ts
</tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>

## context-lines

<tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>
20
</tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>

# TOOL RESULT

ID: toolu_01AES3DF16BpGk1bXZ5MNt5k

<tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>
2163-  
2164-  return out;
2165-}
2166-
2167-function fnCaret(ctx: FnContext): Image {
2168-  const prev = getPrevImage(ctx);
2169-  const out = createSolidImage(ctx.width, ctx.height, '#000000');
2170-  const shift = Math.floor(ctx.height / 3);
2171-  
2172-  for (let y = 0; y < ctx.height; y++) {
2173-    for (let x = 0; x < ctx.width; x++) {
2174-      const srcY = (y + shift) % ctx.height;
2175-      const [r, g, b] = getPixel(prev, x, srcY);
2176-      setPixel(out, x, y, r, g, b);
2177-    }
2178-  }
2179-  
2180-  return out;
2181-}
2182-
2183:function fnExclaim(ctx: FnContext, n: number): Image {
2184-  const prev = getPrevImage(ctx);
2185-  const out = cloneImage(prev);
2186-  const opacity = 0.3;
2187-  const factor = n + 17;
2188-  
2189-  for (let y = 0; y < ctx.height; y++) {
2190-    for (let x = 0; x < ctx.width; x++) {
2191-      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
2192-      const idx = (y * ctx.width + x) * 4;
2193-      out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
2194-      out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
2195-      out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
2196-    }
2197-  }
2198-  
2199-  return out;
2200-}
2201-
2202-function fnDoubleQuote(ctx: FnContext, n: number): Image {
2203-  const prev = getPrevImage(ctx);

</tool.toolu_01AES3DF16BpGk1bXZ5MNt5k>

# TOOL USE

Name: str-replace
ID: toolu_014VqjwHog14CXKNCPH3B2TK

## path

<tool.toolu_014VqjwHog14CXKNCPH3B2TK>
character-defs.ts
</tool.toolu_014VqjwHog14CXKNCPH3B2TK>

## git-commit-message

<tool.toolu_014VqjwHog14CXKNCPH3B2TK>
Make ! hash pattern more pronounced with larger patterns
</tool.toolu_014VqjwHog14CXKNCPH3B2TK>

## diff

<tool.toolu_014VqjwHog14CXKNCPH3B2TK>
 function fnExclaim(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = cloneImage(prev);
-  const opacity = 0.3;
-  const factor = n + 17;
+  const opacity = 0.6;
+  const scale = Math.max(4, (n + 2) * 3);
+  const factor1 = n + 17;
+  const factor2 = n * 7 + 23;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
-      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
+      const bx = Math.floor(x / scale);
+      const by = Math.floor(y / scale);
+      
+      const hash1 = ((bx * factor1) ^ (by * 31) ^ (bx * by * 13)) % 256;
+      const hash2 = ((bx * 47 + by * factor2) ^ (bx ^ by)) % 256;
+      const hash3 = ((bx + by * 73) * (bx ^ (by * 19))) % 256;
+      
+      const pattern = (hash1 + hash2 + hash3) / 3;
+      const brightness = pattern > 128 ? 255 : 0;
+      
       const idx = (y * ctx.width + x) * 4;
       out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
       out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
       out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_014VqjwHog14CXKNCPH3B2TK>

# TOOL RESULT

ID: toolu_014VqjwHog14CXKNCPH3B2TK

<tool.toolu_014VqjwHog14CXKNCPH3B2TK>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Make ! hash pattern more pronounced with larger patterns
</tool.toolu_014VqjwHog14CXKNCPH3B2TK>

# ASSISTANT

The `!` function now:
- Uses 60% opacity instead of 30% for a more pronounced effect
- Creates block-based patterns using a `scale` factor (controlled by n) that makes patterns larger
- Uses multiple hash functions combined together for more interesting patterns
- Thresholds to black/white for high contrast blocky patterns
- The `n` parameter controls the block size: larger n = larger pattern blocks

# USER

revert that, that's way too much

# THINKING

Signature: Ep4CCkYIChgCKkBJpX9uRXX22q9fBncFP0hlXH9fxEKwW6vskSK8BEPY01lYnqy7SIFAcJ0H9fjI/6lVq7pdYuOQ+8XUZ6G/4hPxEgyhU4RWeMpZVYk7E0waDL4nbnyGullMCrFCAiIwdeLhrQUuy9DIF/gvPgW3rVHYne8bCo2Hn+0/uM0nYAK7al+JqmN7yq1s9euv15NsKoUBria5NZv9A1UUWD74lguL5/4VjMV5hzGXoHNluKXNGXXr1bCyOgMHJqNVni0lM1JqQKvzvcNZjQfZytCM3900ePIhHBDDVLo6Yp4NZpsFy2CZqAm4QHHk0TVUPsRpO2fQG4JlEPhu06hBO/iykkPg7wGjKnz0mzKeXjWDGmrFhiq60GNhRhgB

The user wants to revert the changes to the fnExclaim function. Let me revert it back to the original implementation.

# TOOL USE

Name: str-replace
ID: toolu_017rVXRmQ6CzK9ds4wxNFWgZ

## path

<tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>
character-defs.ts
</tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>

## git-commit-message

<tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>
Revert ! hash pattern to original implementation
</tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>

## diff

<tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>
 function fnExclaim(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = cloneImage(prev);
-  const opacity = 0.6;
-  const scale = Math.max(4, (n + 2) * 3);
-  const factor1 = n + 17;
-  const factor2 = n * 7 + 23;
+  const opacity = 0.3;
+  const factor = n + 17;
   
   for (let y = 0; y < ctx.height; y++) {
     for (let x = 0; x < ctx.width; x++) {
-      const bx = Math.floor(x / scale);
-      const by = Math.floor(y / scale);
-      
-      const hash1 = ((bx * factor1) ^ (by * 31) ^ (bx * by * 13)) % 256;
-      const hash2 = ((bx * 47 + by * factor2) ^ (bx ^ by)) % 256;
-      const hash3 = ((bx + by * 73) * (bx ^ (by * 19))) % 256;
-      
-      const pattern = (hash1 + hash2 + hash3) / 3;
-      const brightness = pattern > 128 ? 255 : 0;
-      
+      const brightness = ((x * factor) ^ (y * 31) ^ (x * y)) % 256;
       const idx = (y * ctx.width + x) * 4;
       out.data[idx] = Math.round(out.data[idx] * (1 - opacity) + brightness * opacity);
       out.data[idx + 1] = Math.round(out.data[idx + 1] * (1 - opacity) + brightness * opacity);
       out.data[idx + 2] = Math.round(out.data[idx + 2] * (1 - opacity) + brightness * opacity);
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>

# TOOL RESULT

ID: toolu_017rVXRmQ6CzK9ds4wxNFWgZ

<tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Revert ! hash pattern to original implementation
</tool.toolu_017rVXRmQ6CzK9ds4wxNFWgZ>

# ASSISTANT

Reverted back to the original implementation.

# USER

replace # with a function that rearranges pixels based on self-organizing maps (but it needs to be able to run quickly!)

# THINKING

Signature: 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

The user wants to replace the # function with a self-organizing map (SOM) based pixel rearrangement. SOMs are typically slow because they involve iterative training, but I need to make this fast.

For a fast SOM-like effect, I can:
1. Pre-compute a small SOM grid (e.g., 16x16 or 32x32)
2. Use a simplified/approximated SOM that doesn't require many iterations
3. Map pixels to their best-matching unit (BMU) positions

Actually, for real-time performance, I should:
1. Create a small grid of "neurons" that represent colors
2. For each pixel, find its best matching neuron
3. Rearrange pixels by grouping them based on their BMU

A simpler approach that captures the SOM aesthetic:
1. Divide the image into a grid
2. For each cell, compute average color
3. Sort/rearrange cells based on color similarity (like a SOM would organize)
4. Map original pixels to new positions based on this organization

Or even simpler - create a SOM-like sorting effect:
1. Sample colors from the image to create a palette
2. Organize the palette in a 2D grid using a quick SOM-like arrangement
3. Remap pixels to positions based on where their color falls in the organized grid

Let me implement a fast approximation that:
1. Uses a pre-defined topology (the SOM grid)
2. Does a single pass to assign pixels to grid positions based on color similarity
3. Creates a visually interesting rearrangement

Here's my approach:
- Create a small grid (e.g., based on n parameter)
- Initialize grid nodes with colors sampled from the image
- Do a few quick iterations to organize the grid (colors similar should be neighbors)
- Then remap each pixel to a position based on its color's location in the organized grid

For speed, I'll limit iterations and use a simple distance metric.

# TOOL USE

Name: ripgrep
ID: toolu_019qp8ZgkroeVwC3A3SefULQ

## pattern

<tool.toolu_019qp8ZgkroeVwC3A3SefULQ>
function fnHash
</tool.toolu_019qp8ZgkroeVwC3A3SefULQ>

## path

<tool.toolu_019qp8ZgkroeVwC3A3SefULQ>
character-defs.ts
</tool.toolu_019qp8ZgkroeVwC3A3SefULQ>

## context-lines

<tool.toolu_019qp8ZgkroeVwC3A3SefULQ>
25
</tool.toolu_019qp8ZgkroeVwC3A3SefULQ>

# TOOL RESULT

ID: toolu_019qp8ZgkroeVwC3A3SefULQ

<tool.toolu_019qp8ZgkroeVwC3A3SefULQ>
2205-  const bands = Math.max(2, n);
2206-  const bandHeight = ctx.height / bands;
2207-  
2208-  for (let y = 0; y < ctx.height; y++) {
2209-    const bandIdx = Math.floor(y / bandHeight);
2210-    const isOdd = bandIdx % 2 === 1;
2211-    
2212-    for (let x = 0; x < ctx.width; x++) {
2213-      const [r, g, b] = getPixel(prev, x, y);
2214-      
2215-      if (isOdd) {
2216-        const [h, s, l] = rgbToHsl(r, g, b);
2217-        const [nr, ng, nb] = hslToRgb((h + 180) % 360, s, l);
2218-        setPixel(out, x, y, nr, ng, nb);
2219-      } else {
2220-        const [h, s, l] = rgbToHsl(r, g, b);
2221-        const [nr, ng, nb] = hslToRgb(h, 1 - s, l);
2222-        setPixel(out, x, y, nr, ng, nb);
2223-      }
2224-    }
2225-  }
2226-  
2227-  return out;
2228-}
2229-
2230:function fnHash(ctx: FnContext, c: string): Image {
2231-  const prev = getPrevImage(ctx);
2232-  const out = cloneImage(prev);
2233-  const [cr, cg, cb] = hexToRgb(c);
2234-  
2235-  const gridSpacing = 20;
2236-  
2237-  for (let y = 0; y < ctx.height; y++) {
2238-    for (let x = 0; x < ctx.width; x++) {
2239-      const thickness = 1 + Math.sin(x * y * 0.01) * 3;
2240-      const nearHorizontal = (y % gridSpacing) < thickness;
2241-      const nearVertical = (x % gridSpacing) < thickness;
2242-      
2243-      if (nearHorizontal || nearVertical) {
2244-        setPixel(out, x, y, cr, cg, cb);
2245-      }
2246-    }
2247-  }
2248-  
2249-  return out;
2250-}
2251-
2252-function fnDollar(ctx: FnContext, n: number): Image {
2253-  const prev = getPrevImage(ctx);
2254-  const out = cloneImage(prev);
2255-  

</tool.toolu_019qp8ZgkroeVwC3A3SefULQ>

# TOOL USE

Name: str-replace
ID: toolu_014HNUTcGQchiqArR6BktYeG

## path

<tool.toolu_014HNUTcGQchiqArR6BktYeG>
character-defs.ts
</tool.toolu_014HNUTcGQchiqArR6BktYeG>

## git-commit-message

<tool.toolu_014HNUTcGQchiqArR6BktYeG>
Replace # with fast self-organizing map pixel rearrangement
</tool.toolu_014HNUTcGQchiqArR6BktYeG>

## diff

<tool.toolu_014HNUTcGQchiqArR6BktYeG>
-function fnHash(ctx: FnContext, c: string): Image {
+function fnHash(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
-  const out = cloneImage(prev);
-  const [cr, cg, cb] = hexToRgb(c);
+  const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const gridSpacing = 20;
+  const gridSize = Math.max(4, Math.min((n % 8) + 4, 16));
+  const cellW = Math.floor(ctx.width / gridSize);
+  const cellH = Math.floor(ctx.height / gridSize);
   
-  for (let y = 0; y < ctx.height; y++) {
-    for (let x = 0; x < ctx.width; x++) {
-      const thickness = 1 + Math.sin(x * y * 0.01) * 3;
-      const nearHorizontal = (y % gridSpacing) < thickness;
-      const nearVertical = (x % gridSpacing) < thickness;
+  const cells: { avgR: number; avgG: number; avgB: number; pixels: [number, number, number, number, number][] }[] = [];
+  
+  for (let gy = 0; gy < gridSize; gy++) {
+    for (let gx = 0; gx < gridSize; gx++) {
+      let sumR = 0, sumG = 0, sumB = 0, count = 0;
+      const pixels: [number, number, number, number, number][] = [];
       
-      if (nearHorizontal || nearVertical) {
-        setPixel(out, x, y, cr, cg, cb);
+      for (let y = gy * cellH; y < (gy + 1) * cellH && y < ctx.height; y++) {
+        for (let x = gx * cellW; x < (gx + 1) * cellW && x < ctx.width; x++) {
+          const [r, g, b] = getPixel(prev, x, y);
+          sumR += r;
+          sumG += g;
+          sumB += b;
+          count++;
+          pixels.push([x, y, r, g, b]);
+        }
       }
+      
+      cells.push({
+        avgR: count > 0 ? sumR / count : 0,
+        avgG: count > 0 ? sumG / count : 0,
+        avgB: count > 0 ? sumB / count : 0,
+        pixels
+      });
     }
   }
   
+  const som: number[][] = [];
+  for (let i = 0; i < gridSize * gridSize; i++) {
+    som.push([cells[i].avgR, cells[i].avgG, cells[i].avgB]);
+  }
+  
+  const iterations = 5;
+  const initialRadius = gridSize / 2;
+  const initialLR = 0.5;
+  
+  for (let iter = 0; iter < iterations; iter++) {
+    const radius = initialRadius * Math.exp(-iter / iterations);
+    const lr = initialLR * Math.exp(-iter / iterations);
+    
+    for (let ci = 0; ci < cells.length; ci++) {
+      const input = [cells[ci].avgR, cells[ci].avgG, cells[ci].avgB];
+      
+      let bmuIdx = 0;
+      let bmuDist = Infinity;
+      for (let i = 0; i < som.length; i++) {
+        const dist = (som[i][0] - input[0]) ** 2 + (som[i][1] - input[1]) ** 2 + (som[i][2] - input[2]) ** 2;
+        if (dist < bmuDist) {
+          bmuDist = dist;
+          bmuIdx = i;
+        }
+      }
+      
+      const bmuX = bmuIdx % gridSize;
+      const bmuY = Math.floor(bmuIdx / gridSize);
+      
+      for (let i = 0; i < som.length; i++) {
+        const nx = i % gridSize;
+        const ny = Math.floor(i / gridSize);
+        const gridDist = Math.sqrt((nx - bmuX) ** 2 + (ny - bmuY) ** 2);
+        
+        if (gridDist < radius) {
+          const influence = Math.exp(-(gridDist ** 2) / (2 * radius ** 2));
+          som[i][0] += lr * influence * (input[0] - som[i][0]);
+          som[i][1] += lr * influence * (input[1] - som[i][1]);
+          som[i][2] += lr * influence * (input[2] - som[i][2]);
+        }
+      }
+    }
+  }
+  
+  const cellMapping: number[] = [];
+  const used = new Set<number>();
+  
+  for (let ci = 0; ci < cells.length; ci++) {
+    const input = [cells[ci].avgR, cells[ci].avgG, cells[ci].avgB];
+    
+    let bmuIdx = 0;
+    let bmuDist = Infinity;
+    for (let i = 0; i < som.length; i++) {
+      if (used.has(i)) continue;
+      const dist = (som[i][0] - input[0]) ** 2 + (som[i][1] - input[1]) ** 2 + (som[i][2] - input[2]) ** 2;
+      if (dist < bmuDist) {
+        bmuDist = dist;
+        bmuIdx = i;
+      }
+    }
+    
+    cellMapping[ci] = bmuIdx;
+    used.add(bmuIdx);
+  }
+  
+  for (let ci = 0; ci < cells.length; ci++) {
+    const targetIdx = cellMapping[ci];
+    const targetGX = targetIdx % gridSize;
+    const targetGY = Math.floor(targetIdx / gridSize);
+    
+    for (const [ox, oy, r, g, b] of cells[ci].pixels) {
+      const sourceGX = ci % gridSize;
+      const sourceGY = Math.floor(ci / gridSize);
+      
+      const localX = ox - sourceGX * cellW;
+      const localY = oy - sourceGY * cellH;
+      
+      const newX = targetGX * cellW + localX;
+      const newY = targetGY * cellH + localY;
+      
+      if (newX >= 0 && newX < ctx.width && newY >= 0 && newY < ctx.height) {
+        setPixel(out, newX, newY, r, g, b);
+      }
+    }
+  }
+  
   return out;
 }
\ No newline at end of file

</tool.toolu_014HNUTcGQchiqArR6BktYeG>

# TOOL RESULT

ID: toolu_014HNUTcGQchiqArR6BktYeG

<tool.toolu_014HNUTcGQchiqArR6BktYeG>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Replace # with fast self-organizing map pixel rearrangement
</tool.toolu_014HNUTcGQchiqArR6BktYeG>

# ASSISTANT

Now I need to update the characterDefs entry for `#` since the function signature changed from `(c: string)` to `(n: number)`:

# TOOL USE

Name: str-replace
ID: toolu_01FwYDQF7mJR4ZEjA9aH1tEp

## path

<tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>
character-defs.ts
</tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>

## git-commit-message

<tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>
Update # characterDef to use int argument for SOM grid size
</tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>

## diff

<tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>
   '#': {
     color: '#228B22',
     number: 42,
     fn: fnHash,
     arity: 1,
-    argTypes: ['color'],
-    functionName: "grid-lines",
-    documentation: "Draws grid of lines in color c with thickness = 1 + sin(x*y*0.01) * 3"
+    argTypes: ['int'],
+    functionName: "som-rearrange",
+    documentation: "Rearranges image cells using self-organizing map, grouping similar colors together, grid size 4-16 based on n"
   },
\ No newline at end of file

</tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>

# TOOL RESULT

ID: toolu_01FwYDQF7mJR4ZEjA9aH1tEp

<tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update # characterDef to use int argument for SOM grid size
</tool.toolu_01FwYDQF7mJR4ZEjA9aH1tEp>

# ASSISTANT

The `#` function now:
- Divides the image into a grid of cells (4-16 cells per side, controlled by `n`)
- Computes the average color of each cell
- Runs a fast 5-iteration self-organizing map to organize colors topologically (similar colors become neighbors)
- Rearranges the image cells according to the SOM mapping, so similar-colored regions end up adjacent
- Keeps pixel details within each cell intact, just moves entire cells around

# USER

instead of SOM, order the tiles from left to right, top to bottom based on average hue of each tile

# THINKING

Signature: EqkCCkYIChgCKkBtvbFzvqTP3h/LFPmTyKpHHkKHdPn0/shykcp/kWgsT8ZLRMrDcjy+pCtkrGSGjNfPwWXXbyUC5AWzQxBF7vplEgz/BU97tua5nD1ThXwaDPe6B989m643NX5JvSIwFdz74mWcnCJqD7oh2qNXpNXuzfm6aKh/eY4aheUyvQU4LUHNKLhWAvmhtW2n7cKQKpABvJPXsrEIJn2EgJ+FcoUcZlLxYO5sB6e+fH8Wayx4eJXHpSQGqE6Uj2JF6JpD8hD7RbNw5OUFZwWjPr4SuyuHBjPgcw5MHT/HJyAOzmlvGV0stS4ar15vM39SM/HUC9V4H6u9LoFaYNc6zqShYnsNECJi9x0JpnNR6OPaAktT1Y7SxWEcESUBe851ftXwn4DOGAE=

The user wants a simpler approach - just sort the tiles by their average hue value, arranging them left to right, top to bottom.

# TOOL USE

Name: str-replace
ID: toolu_01PYiHBSyN4SjmVTm53jJxsN

## path

<tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>
character-defs.ts
</tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>

## git-commit-message

<tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>
Replace SOM with simple hue-based tile sorting for #
</tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>

## diff

<tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>
 function fnHash(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const gridSize = Math.max(4, Math.min((n % 8) + 4, 16));
+  const gridSize = Math.max(4, Math.min((n % 12) + 4, 24));
   const cellW = Math.floor(ctx.width / gridSize);
   const cellH = Math.floor(ctx.height / gridSize);
   
-  const cells: { avgR: number; avgG: number; avgB: number; pixels: [number, number, number, number, number][] }[] = [];
+  const cells: { gx: number; gy: number; hue: number; pixels: [number, number, number, number, number][] }[] = [];
   
   for (let gy = 0; gy < gridSize; gy++) {
     for (let gx = 0; gx < gridSize; gx++) {
       let sumR = 0, sumG = 0, sumB = 0, count = 0;
       const pixels: [number, number, number, number, number][] = [];
       
       for (let y = gy * cellH; y < (gy + 1) * cellH && y < ctx.height; y++) {
         for (let x = gx * cellW; x < (gx + 1) * cellW && x < ctx.width; x++) {
           const [r, g, b] = getPixel(prev, x, y);
           sumR += r;
           sumG += g;
           sumB += b;
           count++;
           pixels.push([x, y, r, g, b]);
         }
       }
       
-      cells.push({
-        avgR: count > 0 ? sumR / count : 0,
-        avgG: count > 0 ? sumG / count : 0,
-        avgB: count > 0 ? sumB / count : 0,
-        pixels
-      });
-    }
-  }
-  
-  const som: number[][] = [];
-  for (let i = 0; i < gridSize * gridSize; i++) {
-    som.push([cells[i].avgR, cells[i].avgG, cells[i].avgB]);
-  }
-  
-  const iterations = 5;
-  const initialRadius = gridSize / 2;
-  const initialLR = 0.5;
-  
-  for (let iter = 0; iter < iterations; iter++) {
-    const radius = initialRadius * Math.exp(-iter / iterations);
-    const lr = initialLR * Math.exp(-iter / iterations);
-    
-    for (let ci = 0; ci < cells.length; ci++) {
-      const input = [cells[ci].avgR, cells[ci].avgG, cells[ci].avgB];
+      const avgR = count > 0 ? sumR / count : 0;
+      const avgG = count > 0 ? sumG / count : 0;
+      const avgB = count > 0 ? sumB / count : 0;
+      const [hue] = rgbToHsl(avgR, avgG, avgB);
       
-      let bmuIdx = 0;
-      let bmuDist = Infinity;
-      for (let i = 0; i < som.length; i++) {
-        const dist = (som[i][0] - input[0]) ** 2 + (som[i][1] - input[1]) ** 2 + (som[i][2] - input[2]) ** 2;
-        if (dist < bmuDist) {
-          bmuDist = dist;
-          bmuIdx = i;
-        }
-      }
-      
-      const bmuX = bmuIdx % gridSize;
-      const bmuY = Math.floor(bmuIdx / gridSize);
-      
-      for (let i = 0; i < som.length; i++) {
-        const nx = i % gridSize;
-        const ny = Math.floor(i / gridSize);
-        const gridDist = Math.sqrt((nx - bmuX) ** 2 + (ny - bmuY) ** 2);
-        
-        if (gridDist < radius) {
-          const influence = Math.exp(-(gridDist ** 2) / (2 * radius ** 2));
-          som[i][0] += lr * influence * (input[0] - som[i][0]);
-          som[i][1] += lr * influence * (input[1] - som[i][1]);
-          som[i][2] += lr * influence * (input[2] - som[i][2]);
-        }
-      }
+      cells.push({ gx, gy, hue, pixels });
     }
   }
   
-  const cellMapping: number[] = [];
-  const used = new Set<number>();
+  cells.sort((a, b) => a.hue - b.hue);
   
-  for (let ci = 0; ci < cells.length; ci++) {
-    const input = [cells[ci].avgR, cells[ci].avgG, cells[ci].avgB];
+  for (let i = 0; i < cells.length; i++) {
+    const targetGX = i % gridSize;
+    const targetGY = Math.floor(i / gridSize);
+    const cell = cells[i];
     
-    let bmuIdx = 0;
-    let bmuDist = Infinity;
-    for (let i = 0; i < som.length; i++) {
-      if (used.has(i)) continue;
-      const dist = (som[i][0] - input[0]) ** 2 + (som[i][1] - input[1]) ** 2 + (som[i][2] - input[2]) ** 2;
-      if (dist < bmuDist) {
-        bmuDist = dist;
-        bmuIdx = i;
-      }
-    }
-    
-    cellMapping[ci] = bmuIdx;
-    used.add(bmuIdx);
-  }
-  
-  for (let ci = 0; ci < cells.length; ci++) {
-    const targetIdx = cellMapping[ci];
-    const targetGX = targetIdx % gridSize;
-    const targetGY = Math.floor(targetIdx / gridSize);
-    
-    for (const [ox, oy, r, g, b] of cells[ci].pixels) {
-      const sourceGX = ci % gridSize;
-      const sourceGY = Math.floor(ci / gridSize);
+    for (const [ox, oy, r, g, b] of cell.pixels) {
+      const localX = ox - cell.gx * cellW;
+      const localY = oy - cell.gy * cellH;
       
-      const localX = ox - sourceGX * cellW;
-      const localY = oy - sourceGY * cellH;
-      
       const newX = targetGX * cellW + localX;
       const newY = targetGY * cellH + localY;
       
       if (newX >= 0 && newX < ctx.width && newY >= 0 && newY < ctx.height) {
         setPixel(out, newX, newY, r, g, b);
       }
     }
   }
   
   return out;
 }
\ No newline at end of file

</tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>

# TOOL RESULT

ID: toolu_01PYiHBSyN4SjmVTm53jJxsN

<tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Replace SOM with simple hue-based tile sorting for #
</tool.toolu_01PYiHBSyN4SjmVTm53jJxsN>

# TOOL USE

Name: str-replace
ID: toolu_01Pg5nSCZFZ1dmyMBdmhZiVB

## path

<tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>
character-defs.ts
</tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>

## git-commit-message

<tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>
Update # documentation for hue-sorted tiles
</tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>

## diff

<tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>
   '#': {
     color: '#228B22',
     number: 42,
     fn: fnHash,
     arity: 1,
     argTypes: ['int'],
-    functionName: "som-rearrange",
-    documentation: "Rearranges image cells using self-organizing map, grouping similar colors together, grid size 4-16 based on n"
+    functionName: "hue-sort-tiles",
+    documentation: "Divides image into tiles and sorts them left-to-right, top-to-bottom by average hue, grid size 4-24 based on n"
   },
\ No newline at end of file

</tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>

# TOOL RESULT

ID: toolu_01Pg5nSCZFZ1dmyMBdmhZiVB

<tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update # documentation for hue-sorted tiles
</tool.toolu_01Pg5nSCZFZ1dmyMBdmhZiVB>

# ASSISTANT

Done. The `#` function now:
- Divides the image into a grid of tiles (4-24 tiles per side, based on `n`)
- Calculates the average hue of each tile
- Sorts all tiles by hue
- Places them left-to-right, top-to-bottom in sorted order
- Creates a rainbow gradient effect across the image while preserving the detail within each tile

# USER

make the mininmum tile size much smaller (and remove the maximum of n)

# THINKING

Signature: EpQCCkYIChgCKkDpS30UguzvomeWFTc995s6bVZkZ5azzH+i35DgBIYF/DBn8aplWxxGYUHYYh0OJYA4QPwVJ0Zlg+eMDrcfsUVLEgy462xHZ+W5hFXmUKoaDOd+dwlegnVCTJ48HyIwf/Xhn/Kl7+4Ojg1X2QQO7Y1Nr075GfweHknUCGaOnYkp0uBBNknKa3y4HfYXrMzTKnySWSGAWiPii3uwrYFBOLo6laIsWH0eb5OKmO1oFUtFIiLOLszH146qQYLarjbIsTgxhBTuKWuTlM8dfOJtvS9aiOFZ13EE7OZaD+WB9jargxZLJ7eFUjHSd5OjrzgveXsvrvfWeHh6NnqyEWE52ZzUkEUTzxrrlcBcnDdaGAE=

The user wants smaller minimum tile sizes and no maximum limit on n. Let me update the gridSize calculation.

# TOOL USE

Name: str-replace
ID: toolu_018wCCGNg1JKKpQY6XRCAzwB

## path

<tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>
character-defs.ts
</tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>

## git-commit-message

<tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>
Allow smaller tiles and remove max limit for # hue sort
</tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>

## diff

<tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>
 function fnHash(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
   const out = createSolidImage(ctx.width, ctx.height, '#000000');
   
-  const gridSize = Math.max(4, Math.min((n % 12) + 4, 24));
+  const gridSize = Math.max(2, n + 2);
   const cellW = Math.floor(ctx.width / gridSize);
   const cellH = Math.floor(ctx.height / gridSize);
\ No newline at end of file

</tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>

# TOOL RESULT

ID: toolu_018wCCGNg1JKKpQY6XRCAzwB

<tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Allow smaller tiles and remove max limit for # hue sort
</tool.toolu_018wCCGNg1JKKpQY6XRCAzwB>

# TOOL USE

Name: str-replace
ID: toolu_01FMws4EKXJpHBCvGUc5JQTh

## path

<tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>
character-defs.ts
</tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>

## git-commit-message

<tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>
Update # documentation for new tile size range
</tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>

## diff

<tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>
   '#': {
     color: '#228B22',
     number: 42,
     fn: fnHash,
     arity: 1,
     argTypes: ['int'],
     functionName: "hue-sort-tiles",
-    documentation: "Divides image into tiles and sorts them left-to-right, top-to-bottom by average hue, grid size 4-24 based on n"
+    documentation: "Divides image into tiles and sorts them left-to-right, top-to-bottom by average hue, grid size = n+2 (min 2)"
   },
\ No newline at end of file

</tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>

# TOOL RESULT

ID: toolu_01FMws4EKXJpHBCvGUc5JQTh

<tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>
Successfully replaced content in /Users/ajansson/projects/ascii-language/character-defs.ts. Successfully staged 2 file(s) and committed with message: Update # documentation for new tile size range
</tool.toolu_01FMws4EKXJpHBCvGUc5JQTh>

# ASSISTANT

Done. Now:
- Minimum grid size is 2 (when n=0)
- Grid size = n + 2, with no upper limit
- So n=0 gives 2x2, n=1 gives 3x3, n=10 gives 12x12, n=100 gives 102x102, etc.

# USER

$ is a really awful function. give me ten ideas for what it could do instead

# THINKING

Signature: EucCCkYIChgCKkBZ3gDDpbkbDTfZUCZBW6XQKOqe3wut0HsqbQ3/Z5fpXfd8tTn9SKUHQH3Aa5JlRH/RLqHvm/7iDhREEArd5ZCLEgz+i9CmTJzp/tx381UaDMdjWl5uzTiFwtp57yIwHZcg0/EMth+oY4iJNsS8J3vhjkwGyzHjiH9mmGyn21yBmE2Av+Ox8U1xl7dWbSb4Ks4Bp0Fb5BEbKGDq8aV+s7IHS3mg7/0p4WCyhZSnLwXh3GsJhoFo4DyOPsftESes7s83k9U1rdrUEtf5+4C6VeTA851BNxVpXJekCEbrCtsBpsJcGNnVvBipfGRuLYZ5y/yC9veyqn0yyWqSUyJzIAkO5eD5nBPm1h/XXIqxVya/j0/OvtjSY1B5VJnYOpc1Cl5H4GjXdmSBXUH2tGa4HPzWcp7ibG9ZImNPgshjoxF3FawK2H+1Xrf3IeT3P9u3J1aU7UJKakngqExfeH6g/scYAQ==

The user wants ideas for replacing the $ function. Let me think of 10 interesting image manipulation ideas that would be visually interesting and fit the esoteric programming language theme.

# ASSISTANT

Here are 10 ideas for `$`:

1. **Currency glitch** - Samples the image at regular intervals and stretches/duplicates columns like a broken receipt printer or stock ticker, with green tint on "up" regions and red on "down" based on luminance changes

2. **Liquid gold pour** - Simulates metallic liquid flowing down from the top, pooling based on luminance (darker areas act as basins), with specular highlights

3. **Shatter/glass break** - Breaks image into sharp triangular shards that appear displaced in 3D space, with edges catching light, displacement based on n

4. **Data moshing** - I-frame/P-frame style corruption where blocks from earlier in the image are dragged forward, creating the characteristic "melting" video glitch effect

5. **Wealth distribution** - Redistributes pixel brightness using a power law: the brightest pixels get brighter, darkest get darker (rich get richer), n controls inequality coefficient

6. **Slot machine** - Divides into n vertical strips that appear offset vertically by different amounts, like spinning slot reels frozen at different positions

7. **Inflation** - Pixels "inflate" outward from bright spots like expanding bubbles, pushing nearby pixels away, creating a bubbly/cellular distortion

8. **Stock chart overlay** - Generates a deterministic "stock chart" line graph based on row-averaged luminance, drawn over the image with candlestick-style rendering

9. **Counterfeit/watermark** - Embeds a subtle repeating pattern (like currency watermarks) that's only visible when you look closely, based on very slight hue shifts

10. **Melt/drip expensive** - High-end looking chrome/liquid metal drip effect where bright areas "melt" downward leaving metallic trails, like dripping mercury

Which of these appeals to you, or would you like variations on any?

# USER

glass break sounds good, do that in webgl

# THINKING

Signature: EtUECkYIChgCKkA28izydILr5Ccq9VfcBp1BoxyWCAoDKJZMxuyaidpgivoFao7IX8xFUPP19HvdCAsxIhpcIi8F8iFZ6kUX6tgHEgw6Oz7IKXIEbA0uEW4aDA3RIBLXIFEhz6AcQCIwLDRroTkUS8deNDu/vM1/c8H17a+PXiaq4m8RAv6vU2+ip7awzilZEaF6b+x93gOqKrwDxBQJoOCCW5uogQHOqazvqy66wSeEsuMIIVKAtyUtvLHMXyATWxItn6gqOJGahS1yO1tOsETCUrpqrt9KOnuMGXjGx5rVFR4QUZRx9pZGT4UbNzPp57kil639IYFdAP1alysd5ZsDhl1WaoWJncgo8Vhc9Ma6C1zMgIMLuQP7vkNnx690vHGEGrlxfuPhWyYWN7BEINOkpxUssY4mkPA/Itz+vI2m2ZDj/w343OMQydoTjkFN7/BtWuT5RPUQmXdMYH5lzg9jeC5SrB3j/nauVAq/yHGOOf5M1Y5eE3V0Y0dy1AbPVNEGytQTI4t6lut27F4WLvJVnXksNv6qT3slxpWA4fjkW/xbLYRHnuEKxD97eYCMszG9enPSIMxiLLUWi89VRvYIY6lsIixYxrufX+2S70ql8dmAFLMy45lBoaY2nGJm/jkKGWbYZGg3u/XJ3HgMQyiTPnGaXTHQsDJ/vNNcH5NUtyGpGmDFay9husTrMp+wxFRC7MDKPK/htWjAmH2wEhEHAmKPpU2Vaw/tfownx4HKoRKCS7o2QP3a0d4/fetkAM2HKai/mVXfH2ArW+y1NU+qhzAnbisMGAE=

The user wants me to replace the $ function with a glass break/shatter effect using WebGL. I need to:
1. Find the current fnDollar function
2. Replace it with a WebGL shader that creates a shattered glass effect

The effect should:
- Break the image into sharp triangular shards
- Displace them slightly in a 3D-like way
- Add edge highlights to make it look like glass
- Use n to control the displacement amount or number of shards

# TOOL USE

Name: ripgrep
ID: toolu_01FQnVzGUPtgX8cJuJNyBdiT

## pattern

<tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>
function fnDollar
</tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>

## path

<tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>
character-defs.ts
</tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>

## context-lines

<tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>
35
</tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>

# TOOL RESULT

ID: toolu_01FQnVzGUPtgX8cJuJNyBdiT

<tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>
2253-        }
2254-      }
2255-      
2256-      const avgR = count > 0 ? sumR / count : 0;
2257-      const avgG = count > 0 ? sumG / count : 0;
2258-      const avgB = count > 0 ? sumB / count : 0;
2259-      const [hue] = rgbToHsl(avgR, avgG, avgB);
2260-      
2261-      cells.push({ gx, gy, hue, pixels });
2262-    }
2263-  }
2264-  
2265-  cells.sort((a, b) => a.hue - b.hue);
2266-  
2267-  for (let i = 0; i < cells.length; i++) {
2268-    const targetGX = i % gridSize;
2269-    const targetGY = Math.floor(i / gridSize);
2270-    const cell = cells[i];
2271-    
2272-    for (const [ox, oy, r, g, b] of cell.pixels) {
2273-      const localX = ox - cell.gx * cellW;
2274-      const localY = oy - cell.gy * cellH;
2275-      
2276-      const newX = targetGX * cellW + localX;
2277-      const newY = targetGY * cellH + localY;
2278-      
2279-      if (newX >= 0 && newX < ctx.width && newY >= 0 && newY < ctx.height) {
2280-        setPixel(out, newX, newY, r, g, b);
2281-      }
2282-    }
2283-  }
2284-  
2285-  return out;
2286-}
2287-
2288:function fnDollar(ctx: FnContext, n: number): Image {
2289-  const prev = getPrevImage(ctx);
2290-  const out = cloneImage(prev);
2291-  
2292-  const turns = Math.max(1, n);
2293-  const cx = ctx.width / 2;
2294-  const cy = ctx.height / 2;
2295-  const maxR = Math.min(cx, cy) * 0.9;
2296-  const phi = (1 + Math.sqrt(5)) / 2;
2297-  const totalAngle = turns * Math.PI * 2;
2298-  const steps = turns * 200;
2299-  
2300-  for (let i = 0; i < steps; i++) {
2301-    const t = i / steps;
2302-    const angle = t * totalAngle;
2303-    const r = maxR * Math.pow(phi, angle / (Math.PI * 2) - turns + 1);
2304-    
2305-    if (r < 1 || r > maxR) continue;
2306-    
2307-    const x = Math.floor(cx + r * Math.cos(angle));
2308-    const y = Math.floor(cy + r * Math.sin(angle));
2309-    
2310-    if (x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
2311-      const [pr, pg, pb] = getPixel(prev, x, y);
2312-      const brightness = (pr + pg + pb) / 3;
2313-      const invBrightness = 255 - brightness;
2314-      
2315-      for (let dy = -2; dy <= 2; dy++) {
2316-        for (let dx = -2; dx <= 2; dx++) {
2317-          if (dx * dx + dy * dy <= 4) {
2318-            setPixel(out, x + dx, y + dy, invBrightness, invBrightness, invBrightness);
2319-          }
2320-        }
2321-      }
2322-    }
2323-  }

</tool.toolu_01FQnVzGUPtgX8cJuJNyBdiT>

# TOOL USE

Name: ripgrep
ID: toolu_01FptmBrZk9y4nwhrr56x45N

## pattern

<tool.toolu_01FptmBrZk9y4nwhrr56x45N>
function fnDollar
</tool.toolu_01FptmBrZk9y4nwhrr56x45N>

## path

<tool.toolu_01FptmBrZk9y4nwhrr56x45N>
character-defs.ts
</tool.toolu_01FptmBrZk9y4nwhrr56x45N>

## context-lines

<tool.toolu_01FptmBrZk9y4nwhrr56x45N>
45
</tool.toolu_01FptmBrZk9y4nwhrr56x45N>

# TOOL RESULT

ID: toolu_01FptmBrZk9y4nwhrr56x45N

<tool.toolu_01FptmBrZk9y4nwhrr56x45N>
2243-      const pixels: [number, number, number, number, number][] = [];
2244-      
2245-      for (let y = gy * cellH; y < (gy + 1) * cellH && y < ctx.height; y++) {
2246-        for (let x = gx * cellW; x < (gx + 1) * cellW && x < ctx.width; x++) {
2247-          const [r, g, b] = getPixel(prev, x, y);
2248-          sumR += r;
2249-          sumG += g;
2250-          sumB += b;
2251-          count++;
2252-          pixels.push([x, y, r, g, b]);
2253-        }
2254-      }
2255-      
2256-      const avgR = count > 0 ? sumR / count : 0;
2257-      const avgG = count > 0 ? sumG / count : 0;
2258-      const avgB = count > 0 ? sumB / count : 0;
2259-      const [hue] = rgbToHsl(avgR, avgG, avgB);
2260-      
2261-      cells.push({ gx, gy, hue, pixels });
2262-    }
2263-  }
2264-  
2265-  cells.sort((a, b) => a.hue - b.hue);
2266-  
2267-  for (let i = 0; i < cells.length; i++) {
2268-    const targetGX = i % gridSize;
2269-    const targetGY = Math.floor(i / gridSize);
2270-    const cell = cells[i];
2271-    
2272-    for (const [ox, oy, r, g, b] of cell.pixels) {
2273-      const localX = ox - cell.gx * cellW;
2274-      const localY = oy - cell.gy * cellH;
2275-      
2276-      const newX = targetGX * cellW + localX;
2277-      const newY = targetGY * cellH + localY;
2278-      
2279-      if (newX >= 0 && newX < ctx.width && newY >= 0 && newY < ctx.height) {
2280-        setPixel(out, newX, newY, r, g, b);
2281-      }
2282-    }
2283-  }
2284-  
2285-  return out;
2286-}
2287-
2288:function fnDollar(ctx: FnContext, n: number): Image {
2289-  const prev = getPrevImage(ctx);
2290-  const out = cloneImage(prev);
2291-  
2292-  const turns = Math.max(1, n);
2293-  const cx = ctx.width / 2;
2294-  const cy = ctx.height / 2;
2295-  const maxR = Math.min(cx, cy) * 0.9;
2296-  const phi = (1 + Math.sqrt(5)) / 2;
2297-  const totalAngle = turns * Math.PI * 2;
2298-  const steps = turns * 200;
2299-  
2300-  for (let i = 0; i < steps; i++) {
2301-    const t = i / steps;
2302-    const angle = t * totalAngle;
2303-    const r = maxR * Math.pow(phi, angle / (Math.PI * 2) - turns + 1);
2304-    
2305-    if (r < 1 || r > maxR) continue;
2306-    
2307-    const x = Math.floor(cx + r * Math.cos(angle));
2308-    const y = Math.floor(cy + r * Math.sin(angle));
2309-    
2310-    if (x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
2311-      const [pr, pg, pb] = getPixel(prev, x, y);
2312-      const brightness = (pr + pg + pb) / 3;
2313-      const invBrightness = 255 - brightness;
2314-      
2315-      for (let dy = -2; dy <= 2; dy++) {
2316-        for (let dx = -2; dx <= 2; dx++) {
2317-          if (dx * dx + dy * dy <= 4) {
2318-            setPixel(out, x + dx, y + dy, invBrightness, invBrightness, invBrightness);
2319-          }
2320-        }
2321-      }
2322-    }
2323-  }
2324-  
2325-  return out;
2326-}
2327-
2328-function fnPercent(ctx: FnContext, n: number): Image {
2329-  const prev = getPrevImage(ctx);
2330-  const out = createSolidImage(ctx.width, ctx.height, '#000000');
2331-  
2332-  const cellSize = Math.max(1, n + 1);
2333-  const corners = [

</tool.toolu_01FptmBrZk9y4nwhrr56x45N>

# TOOL USE

Name: str-replace
ID: toolu_01G14fWBfgNasHmcjgsT5njb

## path

<tool.toolu_01G14fWBfgNasHmcjgsT5njb>
character-defs.ts
</tool.toolu_01G14fWBfgNasHmcjgsT5njb>

## git-commit-message

<tool.toolu_01G14fWBfgNasHmcjgsT5njb>
Replace $ golden spiral with WebGL glass shatter effect
</tool.toolu_01G14fWBfgNasHmcjgsT5njb>

## diff

<tool.toolu_01G14fWBfgNasHmcjgsT5njb>
 function fnDollar(ctx: FnContext, n: number): Image {
   const prev = getPrevImage(ctx);
-  const out = cloneImage(prev);
+  const gl = initWebGL(ctx.width, ctx.height);
   
-  const turns = Math.max(1, n);
-  const cx = ctx.width / 2;
-  const cy = ctx.height / 2;
-  const maxR = Math.min(cx, cy) * 0.9;
-  const phi = (1 + Math.sqrt(5)) / 2;
-  const totalAngle = turns * Math.PI * 2;
-  const steps = turns * 200;
+  const shardCount = Math.max(8, (n + 2) * 4);
+  const displacement = 0.02 + n * 0.008;
+  const seed = ctx.images.length * 73.0 + n * 17.0;
   
-  for (let i = 0; i < steps; i++) {
-    const t = i / steps;
-    const angle = t * totalAngle;
-    const r = maxR * Math.pow(phi, angle / (Math.PI * 2) - turns + 1);
+  const vertexShader = `
+    attribute vec2 position;
+    varying vec2 vUV;
+    void main() {
+      vUV = vec2(position.x * 0.5 + 0.5, 1.0 - (position.y * 0.5 + 0.5));
+      gl_Position = vec4(position, 0.0, 1.0);
+    }
+  `;
+  
+  const fragmentShader = `
+    precision highp float;
+    uniform sampler2D uTexture;
+    uniform vec2 uResolution;
+    uniform float uDisplacement;
+    uniform float uShardCount;
+    uniform float uSeed;
+    varying vec2 vUV;
     
-    if (r < 1 || r > maxR) continue;
+    float hash(vec2 p) {
+      return fract(sin(dot(p, vec2(127.1 + uSeed, 311.7))) * 43758.5453);
+    }
     
-    const x = Math.floor(cx + r * Math.cos(angle));
-    const y = Math.floor(cy + r * Math.sin(angle));
+    vec2 hash2(vec2 p) {
+      return vec2(hash(p), hash(p + vec2(17.0, 31.0)));
+    }
     
-    if (x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
-      const [pr, pg, pb] = getPixel(prev, x, y);
-      const brightness = (pr + pg + pb) / 3;
-      const invBrightness = 255 - brightness;
+    // Voronoi to create shard cells
+    vec3 voronoi(vec2 uv, float scale) {
+      vec2 id = floor(uv * scale);
+      vec2 gv = fract(uv * scale);
       
-      for (let dy = -2; dy <= 2; dy++) {
-        for (let dx = -2; dx <= 2; dx++) {
-          if (dx * dx + dy * dy <= 4) {
-            setPixel(out, x + dx, y + dy, invBrightness, invBrightness, invBrightness);
+      float minDist = 1.0;
+      float secondDist = 1.0;
+      vec2 closestPoint = vec2(0.0);
+      vec2 closestId = vec2(0.0);
+      
+      for (int y = -1; y <= 1; y++) {
+        for (int x = -1; x <= 1; x++) {
+          vec2 offset = vec2(float(x), float(y));
+          vec2 cellId = id + offset;
+          vec2 point = hash2(cellId) * 0.8 + 0.1;
+          vec2 diff = offset + point - gv;
+          float dist = length(diff);
+          
+          if (dist < minDist) {
+            secondDist = minDist;
+            minDist = dist;
+            closestPoint = point;
+            closestId = cellId;
+          } else if (dist < secondDist) {
+            secondDist = dist;
           }
         }
       }
+      
+      return vec3(closestId, secondDist - minDist);
     }
+    
+    void main() {
+      vec2 uv = vUV;
+      float aspect = uResolution.x / uResolution.y;
+      vec2 scaledUV = vec2(uv.x * aspect, uv.y);
+      
+      float scale = sqrt(uShardCount);
+      vec3 vor = voronoi(scaledUV, scale);
+      vec2 shardId = vor.xy;
+      float edgeDist = vor.z;
+      
+      // Random displacement per shard
+      vec2 shardHash = hash2(shardId);
+      float angle = shardHash.x * 6.28318;
+      float dist = shardHash.y * uDisplacement;
+      vec2 offset = vec2(cos(angle), sin(angle)) * dist;
+      
+      // Random rotation per shard
+      float rotation = (shardHash.x - 0.5) * 0.1 * uDisplacement * 10.0;
+      vec2 center = (shardId + 0.5) / scale;
+      center.x /= aspect;
+      
+      vec2 rotatedUV = uv - center;
+      float s = sin(rotation);
+      float c = cos(rotation);
+      rotatedUV = vec2(rotatedUV.x * c - rotatedUV.y * s, rotatedUV.x * s + rotatedUV.y * c);
+      rotatedUV += center;
+      
+      vec2 sampleUV = rotatedUV + offset;
+      sampleUV = clamp(sampleUV, 0.0, 1.0);
+      
+      vec3 color = texture2D(uTexture, sampleUV).rgb;
+      
+      // Brightness variation per shard (simulates angle to light)
+      float brightness = 0.85 + shardHash.y * 0.3;
+      color *= brightness;
+      
+      // Edge highlight (glass edge catching light)
+      float edgeWidth = 0.08;
+      float edge = smoothstep(0.0, edgeWidth, edgeDist);
+      float edgeHighlight = (1.0 - edge) * 0.6;
+      color += vec3(edgeHighlight);
+      
+      // Subtle refraction tint on edges
+      if (edgeDist < edgeWidth * 0.5) {
+        color += vec3(0.1, 0.15, 0.2) * (1.0 - edgeDist / (edgeWidth * 0.5));
+      }
+      
+      gl_FragColor = vec4(color, 1.0);
+    }
+  `;
+  
+  const program = createShaderProgram(gl, vertexShader, fragmentShader);
+  gl.useProgram(program);
+  
+  const texture = gl.createTexture();
+  gl.bindTexture(gl.TEXTURE_2D, texture);
+  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, prev.width, prev.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, prev.data);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
+  
+  const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
+  const buffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
+  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
+  
+  const positionLoc = gl.getAttribLocation(program, 'position');
+  gl.enableVertexAttribArray(positionLoc);
+  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
+  
+  gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
+  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), ctx.width, ctx.height);
+  gl.uniform1f(gl.getUniformLocation(program, 'uDisplacement'), displacement);
+  gl.uniform1f(gl.getUniformLocation(program, 'uShardCount'), shardCount);
+  gl.uniform1f(gl.getUniformLocation(program, 'uSeed'), seed);
+  
+  gl.viewport(0, 0, ctx.width, ctx.height);
+  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
+  
+  const pixels = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  gl.readPixels(0, 0, ctx.width, ctx.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
+  
+  const flipped = new Uint8ClampedArray(ctx.width * ctx.height * 4);
+  for (let y = 0; y < ctx.height; y++) {
+    for (let x = 0; x < ctx.width; x++) {
+      const srcIdx = ((ctx.height - 1 - y) * ctx.width + x) * 4;
+      const dstIdx = (y * ctx.width + x) * 4;
+      flipped[dstIdx] = pixels[srcIdx];
+      flipped[dstIdx + 1] = pixels[srcIdx + 1];
+      flipped[dstIdx + 2] = pixels[srcIdx + 2];
+      flipped[dstIdx + 3] = pixels[srcIdx + 3];
+    }
   }
   
-  return out;
+  gl.deleteTexture(texture);
+  gl.deleteBuffer(buffer);
+  gl.deleteProgram(program);
+  
+  return { width: ctx.width, height: ctx.height, data: flipped };
 }
\ No newline at end of file

</tool.toolu_01G14fWBfgNasHmcjgsT5njb>

# TOOL RESULT

ID: toolu_01G14fWBfgNasHmcjgsT5njb

<tool.toolu_01G14fWBfgNasHmcjgsT5njb>

</tool.toolu_01G14fWBfgNasHmcjgsT5njb>
